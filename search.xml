<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ibjx</title>
    <url>/2020/02/25/ibjx/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>123</category>
      </categories>
      <tags>
        <tag>123</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode支持的markdown语法参考</title>
    <url>/2020/01/02/VsCode%E6%94%AF%E6%8C%81%E7%9A%84markdown%E8%AF%AD%E6%B3%95%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<div align="center" style="color:red">VS Code 使用 Markdown 编写文档</div>

<h2 id="1-文本部分"><a href="#1-文本部分" class="headerlink" title="1. 文本部分"></a>1. 文本部分</h2><a id="more"></a>
<h3 id="1-1-斜体和粗体，删除线"><a href="#1-1-斜体和粗体，删除线" class="headerlink" title="1.1 斜体和粗体，删除线"></a>1.1 斜体和粗体，删除线</h3><p>使用 * 和 ** 表示斜体和粗体。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">示例：这是<span class="strong">*斜体*</span>，这是*<span class="strong">*粗体*</span><span class="strong">*。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这是<em>斜体</em>，这是<strong>粗体</strong>。<br>使用 ~~ 表示删除线。<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">~~这是一段错误的文本。</span><br></pre></td></tr></table></figure></li>
<li><del>这是一段错误的文本。</del></li>
</ul>
<h3 id="1-2-分级标题"><a href="#1-2-分级标题" class="headerlink" title="1.2 分级标题"></a>1.2 分级标题</h3><p>使用 === 表示一级标题，使用 — 表示二级标题。<br><img src="https://upload-images.jianshu.io/upload_images/1414656-4697bde7bd330473.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/654/format/webp" alt=""><br>你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。<br><img src="https://upload-images.jianshu.io/upload_images/1414656-4e1275ac4a64ba20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/527/format/webp" alt=""></p>
<h3 id="1-3-常用-Emoji-amp-Font-Awesome"><a href="#1-3-常用-Emoji-amp-Font-Awesome" class="headerlink" title="1.3 常用 Emoji &amp; Font-Awesome"></a>1.3 常用 Emoji &amp; Font-Awesome</h3><p><img src="https://img2018.cnblogs.com/blog/1683299/201909/1683299-20190911231431885-470598308.png" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1414656-b1f92b959dfa863e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/301/format/webp" alt=""><br><a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">更多emoji查看</a></p>
<h3 id="1-4-引用和注脚"><a href="#1-4-引用和注脚" class="headerlink" title="1.4 引用和注脚"></a>1.4 引用和注脚</h3><p>使用 [^keyword] 表示注脚。</p>
<h2 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>上标：30^th^</span><br><span class="line"><span class="bullet">- </span>下标：H~2~O</span><br><span class="line"><span class="bullet">- </span>脚注：Content [^1]</span><br><span class="line">[<span class="symbol">^1</span>]:<span class="link">Hi 这里是一个注脚，会自动拉到最后面排版</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上标：30^th^</li>
<li>下标：H<del>2</del>O</li>
<li>脚注：Content [^1]<br>[^1]:Hi 这里是一个注脚，会自动拉到最后面排版</li>
</ul>
<h2 id="缩略："><a href="#缩略：" class="headerlink" title="缩略："></a>缩略：</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">*[HTML]: 超文本标记语言</span><br><span class="line">*[W3C]:  World Wide Web Consortium</span><br><span class="line">The HTML specification</span><br><span class="line">is maintained by the W3C.</span><br></pre></td></tr></table></figure>
<p>*[HTML]: 超文本标记语言<br>*[W3C]:  World Wide Web Consortium<br>The HTML specification<br>is maintained by the W3C.</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">这里要有空格隔开中文</span><br><span class="line">*<span class="string">[月]</span>: yue4</span><br><span class="line">*<span class="string">[辍]</span>: chuo4</span><br><span class="line">明 明 如 月，何 时 可 辍</span><br></pre></td></tr></table></figure>
<p>*[月]: yue4<br>*[辍]: chuo4<br>明 明 如 月，何 时 可 辍</p>
<h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">==<span class="attribute">marked</span>==</span><br></pre></td></tr></table></figure>

<p>==marked==</p>
<h3 id="1-5-外链接"><a href="#1-5-外链接" class="headerlink" title="1.5 外链接"></a>1.5 外链接</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">关键词</span>](<span class="link">链接地址 "（可选）添加一个标题"</span>)</span><br><span class="line">图片带链接 </span><br><span class="line"><span class="code">    [![](.//img/01.png '百度')](http://www.baidu.com)</span></span><br></pre></td></tr></table></figure>
<p>这里是去 <a href="http://www.baidu.com/" target="_blank" rel="noopener" title="百度一下">百度</a> 的链接</p>
<p><a href="https://user.qzone.qq.com/1535045887/" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1683299/201909/1683299-20190911232801569-1228742801.jpg" alt="" title="本人QQ:1535045887"></a></p>
<h3 id="1-6文字引用"><a href="#1-6文字引用" class="headerlink" title="1.6文字引用"></a>1.6文字引用</h3><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">&gt;                   <span class="keyword">Only</span> <span class="keyword">action</span> can relieve the uneasiness.</span><br></pre></td></tr></table></figure>
<blockquote>
<pre><code>Only action can relieve the uneasiness.</code></pre></blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">多层嵌套</span><br><span class="line">&gt;天大彭于晏</span><br><span class="line"><span class="meta">&gt;&gt;</span>天大彭于晏</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;天大彭于晏</span><br></pre></td></tr></table></figure>
<blockquote>
<p>天大彭于晏</p>
<blockquote>
<p>天大彭于晏</p>
<blockquote>
<p>天大彭于晏</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="1-7-内容目录"><a href="#1-7-内容目录" class="headerlink" title="1.7 内容目录"></a>1.7 内容目录</h3><p>在段落中填写 [TOC] 以显示全文内容的目录结构。</p>
<blockquote>
<p>[TOC]</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/1414656-4558e18cf543a874.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/376/format/webp" alt=""></p>
<h3 id="1-8行内标记"><a href="#1-8行内标记" class="headerlink" title="1.8行内标记"></a>1.8行内标记</h3><p>注：用 ` 标记代码块将变成一行<br>代码</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">标记之外`hello </span><br><span class="line">world`标记之外</span><br></pre></td></tr></table></figure>
<p>标记之外<code>hello 
world</code>标记之外</p>
<h3 id="1-9支持内嵌CSS样式"><a href="#1-9支持内嵌CSS样式" class="headerlink" title="1.9支持内嵌CSS样式"></a>1.9支持内嵌CSS样式</h3><p>代码:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: #AD5D0F;font-size: 30px; font-family: '宋体';"</span>&gt;</span>内联样式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p style="color: #AD5D0F;font-size: 30px; font-family: '宋体';">内联样式</p>

<h3 id="1-10-支持html标签"><a href="#1-10-支持html标签" class="headerlink" title="1.10 支持html标签"></a>1.10 支持html标签</h3><p>直接使用 HTML 标签，可以设置文字居中，字体颜色等样色(HTML 语法)<br>代码:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="meta">align</span>=<span class="string">"center"</span> style=<span class="string">"color:red"</span>&gt;VS <span class="meta">Code</span> 使用 <span class="keyword">Markdown </span>编写文档&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>演示:<br>        <div align="center" style="color:red">VS Code 使用 Markdown 编写文档</div></p>
<h2 id="2-标签分类"><a href="#2-标签分类" class="headerlink" title="2. 标签分类"></a>2. 标签分类</h2><p>在编辑区任意行的列首位置输入以下代码给文稿标签：</p>
<p>标签： 数学 英语 Markdown<br>Tags： 数学 英语 Markdown</p>
<h3 id="2-0-常用布局"><a href="#2-0-常用布局" class="headerlink" title="2.0 常用布局"></a>2.0 常用布局</h3><h3 id="2-1-无序列表"><a href="#2-1-无序列表" class="headerlink" title="2.1 无序列表"></a>2.1 无序列表</h3><p>使用 *，+，- 表示无序列表。</p>
<p>示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>无序列表项 一</span><br><span class="line"><span class="bullet">* </span>无序列表项 二</span><br><span class="line"><span class="bullet">+ </span>无序列表项 三</span><br></pre></td></tr></table></figure>
<p>效果:</p>
<ul>
<li>无序列表项 一</li>
</ul>
<ul>
<li>无序列表项 二</li>
</ul>
<ul>
<li>无序列表项 三<h3 id="2-2-有序列表（ol-li）"><a href="#2-2-有序列表（ol-li）" class="headerlink" title="2.2 有序列表（ol-li）"></a>2.2 有序列表（ol-li）</h3>使用数字和点表示有序列表。<br>示例：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表项 一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表项 二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表项 三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol >
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">注：序列.后 保持空格</span><br><span class="line"><span class="number">1.</span> one</span><br><span class="line"><span class="number">2.</span> two</span><br><span class="line"><span class="number">3.</span> three</span><br></pre></td></tr></table></figure>
演示:</li>
</ul>
<ol>
<li>one</li>
<li>two</li>
<li>three</li>
</ol>
<h3 id="2-3-行内代码块"><a href="#2-3-行内代码块" class="headerlink" title="2.3 行内代码块"></a>2.3 行内代码块</h3><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">用 ```代码```进行包裹</span><br></pre></td></tr></table></figure>
<h3 id="2-4-插入图像"><a href="#2-4-插入图像" class="headerlink" title="2.4 插入图像"></a>2.4 插入图像</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">使用 !<span class="selector-attr">[]</span>(图片链接地址<span class="string">'描述'</span>) 插入图像。</span><br></pre></td></tr></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/1683299/201909/1683299-20190911233054628-1216522735.jpg" alt="" title="我是一名程序员"></p>
<h3 id="2-5-表格支持"><a href="#2-5-表格支持" class="headerlink" title="2.5 表格支持"></a>2.5 表格支持</h3><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">|<span class="string"> 项目        </span>|<span class="string"> 价格   </span>|<span class="string">  数量  </span>|</span><br><span class="line">|<span class="string"> --------   </span>|<span class="string"> -----:  </span>|<span class="string"> :----:  </span>|</span><br><span class="line">|<span class="string"> 计算机     </span>|<span class="string"> \$1600 </span>|<span class="string">   5     </span>|</span><br><span class="line">|<span class="string"> 手机        </span>|<span class="string">   \$12   </span>|<span class="string">   12   </span>|</span><br><span class="line">|<span class="string"> 管线        </span>|<span class="string">    \$1    </span>|<span class="string">  234  </span>|</span><br><span class="line">|<span class="string"> &gt; </span>|<span class="string"> ce    </span>|<span class="string">   ce</span>|</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>项目</th>
<th align="right">价格</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td>计算机</td>
<td align="right">$1600</td>
<td align="center">5</td>
</tr>
<tr>
<td>手机</td>
<td align="right">$12</td>
<td align="center">12</td>
</tr>
<tr>
<td>管线</td>
<td align="right">$1</td>
<td align="center">234</td>
</tr>
<tr>
<td>&gt;</td>
<td align="right">ce</td>
<td align="center">ce</td>
</tr>
</tbody></table>
<h3 id="2-6-定义型列表"><a href="#2-6-定义型列表" class="headerlink" title="2.6 定义型列表"></a>2.6 定义型列表</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">名词 <span class="number">1</span></span><br><span class="line">: 定义 <span class="number">1</span>（左侧有一个可见的冒号和四个不可见的空格）</span><br><span class="line"></span><br><span class="line">代码块 <span class="number">2</span></span><br><span class="line">: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</span><br></pre></td></tr></table></figure>
<dl><dt>名词 1</dt><dd>定义 1（左侧有一个可见的冒号和四个不可见的空格）</dd></dl><dl><dt>代码块 2</dt><dd>这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</dd></dl><h3 id="2-7表格对齐"><a href="#2-7表格对齐" class="headerlink" title="2.7表格对齐"></a>2.7表格对齐</h3><p>注： : 代表对齐方式 ,** : 与 | 之间不要有空格**，否则对齐会有些不兼容</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">代码</span><br><span class="line"></span><br><span class="line">|    a    |       b       |      c     |</span><br><span class="line">|<span class="symbol">:-------</span><span class="symbol">:|</span><span class="symbol">:-------------</span> | ----------<span class="symbol">:|</span></span><br><span class="line">|   居中  |     左对齐    |   右对齐   |</span><br><span class="line">|=========|===============|============|</span><br></pre></td></tr></table></figure>
<p>演示</p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="left">b</th>
<th align="right">c</th>
</tr>
</thead>
<tbody><tr>
<td align="center">居中</td>
<td align="left">左对齐</td>
<td align="right">右对齐</td>
</tr>
<tr>
<td align="center">=========</td>
<td align="left">===============</td>
<td align="right">============</td>
</tr>
</tbody></table>
<h3 id="2-8-Html-标签"><a href="#2-8-Html-标签" class="headerlink" title="2.8 Html 标签"></a>2.8 Html 标签</h3><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：<br>设置colspan，rowspan<br><a href="https://blog.csdn.net/loongshawn/article/details/72829090?utm_source=blogxgwz6" target="_blank" rel="noopener">Markdown表格之合并单元格效果</a></p>
<h3 id="2-8-待办事宜-Todo-列表"><a href="#2-8-待办事宜-Todo-列表" class="headerlink" title="2.8 待办事宜 Todo 列表"></a>2.8 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：<br><img src="https://upload-images.jianshu.io/upload_images/1414656-3c07364e15ba43dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/773/format/webp" alt=""></p>
<h2 id="3-补充"><a href="#3-补充" class="headerlink" title="3.补充"></a>3.补充</h2><h3 id="3-1定义型列表"><a href="#3-1定义型列表" class="headerlink" title="3.1定义型列表"></a>3.1定义型列表</h3><p>注：解释型定义</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">代码：</span><br><span class="line">        Markdown   </span><br><span class="line"><span class="title">        : 轻量级文本标记语言，可以转换成html，pdf等格式  //  开头一个`:</span>` + `Tab` 或 四个空格</span><br></pre></td></tr></table></figure>
<p>Markdown<br>  : 轻量级文本标记语言，可以转换成html，pdf等格式  //  开头一个<code>:</code> + <code>Tab</code> 或 四个空格</p>
<h3 id="3-2自动邮箱链接"><a href="#3-2自动邮箱链接" class="headerlink" title="3.2自动邮箱链接"></a>3.2自动邮箱链接</h3><p>代码:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">xxx</span>@<span class="keyword">outlook</span>.<span class="keyword">com</span>&gt;</span><br></pre></td></tr></table></figure>
<p>演示<br>    <a href="mailto:&#49;&#53;&#x33;&#x35;&#48;&#52;&#53;&#56;&#56;&#55;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#49;&#53;&#x33;&#x35;&#48;&#52;&#53;&#56;&#56;&#55;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#109;</a></p>
<h3 id="3-3字体-字号与颜色"><a href="#3-3字体-字号与颜色" class="headerlink" title="3.3字体,字号与颜色"></a>3.3字体,字号与颜色</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;font <span class="attribute">face</span>=<span class="string">"STCAIYUN"</span>&gt;我是华文彩云&lt;/font&gt;</span><br><span class="line">&lt;font <span class="attribute">color</span>=gray <span class="attribute">size</span>=5&gt;color=gray&lt;/font&gt;</span><br><span class="line">&lt;font color=  #0099ff <span class="attribute">size</span>=5 <span class="attribute">face</span>=<span class="string">"黑体"</span>&gt;color=#0099ff <span class="attribute">size</span>=5 <span class="attribute">face</span>=<span class="string">"黑体"</span>&lt;/font&gt;</span><br></pre></td></tr></table></figure>
<p><font face="STCAIYUN">我是华文彩云</font><br><font color=gray size=5>color=gray</font><br><font color=#0099ff size=5 face="黑体">color=#0099ff size=5 face=”黑体”</font><br><font face = "楷体"><br>Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。</font><br>##4. 数学和LaTeX<br>$ 表示行内公式：</p>
<p>质能守恒方程可以用一个很简洁的方程式 E=mc^2 来表达。</p>
<p>$$ 表示整行公式：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\sum_&#123;i=<span class="number">1</span>&#125;^n a_i=<span class="number">0</span><span class="symbol">$</span><span class="symbol">$</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$E</span>=mc^2$</span></span><br></pre></td></tr></table></figure>
<p>$$\sum_{i=1}^n a_i=0$$<br>$ E=mc^2$</p>
<h3 id="4-1-常用计算速查"><a href="#4-1-常用计算速查" class="headerlink" title="4.1 常用计算速查"></a>4.1 常用计算速查</h3><h3 id="4-2省略号"><a href="#4-2省略号" class="headerlink" title="4.2省略号"></a>4.2省略号</h3><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">a_1</span>,<span class="built_in">a_2</span>,\ldots,<span class="built_in">a_n</span>$</span><br><span class="line">$ <span class="built_in">a_1</span>+<span class="built_in">a_2</span>+\ldots+<span class="built_in">a_n</span>$</span><br><span class="line">$ <span class="built_in">a_1</span>+<span class="built_in">a_2</span>+\cdots+<span class="built_in">a_n</span>$</span><br></pre></td></tr></table></figure>
<p>$ a_1,a_2,\ldots,a_n$<br>$ a_1+a_2+\ldots+a_n$<br>$ a_1+a_2+\cdots+a_n$</p>
<h3 id="4-3字体"><a href="#4-3字体" class="headerlink" title="4.3字体"></a>4.3字体</h3><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> \mathsf&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125;   <span class="symbol">$</span></span><br><span class="line"><span class="symbol">$</span> \mathcal&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; <span class="symbol">$</span></span><br><span class="line"><span class="symbol">$</span> \mathscr&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; <span class="symbol">$</span></span><br><span class="line"><span class="symbol">$</span> \mathfrak&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; <span class="symbol">$</span></span><br></pre></td></tr></table></figure>
<p>$ \mathsf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}   $<br>$ \mathcal{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $<br>$ \mathscr{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $<br>$ \mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $</p>
<h3 id="4-4常用公式"><a href="#4-4常用公式" class="headerlink" title="4.4常用公式"></a>4.4常用公式</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$x_i^<span class="number">2</span>$，$x_i^<span class="number">2</span>+x_&#123;i^<span class="number">2</span>&#125;$，$<span class="number">10</span>^&#123;<span class="number">10</span>&#125;$</span><br><span class="line">$\log_2 x$</span><br><span class="line">$&#123;x^y&#125;^z+x^&#123;y^z&#125;$</span><br><span class="line">$\sum^&#123;j<span class="number">-1</span>&#125;_&#123;k=<span class="number">0</span>&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125; z_k&#125;$</span><br><span class="line">$\sum_&#123;i=<span class="number">0</span>&#125;^n i^<span class="number">2</span> = \frac&#123;(n^<span class="number">2</span>+n)(<span class="number">2</span>n+<span class="number">1</span>)&#125;&#123;<span class="number">6</span>&#125;$</span><br><span class="line">$f(x_1,x_x,\ldots,x_n) = x_1^<span class="number">2</span> + x_2^<span class="number">2</span> + \cdots + x_n^<span class="number">2</span> $</span><br><span class="line">$\displaystyle \lim_&#123;t \to <span class="number">0</span>&#125; \<span class="built_in">int</span>_t^<span class="number">1</span> f(t)\, dt$</span><br><span class="line">$\lim_&#123;t \to <span class="number">0</span>&#125; \<span class="built_in">int</span>_t^<span class="number">1</span> f(t)\, dt$.</span><br></pre></td></tr></table></figure>
<p>$x_i^2$，$x_i^2+x_{i^2}$，$10^{10}$<br>$\log_2 x$<br>${x^y}^z+x^{y^z}$<br>$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$<br>$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$<br>$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $<br>$\displaystyle \lim_{t \to 0} \int_t^1 f(t), dt$<br>$\lim_{t \to 0} \int_t^1 f(t), dt$.</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">如果需要大小调整，大小写切换写</span><br><span class="line">$$<span class="symbol">\B</span>iggl(<span class="symbol">\b</span>iggl(<span class="symbol">\B</span>igl(<span class="symbol">\b</span>igl((x)<span class="symbol">\b</span>igr)<span class="symbol">\B</span>igr)<span class="symbol">\b</span>iggr)<span class="symbol">\B</span>iggr) gives (((((x)))))$$</span><br></pre></td></tr></table></figure>
<p>$$\Biggl(\biggl(\Bigl(\bigl((x)\bigr)\Bigr)\biggr)\Biggr) gives (((((x)))))$$</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">括号自适应大小</span><br><span class="line"><span class="symbol">$</span><span class="symbol">$</span>(\<span class="built-in">frac</span>&#123;\<span class="built-in">sqrt</span> x&#125;&#123;y^<span class="number">3</span>&#125;)<span class="symbol">$</span><span class="symbol">$</span></span><br><span class="line"><span class="symbol">$</span><span class="symbol">$</span> \left(\<span class="built-in">frac</span>&#123;\<span class="built-in">sqrt</span> x&#125;&#123;y^<span class="number">3</span>&#125;\right)<span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure>
<p>$$(\frac{\sqrt x}{y^3})$$<br>$$ \left(\frac{\sqrt x}{y^3}\right)$$</p>
<h3 id="4-5等式"><a href="#4-5等式" class="headerlink" title="4.5等式"></a>4.5等式</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$$</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;aligned&#125;</span></span></span></span><br><span class="line"><span class="formula">        a &amp;= b + c <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">        &amp;= d + e + f + g <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">        &amp;= h + i</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;aligned&#125;</span></span></span></span><br><span class="line"><span class="formula">$$</span></span><br></pre></td></tr></table></figure>
<p>$$<br>    \begin{aligned}<br>        a &amp;= b + c \<br>        &amp;= d + e + f + g \<br>        &amp;= h + i<br>    \end{aligned}<br>$$</p>
<h3 id="4-6矩阵"><a href="#4-6矩阵" class="headerlink" title="4.6矩阵"></a>4.6矩阵</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;matrix&#125;</span></span></span></span><br><span class="line"><span class="formula">    1 &amp; x &amp; x^2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    1 &amp; y &amp; y^2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    1 &amp; z &amp; z^2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;matrix&#125;</span></span></span></span><br><span class="line"><span class="formula">$</span> , <span class="formula">$</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;pmatrix&#125;</span></span> </span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;pmatrix&#125;</span></span></span></span><br><span class="line"><span class="formula">$</span> , <span class="formula">$   </span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;bmatrix&#125;</span></span> </span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;bmatrix&#125;</span></span></span></span><br><span class="line"><span class="formula">$</span> , <span class="formula">$</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;Bmatrix&#125;</span></span> </span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;Bmatrix&#125;</span></span> </span></span><br><span class="line"><span class="formula">$</span> , <span class="formula">$</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;vmatrix&#125;</span></span> </span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;vmatrix&#125;</span></span> </span></span><br><span class="line"><span class="formula">$</span> , <span class="formula">$</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;Vmatrix&#125;</span></span> </span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;Vmatrix&#125;</span></span> </span></span><br><span class="line"><span class="formula">$</span></span><br></pre></td></tr></table></figure>
<p>$<br>    \begin{matrix}<br>    1 &amp; x &amp; x^2 \<br>    1 &amp; y &amp; y^2 \<br>    1 &amp; z &amp; z^2 \<br>    \end{matrix}<br>$ , $<br>    \begin{pmatrix}<br>    1 &amp; 2 \<br>    1 &amp; 2 \<br>    \end{pmatrix}<br>$ , $<br>    \begin{bmatrix}<br>    1 &amp; 2 \<br>    1 &amp; 2 \<br>    \end{bmatrix}<br>$ , $<br>    \begin{Bmatrix}<br>    1 &amp; 2 \<br>    1 &amp; 2 \<br>    \end{Bmatrix}<br>$ , $<br>    \begin{vmatrix}<br>    1 &amp; 2 \<br>    1 &amp; 2 \<br>    \end{vmatrix}<br>$ , $<br>    \begin{Vmatrix}<br>    1 &amp; 2 \<br>    1 &amp; 2 \<br>    \end{Vmatrix}<br>$</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">省略元素 <span class="tag">\<span class="name">cdots</span></span> ⋯ <span class="tag">\<span class="name">ddots</span></span> ⋱ vdots ⋮</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;matrix&#125;</span></span></span></span><br><span class="line"><span class="formula">    a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; a_&#123;13&#125; &amp; <span class="tag">\<span class="name">cdots</span></span> &amp; a_&#123;1n&#125; <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; a_&#123;23&#125; &amp; <span class="tag">\<span class="name">cdots</span></span> &amp; a_&#123;2n&#125; <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">vdots</span></span> &amp; <span class="tag">\<span class="name">vdots</span></span> &amp; <span class="tag">\<span class="name">vdots</span></span> &amp; <span class="tag">\<span class="name">ddots</span></span> &amp; <span class="tag">\<span class="name">vdots</span></span> <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    a_&#123;n1&#125; &amp; a_&#123;n2&#125; &amp; a_&#123;n3&#125; &amp; <span class="tag">\<span class="name">cdots</span></span> &amp; a_&#123;2n&#125; <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;matrix&#125;</span></span></span></span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"></span><br><span class="line"><span class="formula">$$ <span class="tag">\<span class="name">left</span><span class="string">[</span></span></span></span><br><span class="line"><span class="formula"><span class="tag"><span class="string">\begin&#123;array&#125;&#123;cc|c&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag"><span class="string">  1&amp;2&amp;3\\</span></span></span></span><br><span class="line"><span class="formula"><span class="tag"><span class="string">  4&amp;5&amp;6</span></span></span></span><br><span class="line"><span class="formula"><span class="tag"><span class="string">\end&#123;array&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag"><span class="string">\right]</span></span> </span></span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"><span class="formula">  f(n) =</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">begin</span><span class="string">&#123;cases&#125;</span></span></span></span><br><span class="line"><span class="formula">n/2,  &amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;if $n$ is even&#125;</span></span> <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">3n+1, &amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;if $n$ is odd&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;cases&#125;</span></span></span></span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">left</span></span>.</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">begin</span><span class="string">&#123;array&#125;</span><span class="string">&#123;l&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">text</span><span class="string">&#123;if $n$ is even:&#125;</span></span>&amp;n/2<span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">text</span><span class="string">&#123;if $n$ is odd:&#125;</span></span>&amp;3n+1</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;array&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">right</span></span><span class="tag">\<span class="name">&#125;</span></span></span></span><br><span class="line"><span class="formula">=f(n)</span></span><br><span class="line"><span class="formula">$$</span></span><br></pre></td></tr></table></figure>


<p>$$<br>    \begin{matrix}<br>    a_{11} &amp; a_{12} &amp; a_{13} &amp; \cdots &amp; a_{1n} \<br>    a_{21} &amp; a_{22} &amp; a_{23} &amp; \cdots &amp; a_{2n} \<br>    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>    a_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \cdots &amp; a_{2n} \<br>    \end{matrix}<br>$$</p>
<p>$$ \left[<br>\begin{array}{cc|c}<br>  1&amp;2&amp;3\<br>  4&amp;5&amp;6<br>\end{array}<br>\right]<br>$$</p>
<p>$$<br>  f(n) =<br>\begin{cases}<br>n/2,  &amp; \text{if $n$ is even} \<br>3n+1, &amp; \text{if $n$ is odd}<br>\end{cases}<br>$$</p>
<p>$$<br>\left.<br>\begin{array}{l}<br>\text{if $n$ is even:}&amp;n/2\<br>\text{if $n$ is odd:}&amp;3n+1<br>\end{array}<br>\right}<br>=f(n)<br>$$</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">上下行的间距调整 ex</span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"><span class="formula">f(n) =</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">begin</span><span class="string">&#123;cases&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">frac</span><span class="string">&#123;n&#125;</span><span class="string">&#123;2&#125;</span></span>,  &amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;if $n$ is even&#125;</span></span> <span class="tag">\<span class="name">\</span><span class="string">[5ex]</span></span></span></span><br><span class="line"><span class="formula">3n+1, &amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;if $n$ is odd&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;cases&#125;</span></span></span></span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">left</span></span><span class="tag">\<span class="name">&#123;</span></span> </span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">begin</span><span class="string">&#123;array&#125;</span><span class="string">&#123;c&#125;</span></span></span></span><br><span class="line"><span class="formula">a_1x+b_1y+c_1z=d_1 <span class="tag">\<span class="name">\</span></span> </span></span><br><span class="line"><span class="formula">a_2x+b_2y+c_2z=d_2 <span class="tag">\<span class="name">\</span></span> </span></span><br><span class="line"><span class="formula">a_3x+b_3y+c_3z=d_3</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;array&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">right</span></span>. </span></span><br><span class="line"><span class="formula">$$</span></span><br></pre></td></tr></table></figure>
<p>$$<br>f(n) =<br>\begin{cases}<br>\frac{n}{2},  &amp; \text{if $n$ is even} \[5ex]<br>3n+1, &amp; \text{if $n$ is odd}<br>\end{cases}<br>$$</p>
<p>$$<br>\left{<br>\begin{array}{c}<br>a_1x+b_1y+c_1z=d_1 \<br>a_2x+b_2y+c_2z=d_2 \<br>a_3x+b_3y+c_3z=d_3<br>\end{array}<br>\right.<br>$$</p>
<h3 id="aligned-对齐"><a href="#aligned-对齐" class="headerlink" title="aligned 对齐"></a>aligned 对齐</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$$ </span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">left</span></span><span class="tag">\<span class="name">&#123;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">begin</span><span class="string">&#123;aligned&#125;</span></span> </span></span><br><span class="line"><span class="formula">a_1x+b_1y+c_1z &amp;=d_1+e_1 <span class="tag">\<span class="name">\</span></span> </span></span><br><span class="line"><span class="formula">a_2x+b_2y&amp;=d_2 <span class="tag">\<span class="name">\</span></span> </span></span><br><span class="line"><span class="formula">a_3x+b_3y+c_3z &amp;=d_3 </span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;aligned&#125;</span></span> </span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">right</span></span>. </span></span><br><span class="line"><span class="formula">$$</span></span><br></pre></td></tr></table></figure>
<p>$$<br>\left{<br>\begin{aligned}<br>a_1x+b_1y+c_1z &amp;=d_1+e_1 \<br>a_2x+b_2y&amp;=d_2 \<br>a_3x+b_3y+c_3z &amp;=d_3<br>\end{aligned}<br>\right.<br>$$</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">继续用em调整行距</span><br><span class="line"><span class="formula">$$<span class="tag">\<span class="name">begin</span><span class="string">&#123;cases&#125;</span></span></span></span><br><span class="line"><span class="formula">a_1x+b_1y+c_1z=d_1 <span class="tag">\<span class="name">\</span><span class="string">[2ex]</span></span> </span></span><br><span class="line"><span class="formula">a_2x+b_2y+c_2z=d_2 <span class="tag">\<span class="name">\</span><span class="string">[2ex]</span></span> </span></span><br><span class="line"><span class="formula">a_3x+b_3y+c_3z=d_3</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;cases&#125;</span></span></span></span><br><span class="line"><span class="formula">$$</span></span><br></pre></td></tr></table></figure>
<p>$$\begin{cases}<br>a_1x+b_1y+c_1z=d_1 \[2ex]<br>a_2x+b_2y+c_2z=d_2 \[2ex]<br>a_3x+b_3y+c_3z=d_3<br>\end{cases}<br>$$</p>
<h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><h2 id="5-流程图"><a href="#5-流程图" class="headerlink" title="5.流程图"></a>5.流程图</h2><h3 id="5-1简单流程图"><a href="#5-1简单流程图" class="headerlink" title="5.1简单流程图"></a>5.1简单流程图</h3><p><a href="http://flowchart.js.org/" target="_blank" rel="noopener">流程图语法参考</a></p>
<h3 id="5-2序列图x"><a href="#5-2序列图x" class="headerlink" title="5.2序列图x`"></a>5.2序列图x`</h3><p>代码:<br><img src="./%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt=""><br>效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A-&gt;&gt;B: 你好</span><br><span class="line">Note left of A: 我在左边 </span><br><span class="line">Note right of B: 我在右边</span><br><span class="line">B--&gt;A: 很高兴认识你</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">起床-&gt;吃饭: 稀饭油条</span><br><span class="line">吃饭-&gt;上班: 不要迟到了</span><br><span class="line">上班-&gt;午餐: 吃撑了</span><br><span class="line">上班-&gt;下班:</span><br><span class="line">Note right of 下班: 下班了</span><br><span class="line">下班-&gt;回家:</span><br><span class="line">Note right of 回家: 到家了</span><br><span class="line">回家--&gt;&gt;起床:</span><br><span class="line">Note left of 起床: 新的一天</span><br></pre></td></tr></table></figure>
<p>未完待续…. </p>
<h3 id="5-3mermaid-甘特图"><a href="#5-3mermaid-甘特图" class="headerlink" title="5.3mermaid 甘特图"></a>5.3mermaid 甘特图</h3><h3 id="5-4-puml-序列图"><a href="#5-4-puml-序列图" class="headerlink" title="5.4 puml 序列图"></a>5.4 puml 序列图</h3><h3 id="5-5-dot"><a href="#5-5-dot" class="headerlink" title="5.5 dot"></a>5.5 dot</h3>]]></content>
      <tags>
        <tag>VsCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Homework Shell</title>
    <url>/2020/01/01/Homework%20Shell/</url>
    <content><![CDATA[<h2 id="操作系统-Homework-Shell"><a href="#操作系统-Homework-Shell" class="headerlink" title="操作系统 Homework: Shell"></a>操作系统 Homework: Shell</h2><p><a href="https://pdos.csail.mit.edu/6.828/2016/homework/xv6-shell.html" target="_blank" rel="noopener">Homework: shell</a></p>
<p>通过此次作业，将会了解到 Shell 的工作原理，以及类 Linux 系统的新进程到底是如何产生的。</p>
<a id="more"></a>
<p>首先自然是看懂 main 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> fd, r;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read and run input commands.</span></span><br><span class="line">  <span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">'c'</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">'d'</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">' '</span>)&#123;</span><br><span class="line">      <span class="comment">// 如果只是 cd 命令，则切换文件夹后继续等待命令</span></span><br><span class="line">      <span class="comment">// Clumsy but will have to do for now.</span></span><br><span class="line">      <span class="comment">// Chdir has no effect on the parent if run in the child.</span></span><br><span class="line">      <span class="comment">// 一般写完命令敲回车，这里就是把回车改为'\0'</span></span><br><span class="line">      buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></span><br><span class="line">      <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"cannot cd %s\n"</span>, buf+<span class="number">3</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若不是 cd 命令，则fork出子程序尝试运行命令</span></span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">      runcmd(parsecmd(buf));</span><br><span class="line">    <span class="comment">// 等待子进程完成</span></span><br><span class="line">    wait(&amp;r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环调用 getcmd 函数读入命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">getcmd(<span class="keyword">char</span> *buf, <span class="keyword">int</span> nbuf)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(fileno(<span class="built_in">stdin</span>)))  <span class="comment">// 判断标准输入是否为终端</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"6.828$ "</span>);  <span class="comment">// 是终端则显示提示符</span></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, nbuf);</span><br><span class="line">  fgets(buf, nbuf, <span class="built_in">stdin</span>);  <span class="comment">// 从标准输入读入nbuf个字符到 buf 中</span></span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0</span>) <span class="comment">// EOF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读入命令并确定不是 cd 命令后，执行关键语句<br><code>runcmd(parsecmd(buf))</code>,显然是将 buf 用 parsecmd 解析后，送入 runcmd 运行。我们暂时并不关心如何解析，无非是一些字符串处理，提取关键符号确定类型。先看 runcmd 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Execute cmd.  Never returns.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">runcmd(struct cmd *cmd)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> p[<span class="number">2</span>], r;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">execcmd</span> *<span class="title">ecmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipecmd</span> *<span class="title">pcmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">redircmd</span> *<span class="title">rcmd</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(cmd == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">switch</span>(cmd-&gt;type)&#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"unknown runcmd\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">    ecmd = (struct execcmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"exec not implemented\n"</span>);</span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'&gt;'</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">    rcmd = (struct redircmd*)cmd;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"redir not implemented\n"</span>);</span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    runcmd(rcmd-&gt;cmd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'|'</span>:</span><br><span class="line">    pcmd = (struct pipecmd*)cmd;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pipe not implemented\n"</span>);</span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可看出，parsecmd 把命令分成了3个类型，分别是可执行命令，重定向命令，以及管道命令。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>可执行命令</strong><br>在文中找到关键提示：</p>
<blockquote>
<p>You may want to change the 6.828 shell to always try /bin, if the program doesn’t exist in the current working directory, so that below you don’t have to type “/bin” for each program. If you are ambitious you can implement support for a PATH variable.</p>
</blockquote>
<p>也就是说对于 ls 这个存在的命令，我们只需要想办法将命令引导到 /bin/目录下寻找即可。这里涉及到 linux 系统调用的一个关键函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> mode)</span></span></span><br></pre></td></tr></table></figure>
<p>它的作用是检查能否对某个文件(pathname)执行某个操作(mode)，操作的主要模式有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R_OK      <span class="comment">// 测试读许可权</span></span><br><span class="line">W_OK      <span class="comment">// 测试写许可权</span></span><br><span class="line">X_OK      <span class="comment">// 测试执行许可权</span></span><br><span class="line">F_OK      <span class="comment">// 测试文件是否存在</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，测试成功返回值为0。失败为-1。有了这个函数，可以把之前的类型为’ ‘的部分改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">  ecmd = (struct execcmd*)cmd;</span><br><span class="line">  <span class="keyword">if</span> (ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// fprintf(stderr, "exec not implemented\n");</span></span><br><span class="line">  <span class="keyword">if</span> (access(ecmd-&gt;argv[<span class="number">0</span>], F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">  execv(ecmd-&gt;argv[<span class="number">0</span>], ecmd-&gt;argv);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *binPath = <span class="string">"/bin/"</span>;</span><br><span class="line">  <span class="keyword">int</span> pathLen = <span class="built_in">strlen</span>(binPath) + <span class="built_in">strlen</span>(ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">char</span> *abs_path = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((pathLen+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">  <span class="built_in">strcpy</span>(abs_path, binPath);</span><br><span class="line">  <span class="built_in">strcat</span>(abs_path, ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> (access(abs_path, F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">      execv(abs_path, ecmd-&gt;argv);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: Command not found\n"</span>, ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要补充说明的可能就是 execv 函数，它是 exec 函数族的一个，exec 函数族的作用就是根据 pathname 找到可执行文件，并用它取代调用进程的内容。虽然 pid 未改变，但是实际运行的内容已经不同。结合之前 main 函数中的内容，可以看出 Shell 执行某个命令实际上就是 fork 出一个子进程，然后把子进程替换为想要执行的程序。<br>测试结果为：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rlj@rlj-virtual-machine:~/OS/shell$ ./myShell</span><br><span class="line">6.828$ ls</span><br><span class="line">myShell  sh.c  shell_script  Shell_script_习题.pdf  t.sh</span><br><span class="line">6.828$ ls .//</span><br><span class="line">myShell  sh.c  shell_script  Shell_script_习题.pdf  t.sh</span><br><span class="line">6.828$ abc</span><br><span class="line">abc: Command not found</span><br><span class="line">6.828$ ps</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line"> 17514 pts/2    00:00:00 bash</span><br><span class="line"> 17537 pts/2    00:00:00 myShell</span><br><span class="line"> 17541 pts/2    00:00:00 ps</span><br><span class="line">6.828$ <span class="built_in">echo</span> i love you</span><br><span class="line">i love you</span><br></pre></td></tr></table></figure>
<p>好奇又试了试其他指令</p>
<h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>首先可能需要看一下配套的 xv6 教材第 10 页的文件系统，至少需要了解文件描述符 (file descriptor) 是什么。<br>刚开始写的时候还以为需要自己处理 ‘&lt;’ 和 ‘&gt;’ 情况，后来发现结构体 rcmd 中已经设置好，不需要分开处理。注意一下这个函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct cmd*</span><br><span class="line">redircmd(struct cmd *subcmd, char *file, int <span class="built_in">type</span>)</span><br><span class="line">&#123;</span><br><span class="line">  struct redircmd *cmd;</span><br><span class="line"></span><br><span class="line">  cmd = malloc(sizeof(*cmd));</span><br><span class="line">  memset(cmd, 0, sizeof(*cmd));</span><br><span class="line">  cmd-&gt;<span class="built_in">type</span> = <span class="built_in">type</span>;</span><br><span class="line">  cmd-&gt;cmd = subcmd;</span><br><span class="line">  cmd-&gt;file = file;</span><br><span class="line">  cmd-&gt;mode = (<span class="built_in">type</span> == <span class="string">'&lt;'</span>) ?  O_RDONLY : O_WRONLY|O_CREAT|O_TRUNC;</span><br><span class="line">  cmd-&gt;fd = (<span class="built_in">type</span> == <span class="string">'&lt;'</span>) ? 0 : 1;</span><br><span class="line">  <span class="built_in">return</span> (struct cmd*)cmd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看懂之后的工作就很简单了，结果代码为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'&gt;'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">  rcmd = (struct redircmd*)cmd;</span><br><span class="line">  // fprintf(stderr, <span class="string">"redir not implemented\n"</span>);</span><br><span class="line">  // Your code here ...</span><br><span class="line">  close(rcmd-&gt;fd);</span><br><span class="line">  <span class="keyword">if</span> (open(rcmd-&gt;file, rcmd-&gt;flags, 0644) &lt; 0) &#123;</span><br><span class="line">  fprintf(stderr, <span class="string">"Unable to open file: %s\n"</span>, rcmd-&gt;file);</span><br><span class="line">  <span class="built_in">exit</span>(0);</span><br><span class="line">  &#125;</span><br><span class="line">  runcmd(rcmd-&gt;cmd);</span><br><span class="line">  <span class="built_in">break</span>;</span><br></pre></td></tr></table></figure>
<pre><code>思路就是先关闭程序原先的标准输入/输出，打开指定文件作为新的标准输入/输出。</code></pre><p>非常容易漏掉权限位，即open的第三个参数。注意这里用的是8进制数，所以一定不能直接写<code>644</code>而要写<code>0644。</code><br>我还遇到了一个问题，在此记录一下，第一次权限设置不对，导致无法打开生成的文件，更改后运行，还是不行。后来发现其实由于只是 Truncate，没有把之前生成的文件删除新建，所以权限还是第一次有问题的版本。删掉之前的文件，重新运行，结果正常。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>本次作业的最难的就是管道。重点还是参考 xv6 教材 13 页管道部分，在 xv6 源码的 Sheet 86 还能找到管道的实现。重点是搞明白 <code>pipe</code>，<code>dup</code> 两个函数。</p>
<ul>
<li><code>int pipe(int p[])</code><br>作用是建立一个缓冲区，并把缓冲区通过 fd 形式给程序调用。它将 p[0] 修改为缓冲区的读取端， p[1] 修改为缓冲区的写入端。</li>
<li><code>int dup(int old_fd)</code><br>作用是产生一个fd，指向 old_fd 指向的文件，并返回这个fd。产生的 fd 总是空闲的最小 fd。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'|'</span>:</span><br><span class="line">  pcmd = (struct pipecmd*)cmd;</span><br><span class="line">  // fprintf(stderr, <span class="string">"pipe not implemented\n"</span>);</span><br><span class="line">  // Your code here ...</span><br><span class="line">  <span class="keyword">if</span> (pipe(p) &lt; 0) fprintf(stderr,<span class="string">"pipe failed\n"</span>);</span><br><span class="line">  <span class="keyword">if</span> (fork1() == 0) &#123;</span><br><span class="line">  // 先关闭标准输出再 dup</span><br><span class="line">  // dup 会把标准输出定向到 p[1] 所指文件，即管道写入端</span><br><span class="line">  close(1);</span><br><span class="line">  dup(p[1]);</span><br><span class="line">  // 去掉管道对端口的引用</span><br><span class="line">  close(p[0]);</span><br><span class="line">  close(p[1]);</span><br><span class="line">  // 此时 left 的标准输入不变，标准输出流入管道</span><br><span class="line">  runcmd(pcmd-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fork1() == 0) &#123;</span><br><span class="line">  // 先关闭标准输入再 dup</span><br><span class="line">  // dup 会把标准输入定向到 p[0] 所指文件，即管道读取端</span><br><span class="line">  close(0);</span><br><span class="line">  dup(p[0]);</span><br><span class="line">  // 去掉管道对端口的引用</span><br><span class="line">  close(p[0]);</span><br><span class="line">  close(p[1]);</span><br><span class="line">  // 此时 right 的标准输入从管道读取，标准输出不变</span><br><span class="line">  runcmd(pcmd-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">  close(p[0]);</span><br><span class="line">  close(p[1]);</span><br><span class="line">  <span class="built_in">wait</span>(&amp;r);</span><br><span class="line">  <span class="built_in">wait</span>(&amp;r);</span><br><span class="line">  <span class="built_in">break</span>;</span><br></pre></td></tr></table></figure>
比较费解的就是 fork 了两次，也 wait 了两次。我自己写了一个实现，似乎也能正常运行，并且只 fork 了一次。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'|'</span>:</span><br><span class="line">  pcmd = (struct pipecmd*)cmd;</span><br><span class="line">  // fprintf(stderr, <span class="string">"pipe not implemented\n"</span>);</span><br><span class="line">  // Your code here ...</span><br><span class="line">  <span class="keyword">if</span> (pipe(p) &lt; 0) fprintf(stderr,<span class="string">"pipe failed\n"</span>);</span><br><span class="line">  <span class="keyword">if</span> (fork1() == 0) &#123;</span><br><span class="line">  close(1);</span><br><span class="line">  dup(p[1]);</span><br><span class="line">  close(p[0]);</span><br><span class="line">  close(p[1]);</span><br><span class="line">  runcmd(pcmd-&gt;left);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  close(0);</span><br><span class="line">  dup(p[0]);</span><br><span class="line">  close(p[0]);</span><br><span class="line">  close(p[1]);</span><br><span class="line">  runcmd(pcmd-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">break</span>;</span><br></pre></td></tr></table></figure>
最后，执行脚本判断：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os/shell4" alt=""><br>好的 ，又出现了问题。这几个命令都位于 <code>/usr/bin/</code>下，而我们在执行中只加入了 <code>/bin/</code> 目录，于是我又为case ‘ ‘添加了一个一劳永逸的实现，方便以后添加新的路径。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">  ecmd = (struct execcmd*)cmd;</span><br><span class="line">  <span class="keyword">if</span>(ecmd-&gt;argv[0] == 0)</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">  // fprintf(stderr, <span class="string">"exec not implemented\n"</span>);</span><br><span class="line">  <span class="keyword">if</span>(access(ecmd-&gt;argv[0], F_OK) == 0) &#123;</span><br><span class="line">  execv(ecmd-&gt;argv[0], ecmd-&gt;argv);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  // 将路径改为数组实现</span><br><span class="line">  const char *binPath[] = &#123;<span class="string">"/bin/"</span>, <span class="string">"/usr/bin/"</span>&#125;;</span><br><span class="line">  char *abs_path;</span><br><span class="line">  int bin_count = sizeof(binPath)/sizeof(binPath[0]);</span><br><span class="line">  int found = 0;</span><br><span class="line">  <span class="keyword">for</span> (int i=0; i&lt;bin_count &amp;&amp; found==0; i++) &#123;</span><br><span class="line">      int pathLen = strlen(binPath[i]) + strlen(ecmd-&gt;argv[0]);</span><br><span class="line">      abs_path = (char *)malloc((pathLen+1)*sizeof(char));</span><br><span class="line">      strcpy(abs_path, binPath[i]);</span><br><span class="line">      strcat(abs_path, ecmd-&gt;argv[0]);</span><br><span class="line">      <span class="keyword">if</span>(access(abs_path, F_OK) == 0) &#123;</span><br><span class="line">          execv(abs_path, ecmd-&gt;argv);</span><br><span class="line">      found = 1;</span><br><span class="line">      &#125;</span><br><span class="line">      free(abs_path);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (found == 0) &#123;</span><br><span class="line">      fprintf(stderr, <span class="string">"%s: Command not found\n"</span>, ecmd-&gt;argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">break</span>;</span><br></pre></td></tr></table></figure>
运行成功,结果如下<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os/shell2" alt=""></li>
</ul>
<p>[本文来源]<a href="https://www.jianshu.com/p/64385b80210b" target="_blank" rel="noopener">https://www.jianshu.com/p/64385b80210b</a></p>
]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Ping 本质（ ICMP ）</title>
    <url>/2020/01/01/Ping%20%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<h2 id="1、什么是-Ping"><a href="#1、什么是-Ping" class="headerlink" title="1、什么是 Ping"></a>1、什么是 Ping</h2><a id="more"></a>
<blockquote>
<p>ping是一种计算机网络工具，用来测试数据包能否透过IP协议到达特定主机。ping的运作原理是向目标主机传出一个ICMP echo@要求数据包，并等待接收echo回应数据包。程序会按时间和成功响应的次数估算丢失数据包率（丢包率）和数据包往返时间（网络时延，Round-trip delay time）。———— 维基百科<br> 我们在网络通信的过程中，常常使用 ping 某一个 IP 地址或者某个域名看下基本连接是否正常；是否有丢包；是否有网络延迟。ping 就是我们经常用来作为网络连接通信的测试“指令”。</p>
</blockquote>
<p>我记得我们以前调侃说只要会 Ping 就可以去当网吧网管了（其实网管的工作肯定比这个复杂的多）。</p>
<p>Windows 10 下的 Ping</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">C:\&gt;ping www.baidu.com</span><br><span class="line"></span><br><span class="line">正在 Ping www.a.shifen.com [<span class="number">119.75</span><span class="number">.216</span><span class="number">.20</span>] 具有 <span class="number">32</span> 字节的数据:</span><br><span class="line">来自 <span class="number">119.75</span><span class="number">.216</span><span class="number">.20</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">42</span>ms TTL=<span class="number">53</span></span><br><span class="line">来自 <span class="number">119.75</span><span class="number">.216</span><span class="number">.20</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">42</span>ms TTL=<span class="number">53</span></span><br><span class="line">来自 <span class="number">119.75</span><span class="number">.216</span><span class="number">.20</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">42</span>ms TTL=<span class="number">53</span></span><br><span class="line">来自 <span class="number">119.75</span><span class="number">.216</span><span class="number">.20</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">42</span>ms TTL=<span class="number">53</span></span><br><span class="line"></span><br><span class="line"><span class="number">119.75</span><span class="number">.216</span><span class="number">.20</span> 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = <span class="number">4</span>，已接收 = <span class="number">4</span>，丢失 = <span class="number">0</span> (<span class="number">0</span>% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = <span class="number">42</span>ms，最长 = <span class="number">42</span>ms，平均 = <span class="number">42</span>ms</span><br></pre></td></tr></table></figure>
<h2 id="Ping-的工作原理"><a href="#Ping-的工作原理" class="headerlink" title="Ping 的工作原理"></a>Ping 的工作原理</h2><p>在维基百科中解释有说明， Ping 的原理是 ICMP 协议.</p>
<h2 id="什么是-ICMP-协议"><a href="#什么是-ICMP-协议" class="headerlink" title="什么是 ICMP 协议"></a>什么是 ICMP 协议</h2><blockquote>
<p>ICMP 的全称是 Intent Control Message Protocol, 中文过来就是 互联网控制报文协议</p>
</blockquote>
<p>网络数据包在庞大的网络中会很多各种不同情况。如果一定需要举一个例子来比如的话，用相当于兵种的侦察兵。时刻给大部队探测前方的情况。以便后方的大部队能够根据不同情况做出不同的调整。所以 ICMP 经常用于网络环境的测试。</p>
<blockquote>
<p>互联网控制消息协议（英语：Internet Control Message Protocol，缩写：ICMP）是互联网协议族的核心协议之一。它用于TCP/IP网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。 —— 维基百科</p>
</blockquote>
<h2 id="ICMP-协议的格式"><a href="#ICMP-协议的格式" class="headerlink" title="ICMP 协议的格式"></a>ICMP 协议的格式</h2><p>用图文表示：<br><img src="https://upload-images.jianshu.io/upload_images/12814988-200da5d8944c012d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="ICMP 协议格式"><br>ICMP 报文封装在 IP 包里面。ICMP 的报文类型根据类型和代码有很多，文章后面有来自维基百科的完整的表格。但是主要分为两类：</p>
<blockquote>
<p>A、查询报文<br>B、差错报文</p>
</blockquote>
<h2 id="查询报文-（Echo-Request与-Echo-Reply）"><a href="#查询报文-（Echo-Request与-Echo-Reply）" class="headerlink" title="查询报文 （Echo Request与 Echo Reply）"></a>查询报文 （Echo Request与 Echo Reply）</h2><p>定义：发送端主动发起请求，并且获取到应答。</p>
<p>常见应用：Ping</p>
<p>Ping 就是主动请求，获取到主动应答。但是 Ping 是在原生的 ICMP 中添加了自定义格式区域。例如 Ping 中放了发送的请求时间，以此计算出路程。所以，其实在 Ping 的报文中会加入序号，以用来区分数据包，从而提高计算时间或者路程的准确性。</p>
<h2 id="差错报文"><a href="#差错报文" class="headerlink" title="差错报文"></a>差错报文</h2><p>主要有以下几种：</p>
<ol>
<li><p>源抑制<br>发送端发送大量数据时，可能会导致网络( 路由器 )过载，此时过载处可以向发送端发送源抑制的消息，让他降低发送速度。</p>
</li>
<li><p>终点不可到达<br>网络信息不能到达终点，就会给发送端发送一个目的不可到达的信息。告诉发送端可能是设备故障而引起关闭（情况之一）。然后这种又可以再次细分：<br>A、网络不可达 — 代码为 0，<br>B、主机不可达 — 代码为 1.<br>C、协议不可达 — 代码为 2.<br>D、端口不可达 — 代码为 3.<br>E、需要分段 - 代码为 4.（ 必须把数据分段才能去到终点 ）</p>
</li>
<li><p>超时<br>网络包超过设置的在网络中的生存时间，还没有达到。</p>
</li>
<li><p>路由重定向<br>定义数据包的路由股则。因为大部分的时候，路由规则是通过相关协议算法生成的，有些时候重新定义过之后，会让这个数据包绕的更远。</p>
</li>
</ol>
<blockquote>
<p>常见应用：Traceroute<br>Traceoute 有点像是在不断试错的意思。是用来侦测主机到目的主机之间所经路由情况的重要工具。Ping 我们知道是可以知道这条大路通不通的，Traceoute 通过设置 TTL 知道到底是哪个路由器不通。<br>TTL : 数据包在网络中生存时间，也就是通过数据被路由器转发的次数，没转发一次就减一。知道为 0 的时候就抛弃。<br>Traceroute 的原理：它收到目的主机的 IP 后，首先给目的主机发送一个 TTL=1 的 UDP 数据包，而经过的第一个路由器收到这个数据包以后，就自动把 TTL 减 1，而 TTL 变为 0 以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的 ICMP 数据报给主机。如此循环就可以知道所有的路由 IP 了。（ ICMP 出错了就会回错误包 ）</p>
</blockquote>
<p>通常 Traceoute 的目的端口设置的是一个大于 30000 的值（ 一般的应用端口号远小于这个数 ）。所以如果回复的是 “端口不可达”，那就说明到达终点，否则这个信息就会超时。以此确保 消息是否到达终点。</p>
<p>Traceoute 还有一个有意思的功能，就是确定 MTU（数据最大传输单元），Traceoute 通常对数据不分段，就直接发送，如果如果遇到过程中某个路由转发，出现返回 ICMP 需要分段的错误，就把数据进行拆分，直到最后到达终点。就验证出 MTU。</p>
<p>ICMP 其实还有很多意思的地方，这边就简单的介绍到这里。<br>附表：<br><img src="https://upload-images.jianshu.io/upload_images/12814988-660f2b1948e6e6c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1006/format/webp" alt="ICMP"></p>
<p>作者：FutureEye<br>链接：<a href="https://www.jianshu.com/p/e1795962ad76" target="_blank" rel="noopener">https://www.jianshu.com/p/e1795962ad76</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <tags>
        <tag>Computer Networking</tag>
      </tags>
  </entry>
  <entry>
    <title>对5个数进行排序最少需要多少次</title>
    <url>/2020/01/01/%E5%AF%B95%E4%B8%AA%E6%95%B0%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E6%9C%80%E5%B0%91%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E6%AC%A1/</url>
    <content><![CDATA[<h2 id="对五个数排序最少需要7次"><a href="#对五个数排序最少需要7次" class="headerlink" title="对五个数排序最少需要7次."></a>对五个数排序最少需要7次.</h2><p>今个儿,算法老师上课给我们出的一道题,老师只是告诉我们7次,也没说具体怎么个过程.<br>上网查了查也是看懂了吧<br>本文介绍一个对5个数进行排序的方法，仅使用7次比较。假设要排序的数为a,b,c,d,e。</p>
<blockquote>
<p>首先将a,b进行比较，假设结果为a&lt;b，再将c,d进行比较，假设结果为c&lt;d；然后将两组数的较大者进行比较（即比较b,d），假设结果为b&lt;d，于是就有下面的关系，箭头的关系表示“&lt;”，即”小于”，至此，已经进行了三次比较。</p>
</blockquote>
<p>即:a&lt;b&lt;d,c&lt;d</p>
<blockquote>
<p>  现在将e插入到{a,b,d}的适当位置，采用二分查找法寻找查找位置时，只需要两次比较——先同b比较，然后再同a或d比较。将e插入到{a,b,d}时,一共有四种情况</p>
</blockquote>
<p>e&lt;a&lt;b&lt;d,<br>a&lt;e&lt;b&lt;d,<br>a&lt;b&lt;e&lt;d,<br>a&lt;b&lt;d&lt;e,<br>c&lt;d</p>
<blockquote>
<p> 在这四中情况中，要将c插入到由[abcd]组成的序列中最多只需要两次比较。同样使用二分法寻找插入位置。以第一种情况为例：c首先同a比较，如果大于a，再同b比较，如果大于b，则不会再同d比较，因为我们在之前已经知道c&lt;d。</p>
</blockquote>
<p>所以 3 + 2 + 2 = 7,一共是7次比较</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread and locking</title>
    <url>/2020/01/01/Thread%20and%20locking/</url>
    <content><![CDATA[<h3 id="Threads-and-Locking"><a href="#Threads-and-Locking" class="headerlink" title="Threads and Locking"></a>Threads and Locking</h3><p>题目来源<a href="https://pdos.csail.mit.edu/6.828/2018/homework/lock.html" target="_blank" rel="noopener">Threads and Locking</a><br>本次作业主要讲的是并行作业，以及并行作业中互斥锁（P,V问题）的相关知识。</p>
<a id="more"></a>
<p><a href="https://pdos.csail.mit.edu/6.828/2018/homework/ph.c" target="_blank" rel="noopener">ph.c源码</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -g -O2 ph.c -pthread</span><br><span class="line">./a.out <span class="number">1</span></span><br><span class="line">./a.out <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>代码首先创建了10000个小的node，用每一个node（在代码中名字是entry）来表示一个线程（这里涉及C++链表的内容），然后通过平均分配的方法来把这些线程分配给各个进程。</li>
<li>put函数用来将每一个线程加入链表。然后将这个node的对应信息记录到哈希表：struct entry *table[NBUCKET]中。</li>
<li>get函数通过反哈希的方式得到一个node（也就是一个线程）。同时这也表示这次线程的结束。</li>
</ul>
<p>这样不断通过put 和get来实现并行程序。</p>
<blockquote>
<p>产生错误的原因：当我们在使用put函数的时候，不小心造成两个新的node同时插入链表时（也就是同时使用内存），我们的哈希表只能记录下其中的一个表头，而失去了另外一个node的表头，所以造成了get的时候丢失了node。</p>
</blockquote>
<blockquote>
<p>为了避免这样的错误产生，我们仅仅需要在put的时候加入互斥锁即可：</p>
</blockquote>
<p>1)编译ph.c源文件，并分别以单线程和双线程运行，查看结果<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os/thread1" alt=""></p>
<blockquote>
<p>每个线程分两个阶段(<code>phases</code>)运行。在第一个阶段，每个线程将<code>NKEYS/nthread keys</code>放入<code>the hash table</code>。<br>在第二阶段，每个线程从散列表中获取<code>NKEYS</code>。<code>print</code>语句告诉你每个阶段为每个线程花费了多长时间。 倒数第二行会告诉你有多少个key丢失了，底部的<code>completion time</code>告诉你应用程序的总运行时间。</p>
</blockquote>
<blockquote>
<p><code>ph.c</code>程序主要工作是使用随机数生成10000个<code>keys</code>，然后利用线性<code>hash</code>将其插入5个哈希槽中，最后再取出每<br>个key。</p>
</blockquote>
<p>2)pthread_mutex_t bucket_locks[NBUCKET];//声明锁变量数组:</p>
<p>3)在main()函数中初始锁变量数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i &lt; NBUCKET;i++)&#123;</span><br><span class="line">	pthread_mutex_init(&amp;bucket_locks[i],<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4)修改put函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;bucket_locks[i]);</span><br><span class="line">  insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  pthread_mutex_unlock(&amp;bucket_locks[i]);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>5)再次编译ph.c,并分别以单线程和双线程运行,查看结果<br>gcc -g -O2 ph.c -pthread<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os/thread3" alt=""><br>0 keys missing<br>结果可能存在偏差。<br><a href="https://blog.csdn.net/a747979985/article/details/97250404" target="_blank" rel="noopener">这篇文章讲的更详细</a></p>
]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>DataBase</title>
    <url>/2020/01/01/DataBase/</url>
    <content><![CDATA[<h2 id="数据库复习"><a href="#数据库复习" class="headerlink" title="数据库复习"></a>数据库复习</h2><p>还几天考数据库了,看了看往年试卷没找几道会的题.<br>翻了翻书复习,内容太多了<br>所以打算拿往年试卷复习.</p>
<a id="more"></a>
<p>INTERSECT ∩<br>UNION ∪<br>EXCEPT -<br>exists/in/all/any R</p>
<!--more-->
<ul>
<li>DBMS 数据库管理系统</li>
<li>DBA 数据库管理员</li>
<li>DB 数据库</li>
<li>关系数据库(关系模型)提出者(E.F.code)</li>
<li>网状模型<br>  用网络结构表示实体类型及其实体之间联系的模型</li>
<li>数据库分层<ul>
<li>逻辑层 : 模式</li>
<li>物理层 : 实际是数据存储</li>
<li>视图层 : 虚的概念</li>
</ul>
</li>
<li>约束条件的写法<ul>
<li>至少选三门不同的课<ul>
<li>$\pi$ 投影 select</li>
<li>$\sigma$ 选择 where</li>
<li>from 是不是连接??</li>
</ul>
</li>
</ul>
</li>
<li>给定关系模式和函数依赖,判断无损连接(使用表格法,P55 图3-9)</li>
<li>三范式分解<ul>
<li>判断函数依赖最小集<ul>
<li>把每个函数依赖的右边转换成单个属性</li>
<li>左边的多于属性去掉(求闭包)</li>
<li>除掉多余函数依赖(P45)</li>
</ul>
</li>
<li>最小集中的每一个函数依赖作为一个分解<br>  例如:AB-&gt;C, 得S1(A,B,C)</li>
<li>判断是否具有无损连接性,是否包含所有属性</li>
<li>求解关键字(左属性,孤立属性,右属性,左右属性)</li>
</ul>
</li>
<li>BC范式(几乎不考,选择题)</li>
<li>ER图(简答题)<ul>
<li>画 ER图<ul>
<li>如果是一个多值属性,则需将该属性转换为实体集<br>  类如工资,或者是队服颜色</li>
<li>关键字,外关键字</li>
</ul>
</li>
<li>ER图转换成表</li>
</ul>
</li>
<li>虚拟试图<ul>
<li>虚拟视图的创建</li>
<li><h2 id="可更新视图判断-说明原因"><a href="#可更新视图判断-说明原因" class="headerlink" title="可更新视图判断(说明原因)"></a>可更新视图判断(说明原因)</h2><ul>
<li></li>
<li></li>
</ul>
</li>
<li>权限图<ul>
<li>**:具有该数据元素所有权,而不是来自别处授予</li>
<li>*:带有授权选项</li>
<li>grant语句 与 权限图 的转换</li>
</ul>
</li>
<li>关键字和外键的写法及权限</li>
</ul>
</li>
<li>故障恢复与并行控制<ul>
<li>冲突可串行化的判断</li>
<li>ACID 事务的基本特点</li>
<li>undo/redo log</li>
<li>死锁的判断 (依赖图,是否有环)</li>
</ul>
</li>
<li>flush 数据库清理日志<ul>
<li>flush执行一系列 sql 语句,但不提交事务;<br>commit 方法先调用flush()方法,然后提交事务,提交事务意味着对数据库操作永久保存下来.</li>
</ul>
</li>
<li>两个关系R与S  R与S的交集能写成什么？<blockquote>
<p>R∩S=R-(R-S)</p>
</blockquote>
</li>
<li>笛卡尔积用基本的关系代数表述<h3 id="rlj"><a href="#rlj" class="headerlink" title="rlj"></a>rlj</h3></li>
</ul>
<ol>
<li>下列关于关系数据库的说法，哪一项是正确的？B<br>• A. 关系数据库不能存储视频或音频。(可以存储视频或音频)</li>
</ol>
<p><strong>• B. 表是由列和行组成的。</strong><br>• C. 同一个表中的行可以拥有不同的列集。<br>• D. 行也称为表字段。(行也称记录,列有时也称字段和域)<br>2. 下列哪些是关系数据模型的组件？B<br>• A. 指针，集合，约束<br><strong>• B. 关系，属性，元组</strong><br>• C. 实例，记录类型，实体<br>• D. 表，行，等级<br>3. 下列哪一项表述是错误的？A<br><strong>• A. 关系模型中的属性映射到关系数据库中的行</strong> (记录映射成行)<br>• B. 在 ERD 中，用长方形表示实体(集)<br>• C. 一对一和多对多是可以在 ERD 中表示的关系<br>• D. 关系模型中的实体映射到关系数据库中的表</p>
<blockquote>
<p>行可能是一个实体,列是属性<br>4. 应用程序 B 想要在同一事务中多次读取表 EMPLOYEE 中的行子集。为了保证每次<br>都能返回相同的行子集，应该使用哪种隔离级别？C<br>• A.当前落实<br>• B.读稳定性<br><strong>• C.可重复读</strong><br>• D.未落实读<br>5. 下列关于事务的说法，哪一项是错误的？A<br><strong>• A.事务中的操作并行执行。</strong><br>• B.同一个事务中只能执行 1 个 COMMIT 语句。<br>• C.事务会保证一组操作的原子性。<br>• D. ROLLBACK 或 COMMIT 语句可以终结事务。<br>6. 下列哪一项是事务的定义？A<br><strong>• A. 组合在一起的一个或多个 SQL 操作序列，也被称为一个工作单元</strong><br>• B. 一组可以并行执行的独立操作<br>• C. 一个数据隔离级别，可通过允许读取之前已落实的数据来防止死锁<br>• D. 一个 DB2 数据库对象<br>7. 以下哪种情况会发生脏读？C<br>• A. 一个事务读取了相同的数据行两次，并且每次都返回不同的数据值(不可重复读)<br>• B. 在一个事务期间，基于特定标准的搜索在执行连续搜索之后返回额外的行(幻影读))<br><strong>• C. 返回了未落实的数据，但产生这些数据的事务已回滚</strong><br>• D. 两个事务读取并试图更新相同的数据，第二次更新将在第一次更新落实之前将其覆盖<br>8. 下列哪一项是关于 DB2 授权的最佳描述？A<br><strong>• A. 授权是一个过程，检查你是否具有足够的权限以执行所需的数据库操作</strong><br>• B. 授权是一个过程，在此过程中 DBA 将收集相关信息以查看哪些人可以访问数据库<br>• C. 授权是一个过程，在此过程中 DB2 数据库将使用 Windows 安全机制来检查你是<br>否能够访问 DB2 数据库<br>• D. 授权是一个过程，它通过验证你的用户 ID 和密码来确认你是否是所声称的那个人<br>9. 下列哪一项不是恢复的类型？B<br>A. 版本恢复<br><strong>B. 自动重启恢复</strong><br>C. 崩溃恢复<br>D. 前滚恢复<br>10. 自动存储具备什么功能？A<br><strong>• A. 自动存储允许用户指定数据库管理器用于存储表空间数据的路径，从而简化了存储管理。</strong><br>• B. 自动存储是一种选项，它允许写入到数据库的事务自动落实。<br>• C. 自动存储是一种 DB2 功能，它允许按设定计划自动备份表。<br>• D. 自动存储可以用于自动重组物理介质上的数据，以提高性能。<br>11. 铁路售票系统要求客户在订票前可以允许客户查询但客户上次的查询结果必须出现在下次查询中,在售票系统中的事务隔离级至少应该是:C<br>A. Read Uncommitted  B Read Committed<br><strong>C. Repeatable Reads</strong>   D. Serializable<br>12. 数据库管理系统的组成部分:   </p>
</blockquote>
<ul>
<li>锁管理器 </li>
<li>存储管理器</li>
<li>文件/索引/记录管理器</li>
<li>事务管理器</li>
<li>查询编译器</li>
<li>缓冲区管理器</li>
</ul>
<ol start="13">
<li>on update 和 on delete 后面可以跟的词语有四个no action ， set null ， set default ，cascade</li>
</ol>
<ul>
<li>no action 表示 不做任何操作，</li>
<li>set null 表示在外键表中将相应字段设置为null</li>
<li>set default 表示设置为默认值</li>
<li>cascade 表示级联操作，就是说，如果主键表中被参考字段更新，外键表中也更新，主键表中的记录被删除，外键表中改行也相应删除</li>
</ul>
<ol start="14">
<li><p>有关系模式R(A,B,C,D),有函数依赖集F={A-&gt;B,D-&gt;C，A-&gt;C，D-&gt;A},下面哪个分解不具有无损连接性 <strong>D</strong><br>A. ABC,AD   B. ACD,BCD  C.ABD,BD   D.AD,AB </p>
</li>
<li><p>下面哪个说法符合数据库系统WAL(log先写协议): <strong>D</strong><br>A.数据库内存中被事务修改的页面在事务成功完成时被强制写到磁盘中<br>B.数据库内存中被事务修改的页面在事务撤销时被写到标记为非脏页<br>C.事务成功完成时不需要将与其相关的log页面强制写回磁盘<br>D.事务中被修改的内存数据页面在写回磁盘前必须将与其相关的log写回磁盘</p>
</li>
<li><p>在DBMS中执行GRANT REFERENCES(col1) ON TABLE t1 TO user user7,对于该语句下面哪个描述是正确的: <strong>C</strong><br>A.user7可以在t1上定义视图<br>B.user7可以更新t1中的col1属性的值<br>C.user7在创建其他表时可以定义参考于t1中col1属性的外关键字<br>D.user7可以在t1中定义外关键字.</p>
</li>
<li><p>下列哪一个说法是不正确的 （A） （关系模型）</p>
</li>
</ol>
<p><strong>A、层次模型是EF codd一种</strong><br>B、数据的结构的结构模型的一部分<br>C、DBMS全称Database Management System<br>D、DBA的全称Database Administrator<br>18. 关于视图的描述中，说法正确的是（A）<br><strong>A、在查询中视图可以用作表来使用</strong><br>B、数据库对视图另外的保存数据<br>C、试图都是可以更新的<br>D、可更新视图都是可插入视图<br>19. 关于视图的描述下面说法哪些是正确的: A<br><strong>A.数据库只存储视图的定义.</strong><br>B.数据库为视图另外保存数据<br>C.视图都是可更新的<br>D.视图只能在一个关系上创建<br>20. 在数据库系统中，日志文件可以用于 D<br>A.保障事务的并发性   B.保障数据的安全性<br>C.检测系统的死锁     <strong>D.数据库故障的恢复</strong><br>21. 下面哪个隔离级在读的时候不给任何数据加读锁的是：A<br>A.Read Uncommitted    B. Read Committed<br>C. Repeatable Read    D. Serializable<br><strong>D.数据库重新启动时恢复系统中的分析阶段从检查点开始</strong></p>
<ol start="22">
<li>创建视图<br>create view movieprod(t,n) as select title,name<br>from movies,movieexexc<br>where pc#=c#</li>
<li>创建约束<br>club 数据库中定义一个合适的对象，能够实现下面的功能<br>当使用 insert 语句对 sailors 表插入记录时如果某些记录的 age 值小于 19，同时将这些 age 小于 19 的记录插入到 yangsaliors 表中。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> ST</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> sailors</span><br><span class="line"><span class="keyword">referencing</span></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">row</span> <span class="keyword">as</span> newrow</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">when</span> (new.age &lt;<span class="number">19</span> )</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> yangsaliors(<span class="keyword">sid</span>,<span class="keyword">name</span>,age) <span class="keyword">values</span>(newrow.sid,new.name,new.age)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2012-2013"><a href="#2012-2013" class="headerlink" title="2012-2013"></a>2012-2013</h3><ol>
<li>下列哪一个选项中的描述都可以作为E/R图中的实体集？ <strong>D</strong><br>A. 产品，颜色，高度<br>B. 黄色，大，长<br>C. 约翰，狗，飞机<br>D. 人，动物，植物 </li>
</ol>
<blockquote>
<p>实体是某种抽象对象,相似实体的集合形成实体集.<br>实体集有相关的属性,属性是这个实体机中实体所具有的性质<br>联系是两个或多个实体集的连接<br>颜色,高度 应该算是一种属性<br>约翰,狗,飞机 是实体</p>
</blockquote>
<ol start="2">
<li><p>下列哪一项表述是错误的？ <strong>D</strong><br>A.关键字唯一地标识表中的行。<br>B.外关键字是引用其他表主关键字的列集。<br>C.主关键字和外关键字用于强制数据完整性。<br>D.必须始终在表中定义主关键字。</p>
</li>
<li><p>下列哪些实体集在ER图中应该使用一对多关系？ <strong>D</strong><br>A. 人，  汽车<br>B. 学生，课程<br>C. 学生，教师<br>D. 母亲，孩子</p>
</li>
<li><p>如果使用下列语句创建 TAB1<br>CREATE TABLE tab1(c1 int not null,c2 int not null,<br>check  (c1+c2&gt;10))<br>下列哪个语句会将记录成功插入表 TAB1？ <strong>C</strong><br>A. INSERT INTO tab1 VALUES (0, 9)<br>B. INSERT INTO tab1 VALUES (null, 20)<br>C. INSERT INTO tab1 VALUES (4, 22)<br>D. INSERT INTO tab1 VALUES (20,null)</p>
<blockquote>
<p>check 这个是约束吗?</p>
</blockquote>
</li>
<li><p>给定下列两个表 </p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">C1</td>
<td align="center">C2</td>
<td align="center"></td>
<td align="center">CA</td>
<td align="center">CB</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center"></td>
<td align="center">a</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">4</td>
<td align="center"></td>
<td align="center">c</td>
<td align="center">d</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">6</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">下列哪个查询语句会得到下面的结果 <strong>C</strong>?</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>C1   C2    CA    CB<br>1    2     a      b<br>1    2     c      d<br>3    4     a      b<br>3    4     c      d<br>5    6     a      b<br>5    6     c      d<br>A.select * from t1,t2 where t1.c1=t2.cb<br>B.select * from t1,t2 where t1.c2=t2.ca<br>C.select * from t1,t2<br>D.select * from t1 inner join t2 on t1.c1=t2.ca</p>
<ol start="6">
<li><p>我们在DBMS中记录员工和部门的管理信息,当一个部门的管理员辞职后,数据库需要自动将该部门的管理员信息填成空值,在定义管理关系表时我们对于外关键字的删除规则应定义为 <strong>C</strong><br>A.ON DELETE CASCADE            B.ON DELETE ROLLBACK<br>C.ON DELETE SET NULL        D.ON DELETE NO ACTION</p>
</li>
<li><p>执行下列 SQL 语句之后：<br>GRANT ALL  ON TABLE student TO USER user1<br>假设用户 USER1 没有其他权限，下列哪一项操作是 USER1 可以执行的？<strong>D</strong><br>A. 将其获得在表student上的所有权限赋予其他用户<br>B. 删除关联到表 STUDENT 的视图<br>C. 删除表 STUDENT   D. 以上都不是</p>
</li>
<li><p>下面视图定义是中哪个是可更新视图  我猜选<strong>D</strong><br>A.Create view V1 as select  S.rating , max(S.age) as avgage from Sailors S group by S.rating<br>B.Create view V2 as select  *  from saliros S1 where S1.age&gt;18 expect select * from sailors S2 where S2.name like ‘%Tom’<br>C.Create view V3 as select  S.name, R,bid. from Sailor S, Reserves R where S.sid=R.sid<br>D.Create view V4 as select * from Bailors B where B.name is not null</p>
</li>
</ol>
<ul>
<li>(1) 若视图是基于多个表使用联接操作而导出的，那么对这个视图执行更新操作时，每次只能影响其中的一个表。</li>
<li>(2) 若视图导出时包含有分组和聚合操作，则不允许对这个视图执行更新操作。</li>
<li>(3) 若视图是从一个表经选择、投影而导出的，并在视图中包含了表的主键字或某个候选键，这类视图称为‘行列子集视图’。对这类视图可执行更新操作。<br><a href="https://www.cnblogs.com/suncan0/p/4767900.html" target="_blank" rel="noopener">可更新视图规则</a></li>
</ul>
<ol start="9">
<li>有两个关系TAB1,TAB2<br> TAB1                       TAB2<br>C1     C2                   CX     CY </li>
</ol>
<hr>
<p>A      11                    A      21<br>B      12                    C      22<br>C      13<br>   结果集如下<br>C1     C2    CX     CY </p>
<hr>
<p> A     11    A      21<br> C     13    C      22<br> B     12    -       -<br>哪个SQL语句能够生成该结果  <strong>D</strong><br>A. SELECT * FROM tab1 right OUTER JOIN tab2 ON c1=cx<br>  B. SELECT * FROM tab1 INNER JOIN tab2 ON c1=cx<br>C. SELECT * FROM tab1 FULL OUTER JOIN tab2 ON c1=cx<br>D. SELECT * FROM tab1 LEFT OUTER JOIN tab2 ON c1=cx</p>
<ol start="10">
<li>数据库系统管理员按照事务的方式执行下面的语句：<br>Create table tab1 (a int,b int)<br>insert into tabl values(1,2)<br>insert into tab1 values(2,3)<br>commit<br>Insert into tab1 values(2,3)<br>Insert into tab1 values(1,6)<br>rollback<br>Delete from tab1 where a=1<br>Insert into tab1 values(1,7)<br>数据库系统突然崩溃，系统重新启动后，该管理员执行<br>Select count(<em>) from tab1<br>数据库系统的输出是多少：*</em>A**<br>A. 2      B.3        C.4        D.5</li>
</ol>
<ol start="11">
<li>有关系模式R（A,B,C,D）,其函数依赖集F={A-&gt;B,B-&gt;C,C-&gt;D,D-&gt;A},将关系模式R分解为AB，BC，CD后，哪个函数依赖丢失了？<strong>C</strong><br>A． A-&gt;B    B.  B-&gt;C   C. D-&gt;A  D.没有函数依赖丢失</li>
</ol>
<ol start="12">
<li>有两个关系T1,T2<br>T1          T2<br>C1           CX    </li>
</ol>
<hr>
<p>A             A<br>B             C      </p>
<p>结果集如下<br>C1<br>A<br>B<br>A<br>C<br>哪个SQL语句能够生成该结果 <strong>B</strong><br>A.select * from t1 union  select * from t2<br>B.select * from t1 union all select * from t2<br>C.select * from t1,t2<br>D.select * from t1 except select * from t2</p>
<blockquote>
<p>union 默认是去重的,<br>如果要取消去重,要 加上 all关键字</p>
</blockquote>
<ol start="13">
<li><p>假设关系模式R1（EMP_ID，EMP_NAME，PHONE，EMAIL，SALARY）<br>下列方法中，哪一个是限制用户查看 SALARY 信息但仍允许他们查看其他值的最简单方法？<strong>B</strong><br>A. 加密表的数据<br>B. 创建不包含 SALARY 列的视图。赋予访问视图的权限，并撤销访问原始表的权限<br>C. 撤销不应查看 SALARY 数据的用户对 SALARY 列的 SELECT 访问权限<br>D. 将 SALARY 数据存储在其他表中，并赋予相应用户对该表的 SELECT 权限</p>
</li>
<li><p>有关系模式R(A,B,C,D),有函数依赖集F={A-&gt;B,D-&gt;C，A-&gt;C，D-&gt;A},下面哪个分解不具有无损连接性 <strong>D</strong><br>A. ABC,AD   B. ACD,BCD  C.ABD,BD   D.AD,AB </p>
<blockquote>
<p>无损连接性就是能还原关系的意思</p>
</blockquote>
</li>
<li><p>下面哪个说法符合数据库系统WAL(log先写协议): <strong>D</strong><br>A.数据库内存中被事务修改的页面在事务成功完成时被强制写到磁盘中<br>B.数据库内存中被事务修改的页面在事务撤销时被写到标记为非脏页<br>C.事务成功完成时不需要将与其相关的log页面强制写回磁盘<br>D.事务中被修改的内存数据页面在写回磁盘前必须将与其相关的log写回磁盘</p>
</li>
<li><p>在JDBC提供的数据库编程方法中提供了几种JDBC和数据库的连接方法:<strong>C</strong><br>A.5            B.2            C.4            D.1</p>
</li>
<li><p>某数据库应用系统中，在tab1表上频繁出现where a=… ., where a=….and c=….这些查询条件，其中tab1表中的记录个数为1000万条。数据库中数据库管理员为了提高查询效率决定建立索引，请你选出最合适的索引 <strong>D</strong><br>A.  在属性a上和属性（c，b）和属性（a，b，c）上分别建立索引<br>B． 在属性（a，c, b）上建立一个索引<br>C． 在属性a上和属性（a，b，c）分别建立索引<br>D． 在属性（a，c）上建立索引</p>
</li>
<li><p>下面哪个调度是串行调度:  <strong>B</strong><br>A. T1:R(A),T2:R(B),T2:W(B),T1:W(A)<br>B. T1:R(B),T1:W(B),T2:R(A), T2:W(A)<br>C. T1:R(A),T2:R(B),.T1:W(A),T2:W(B)<br>D. T2:R(A),T1:R(B),.T1:W(A),T2:W(B)</p>
</li>
<li><p>关于数据库管理系统下面哪个描述是最正确的  <strong>C</strong><br>A.数据库管理系统是数据的集合.<br>B.数据库管理系统是数据的集合,并且存储着数据与数据之间的关系.<br>C.数据库管理系统是由一个互相关联的数据的集合和一组用以访问和管理这些数据的程序组成.</p>
</li>
</ol>
<ol start="20">
<li>以下哪种情况会发生不可重复读？<strong>A</strong><br>A. 一个事务读取了相同的数据记录两次，并且每次都返回不同的数据值<br>B. 在一个事务期间，基于特定标准的搜索在执行连续搜索之后返回额外的行<br>C. 返回了未落实的数据，但产生这些数据的事务已回滚<br>D. 两个事务读取并试图更新相同的数据，第二次更新将在第一次更新落实之前将其覆盖</li>
<li>在数据库中存储的是 C<br>A．数据    B．数据模型<br>C．数据以及数据之间的联系    D．信息</li>
</ol>
<p>二.名称解释(每题3分,共15分)</p>
<ol>
<li>主关键字<br>主关键字（主键，primary key）是被挑选出来,作表的行的唯一标识的候选关键字。一个表只有一个主关键字。主关键字又可以称为主键。 主键可以由一个字段，也可以由多个字段组成，分别称为单字段主键或多字段主键。又称主码。并且它可以唯一确定表中的一行数据，或者可以唯一确定一个实体。</li>
</ol>
<p>2.BC范式</p>
<p>BCNF<br>设关系模式R&lt;U，F&gt;∈1NF，如果对于R的每个函数依赖X→Y，若Y不属于X，则X必含有候选码，那么R∈BCNF。</p>
<ol start="3">
<li>关系模式分解的无损连接性</li>
</ol>
<p>对关系模式分解时，原关系模式的任何一个合法的关系值在分解之后应该能通过自然连接运算恢复起来，这就是无损连接所要解决的问题。</p>
<ol start="4">
<li><p>数据库</p>
<blockquote>
<p>数据库是存放数据的仓库。它的存储空间很大，可以存放百万条、千万条、上亿条数据。但是数据库并不是随意地将数据进行存放，是有一定的规则的，否则查询的效率会很低。当今世界是一个充满着数据的互联网世界，充斥着大量的数据。即这个互联网世界就是数据世界。数据的来源有很多，比如出行记录、消费记录、浏览的网页、发送的消息等等。除了文本类型的数据，图像、音乐、声音都是数据</p>
</blockquote>
</li>
<li><p>事务原子性<br>事务中的多个数据库操作是一个不可分割的原子单元整体，只有所有的操作执行成功，整个事务才提交。事务中的任何一个数据库操作失败，已经执行的任何操作都必须被撤销，让数据库返回初始状态。<br>拓展:</p>
</li>
</ol>
<ul>
<li>事务ACID四大特性:<ul>
<li>原子性<br>  -定义:事务中的多个数据库操作是一个不可分割的原子单元整体，只有所有的操作执行成功，整个事务才提交。事务中的任何一个数据库操作失败，已经执行的任何操作都必须被撤销，让数据库返回初始状态。<ul>
<li>实现:事务内的一组操作全部成功(或者全部失败),为了实现原子性,就需要通过日志:将所有对数据的操作都写入日志,如果事务中的一部分操作已经成功,但后面部分操作,因为系统断电,操作系统崩溃等问题而没有成功执行,那么就要通过<strong>回溯日志,将前面已经成功执行的操作撤销,从而达到”全部执行失败”的效果。</strong></li>
</ul>
</li>
<li>一致性:<ul>
<li>事务操作成功后，保证数据不会被破坏</li>
<li>如A账户转账100元到B账户，不管操作成功与否，A和B账户的存款总额是不变的。一致性分为数据库外部一致性和内部一致性：</li>
<li>数据库外部一致性:由外部的应用编码来实现,即银行的应用在进行转账的操作时,必须在同一事务内部调用对账户A和账户B的操作。如果在这个阶段出现错误,这不是数据库本身能解决的,也不属于我们要讨论的范围。</li>
<li>数据库内部的一致性:在同一个事务内部的一组操作必须全部成功(或者全部失败) 这就是事务原子性</li>
</ul>
</li>
<li>持久性:<ul>
<li>一旦事务提交成功后，事务中所有的数据操作都必须被持久化到数据库中。即使在事务提交后，数据库马上崩溃，在数据库重启时，也必须保证能够通过某种机制恢复数据。</li>
</ul>
</li>
<li>隔离性:<br>  <a href="https://blog.csdn.net/u014079773/article/details/52808193" target="_blank" rel="noopener">点击阅读隔离</a></li>
</ul>
</li>
</ul>
<h4 id="简答题（共45分）"><a href="#简答题（共45分）" class="headerlink" title="简答题（共45分）"></a>简答题（共45分）</h4><p>有关系模式students(sid,sname,age,grade,class), course(cid, cname), enroll(sid,cid, score). students记录学生的基本信息,在students中sid表示学生的学号，sname表示学生的姓名,age表示年龄,grade表示年级,class表示班级，sid是students的主关键字.Course记录课程信息,cid为课程编号,cname表示课程名称,cid为course的主关键字.Enroll表示学生的选课信息,sid表示学号,cid表示课程编号,score表示成绩,sid,cid共同组成enroll的主关键字,sid为指向students的外关键字,cid为指向course的外关键字<br>1.请用关系代数写出下面的查询<br>查找年龄最小的学生姓名 (5分)<br>差不多就这个意思<br>重命名为S2 (sname2,age2)<br>S3:=Πsname(S∞(age&gt;age2)S2)<br>R4:= S(name)-S3(name)<br>2.请用元组关系演算写出下面的查询<br>查找年龄小于19而且数据库课程的成绩高于89的学生姓名（5分）</p>
<p>请用SQL语句写出下面的查询<br>4. 查找即选了’数据库原理’课程而没有选’web开发’课程的学生姓名（5分）</p>
<p>select sname from course c,students s,enrool r<br>where cname = ‘数据库原理’<br>and s.sid=r.sid<br>and c.cid=r.cid<br>except<br>select sname from course c,students s,enrool r<br>where cname = ‘数据库原理’<br>and s.sid=r.sid<br>and c.cid=r.cid</p>
<ol start="5">
<li>统计2011级每个班中数据库课程不及格的人数 （5分）</li>
</ol>
<p>select count(*)<br>from course c,students s,enrolled r<br>where grade = 2011<br>and cname = ‘数据库原理’<br>and s.sid=r.sid<br>and c.cid=r.cid<br>and score &lt; 60</p>
<ol start="6">
<li>显示在2011级各班中在数据库原理课程上平均分最低的班级和平均分（5分）</li>
</ol>
<p>select min()<br>avg(score) as avg(score)<br>group by class</p>
<ol start="7">
<li>统计选了数据库课程的平均分，最高分和最低分（5分）<br>avg(score),max()</li>
</ol>
<ol start="8">
<li>请根据下面的要求画出ER图（5分）<br>某个企业的数据库中记录以下信息:1.员工(ssn，name，lot)员工编号ssn唯一确定一个员工，2.部门(did，dname，buget)部门编号did唯一确定一个部门,3.员工与部门的管理关系，每个部门有且仅有一个管理者。</li>
</ol>
<blockquote>
<p>一个员工实体集,ssn是主键 (矩形)<br>一个部门实体集,did是主键 (矩形)<br>一个 manage 关系, 剪头指向 部门 (菱形)<br>需不需要用弧线?</p>
</blockquote>
<ol start="9">
<li>有关系模式R(ABCD),R上的函数依赖集F={ A-&gt;C,C-&gt;A,B-&gt;AC,D-&gt;AC,BD-.A },请将R分解成满足第三范式的关系模式，要求该分解具有无损连接性和依赖保持性(10分)</li>
</ol>
<h4 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h4><ul>
<li><p>关系的键 : 一个或多个属性集 {…}; 当键只包括单独的属性A时,称A(而不是{A})是键 </p>
<ul>
<li><ol>
<li>不可能存在两个不同元组具有相同的{…} </li>
</ol>
</li>
<li><ol start="2">
<li>键必须是最小的,ok!</li>
</ol>
</li>
</ul>
</li>
<li><p>超键 : 不满足上述条件的第二种情况.</p>
</li>
<li><p><strong>主属性</strong>：  包含在任一候选关键字中的属性称主属性。</p>
</li>
<li><p><strong>非主属性</strong>：  不包含在主码中的属性称为非主属性。</p>
</li>
<li><p><strong>函数依赖FD</strong>：<br>例：身份证号→姓名。<br>A → B<br>感觉就是 已知 A 可以推出 B (A可能就是键值吧)<br>至于是谁依赖谁呢?</p>
<ul>
<li><p><strong>部分函数依赖</strong>：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。</p>
</li>
<li><p><strong>完全函数依赖</strong>：在R(U)中，如果Y函数依赖于X,并且对于X的任何一个真子集X’，都有Y不函数依赖于X’， 则称Y对X完全函数依赖。否则称Y对X部分函数依赖。</p>
<ul>
<li><strong>平凡函数依赖</strong> : 例如: A,B,C -&gt; A,B<br>右边是左边的子集</li>
</ul>
<blockquote>
<p>【例】:<br>举个例子就明白了。假设一个学生有几个属性<br>SNO 学号   SNAME 姓名    SDEPT系<br>SAGE 年龄  CNO 班级号     G 成绩<br>对于(SNO,SNAME,SDEPT,SAGE,CNO,G)来说，G完全依赖于(SNO, CNO), 因为(SNO,CNO)可以决定G，而SNO和CNO都不能单独决定G。<br>而SAGE部分函数依赖于(SNO,CNO),因为(SNO,CNO)可以决定SAGE，而单独<br>SNO也可以决定SAGE。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>传递函数依赖</strong>：<br>设R（U）是属性集U上的关系，x、y、z是U的子集，在R（U）中，若x→y，但y→x，若y→z，则x→z，称z传递函数依赖于x，记作X→TZ。<br>如果X-&gt;Y, Y-&gt;Z, 则称Z对X传递函数依赖。</p>
</li>
<li><p><strong>计算X+（属性的闭包）算法</strong>： </p>
<blockquote>
<pre><code>a.初始化，令X+ = X;  </code></pre><p>   b.在F中依次查找每个没有被标记的函数依赖，若“左边属性集”包含于X+ ，则令 X+ = X+∪“右边属性集”, 并为访问过的函数依赖设置标记。<br>   c.反复执行b直到X+不改变为止。</p>
</blockquote>
</li>
<li><p><strong>检验给定的任意函数依赖A1A2…An-&gt;B是否蕴含于依赖集S:</strong></p>
<blockquote>
<p>分析：<br>根据属性集闭包的定义，可知A1A2…An-&gt;{A1,A2,…,An}+ 蕴含于S。只要证明B在{A1，A2，….,An}+中，那么函数依赖A1A2…An-&gt;B肯定蕴含于依赖集S中<br>求解过程：<br>（1） 利用依赖集计算闭包<br>（2） 如果B在闭包中，则函数依赖A1A2…An-&gt;B是否蕴含于<br>依赖集S，否则不蕴含于S</p>
</blockquote>
</li>
</ul>
<p>【例】:<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk1.png" alt=""><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk2.png" alt=""><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk3.png" alt=""></p>
<ul>
<li><p>最小化基本集 : 不可能包含平凡FD</p>
<ul>
<li><ol>
<li>B中所有FD的右边均为单一属性</li>
</ol>
</li>
<li><ol start="2">
<li>从B中删除任何一个FD后,该集合不再是基本集</li>
</ol>
</li>
<li><ol start="3">
<li>对于B中任何一个FD,如果从其左边删除一个或者多个属性,B将不再是基本集</li>
</ol>
</li>
</ul>
</li>
<li><p>Armstrong公理</p>
<ul>
<li><p>自反律:自己推自己 A-&gt;A</p>
</li>
<li><p>增广律 A-&gt;B 怎 AC-&gt;BC</p>
</li>
<li><p>传递律 A-&gt;B B-&gt;C 则A-&gt;C</p>
</li>
</ul>
</li>
</ul>
<p><font color=red size = 5>总结：</font><br>判定函数依赖X→Y是否能由F导出的问题，         可转化为求X+并判定Y是否是X+子集的问题。<br><font color=red>即求F闭包的问题可转化为求属性集闭包的问题。</font></p>
<p>函数依赖的闭包：<br>定义：若F为关系模式R(U)的函数依赖集，我们把F以及<font color=red>所有被F逻辑蕴涵的函数依赖的集合</font><br>称为F的闭包，记为F+</p>
<p>求函数依赖闭包，基于函数依赖推理规则<br>函数依赖推理规则：<br>若XY-&gt;Z，则X-&gt;Z，Y-&gt;z （错）<br>正确的：<br>若X-&gt;Y, 则XZ-&gt;YZ<br>若X-&gt;Y,X-&gt;Z，则X-&gt;YZ<br>若X-&gt;Y，Z属于Y，则X-&gt;Z<br>若X-&gt;Y，Y-&gt;Z，则X-&gt;Z<br>若X-&gt;YZ，则X-&gt;Y，X-&gt;Z //可以把每个函数依赖的右边的属性分解，从而使其右边只出现一个属性<br>伪传递率：<br>若A-&gt;B,BC-&gt;D,则AC-&gt;D</p>
<ul>
<li>异常<ul>
<li>冗余</li>
<li>更新异常</li>
<li>删除异常</li>
</ul>
</li>
<li>分解关系<br>  一般用分解关系的方法来消除异常4</li>
</ul>
<p><font size = 5 color=red>第一范式（1NF）：</font>属性，属性值，字段不可分<br>就是无重复的列<br>如果一个关系模式R的所有属性都是不可分的基本数据项<br>不满足1NF的数据库就不是关系数据库<br>不可以表中有表</p>
<p><font size = 5 color=red>第二范式（2NF）：</font>符合1NF，每一个非主属性完全依赖于码，不能存在部分依赖，有主键，非主键字段依赖主键; 唯一性 一个表只说明一个事物;<br>例:<br>不符合第二范式的例子:<br>表:学号, 姓名, 年龄, 课程名称, 成绩, 学分;<br>这个表明显说明了两个事务:学生信息, 课程信息;<br>存在问题:<br>数据冗余，每条记录都含有相同信息；<br>删除异常：删除所有学生成绩，就把课程信息全删除了；<br>插入异常：学生未选课，无法记录进数据库；<br>更新异常：调整课程学分，所有行都调整。<br>修正:<br>学生：Student(学号, 姓名, 年龄)；<br>课程：Course(课程名称, 学分)；<br>选课关系：SelectCourse(学号, 课程名称, 成绩)。<br>满足第2范式只消除了插入异常。</p>
<p><font size = 5 color=red>第三范式（3NF）：</font><br>符合2NF，并且，消除传递依赖，非主键字段不能相互依赖; 每列都与主键有直接关系，不存在传递依赖;<br>若所有的属性都是主属性，则属于第三范式<br>要求一个数据库表中不包含已在其它表中已包含的非主关键字信息<br>【例】：<br>不符合第三范式的例子:<br>学号, 姓名, 年龄, 所在学院, 学院联系电话，关键字为单一关键字”学号”;<br>存在依赖传递: (学号) → (所在学院) → (学院地点, 学院电话)<br>存在问题:<br>数据冗余:有重复值；<br>更新异常：有重复的冗余信息，修改时需要同时修改多条记录，否则会出现数据不一致的情况<br>删除异常<br>修正：<br>学生：(学号, 姓名, 年龄, 所在学院)；<br>学院：(学院, 地点, 电话)。 </p>
<font size = 5 color=red>
总结：</font>

<ul>
<li>1nf:不可分</li>
<li>2nf:一个表说明一个事物，唯一性</li>
<li>3nf:对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。</li>
</ul>
<p><font size = 5 color=red>BCNF</font>是3NF的改进形式<br>BCNF意味着在关系模式中每一个决定因素都包含候选键，也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。BCNF范式排除了任何属性对候选键的传递依赖与部分依赖。</p>
<ul>
<li>满足BCNF条件<ul>
<li>1 所有非主属性对每一个候选键都是完全函数依赖；</li>
<li>2 所有的主属性对每一个不包含它的候选键，也是完全函数依赖；</li>
<li>3 没有任何属性完全函数依赖于非候选键的任何一组属性。</li>
</ul>
</li>
</ul>
<p><font size = 5 color=red>候选键</font>(又称候选码，候选关键字,码 ，candidate key)<br>设K是一个R(U)中的属性或属性集合(注意可以是属性集合，也即多个属性的组合)，若K完全函数确定U，则K为R的候选键(Candidate key);<br>通俗地说就是，能够确定全部属性的某个属性或某组属性，称为候选键。若候选键多于一个，则选定其中一个作为主键。</p>
<p><strong>在所有依赖关系右边没有出现的属性一定是候选键的成员。</strong></p>
<p><font size = 5 color=red>BCNF范式排除了任何属性对候选键的传递依赖与部分依赖。</font><br><font size = 5 color=red></font><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk4.png" alt=""><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk5.png" alt=""><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk6.png" alt=""><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk7.png" alt=""><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk8.png" alt=""><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk9.png" alt=""></p>
<h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><p>设有关系模式R（A，B，C，D，E，G）上的函数依赖集为：<br> F={ A→B，B→C，AD→G，D→E } 。求解：<br>31. 求关系模式R的所有侯选键。</p>
<blockquote>
<p>解: 求出侯选键AD。（2分）<br>首先在F中函数依赖右边不出现的属性必在侯选键中,即AD (1分)；由于(AD)+=ABCDEG, 即AD能函数决定所有的属性, 所以侯选键只有一个 AD（1分） 。 AD+=AD BEG C<br>32. 分别求属性集G、AD、CD、BC的闭包。<br>G+=G(1分)；      (AD)+=ABCDEG(1分)；<br>(CD)+= CDE(1分)；(BC)+=BC(1分)<br>33. 将关系模式R保持依赖地且无损地分解成3NF，要求写出分解过程。<br>解：F={ A→B，B→C，AD→G，D→E }<br>F是最小依赖集，所有属性在F中出现，将F中是每个函数依赖组成一个关系模式得保持函数依赖的分解：{AB，BC，ADG， DE} (2分)； 并上一个侯选键{AD}得无损分解：<br>{AB，BC，ADG，DE}∪{AD}={ AB，BC，ADG，DE } (2分)<br>F={ A→B，B→C，AD→G，D→E }<br>34. 将关系模式R无损地分解成BCNF，要求写出分解过程。<br>解：根据转换为BCNF的无损连接分解算法6.5  1）由于候选键为AD，<br>F中存在不符合BCNF要求的函数依赖，所以R不是BCNF，<br>选 A→B 分解为：R1=AB，R2=ACDEG ；(1分)<br>R1上保持的函数依赖集为A→B，键为A，所以是BCNF；<br>R2 上保持的函数依赖集为A→C，AD→G，D→E，键为AD，所以不是BCNF； (1分)<br>选A→C进一步分解为：R21=AC，R22=ADEG；(1分) R21上保持的函数依赖为A→C，键为A，所以是BCNF；<br>R22上保持的函数依赖为AD→G，D→E键为AD，所以不是BCNF； 选D→E进一步分解为：R221=DE，R222=ADG；(1分) R221上保持的函数依赖为D→E，键为D，所以是BCNF； R222上保持的函数依赖为AD→G，键为AD，所以是BCNF；<br>最后得保持无损连接特征的分解：{R1，R21，R221，R222}或表示为{AB，AC，DE，ADG}(1分)<br>注：由于选择不符合BCNF要求的函数依赖有多个，因此选择次序可有不同，最后的结果也不同，原则上按上述评分标准分步给分。<br>35. 说明分解ρ={R1，R2}，R1（ABC）、R2（ADEG）的范式级别并说明理由<br>答：R1是2NF (1分)，R2是1NF；(1分)<br>R1上的函数依赖集为：A→B，B→C，码为：A，不存在部分依赖，存在非主属性C对码A的传递依赖。(1分)<br>R2上的函数依赖集为：AD→G，D→E码为：AD，存在非主属性E对码AD的部分依赖。。(1分)<br>ρ={R1，R2}，R1（ABC）、R2（ADEG）</p>
</blockquote>
<h4 id="关系模型基础"><a href="#关系模型基础" class="headerlink" title="关系模型基础:"></a>关系模型基础:</h4><ul>
<li>属性 : 关系的列命名为属性,属性出现在列的顶部;属性用来表述所在列的项目的语义</li>
<li>模式 : 关系名和其属性集合的组合称为这个关系的模式;</li>
<li>元组 : 关系中除含有属性名所在行以外的其他行称为元组;<br>每个元组均有一个分量对应于关系的每个属性</li>
<li>域 : 一个特殊的元素属性 (数据类型)</li>
<li>关系是元组的集合,而不是元组的列表,关系中元组出现的顺序不是实质问题.</li>
<li>关系上的键 : </li>
<li>修改关系模式<ul>
<li>DROP TABLE R;</li>
<li>ALTER TABLE Moive ADD phone char(16);</li>
<li>ALTER TABLE Moive DROP phone;</li>
</ul>
</li>
<li>默认值 <ul>
<li>gender char(1) default ‘?’,</li>
<li>birthdate date default date ‘0000-00-00’,</li>
</ul>
</li>
<li>键的声明<br>  可声明一个或者一组属性是键<ul>
<li>PRIMARY KEY (属性不能有null值)</li>
<li>UNIQUE (null值是允许的)</li>
<li>外键</li>
</ul>
</li>
</ul>
<h4 id="代数查询语言"><a href="#代数查询语言" class="headerlink" title="代数查询语言"></a>代数查询语言</h4><ul>
<li>关系上的集合操作<ul>
<li>并 R∪S</li>
<li>交 R∩S</li>
<li>差 R-S</li>
</ul>
</li>
<li>投影 π a1,a2,…(R)<br>ok领会!<br>a1,a2…是要投影的列</li>
<li>选择<br>σc(R) C是条件</li>
<li>笛卡尔积 R × S<br>领会</li>
<li>自然连接<br>  R ∞ S (用∞代替那个符号了)<ul>
<li>要求: 连接时相应的元组必须在某些方面一致.(属性名字吗?)</li>
<li>如果一个元组不能和另外关系中的任何一个元组配对的话,这个元组就被称为<strong>悬浮元组</strong></li>
</ul>
</li>
<li>θ连接<br>R ∞c S<br>上面提到了C指的是条件<br>θ连接也就是满足某种条件的笛卡尔积</li>
<li>命名和重命名<br>ρs(R)<br>ρs(A1,A2,…An)(R)<br>把S改成名为R的关系</li>
<li>操作之间的关系<ul>
<li>R ∩ S = R - (R - S)</li>
<li>R ∞c S = σc(R × S) </li>
<li>自然连接和笛卡尔积的连接就不必写了把</li>
</ul>
</li>
<li>代数表达式的线性符号<ul>
<li>关系的名字和用圆括号括起来的关系属性的列表.名字Answer习惯性表示最后一步运算的结果,也就是在表达式树根节点上的关系名</li>
<li>赋值符号 :=</li>
<li>赋值号右边的任何代数表达式,可以采用每个赋值语句只用一个算符的方法.也可把几个代数运算组合到一起写到表达式的右端.</li>
</ul>
</li>
<li>关系上的约束<ul>
<li>R=ø 表示 R的值必须为空的约束 与 “R中没有元组等价”</li>
<li>R ⊆ S 表示”任何在R中出现的元组都必须在S中出现”的约束<br>也可写成R - S = ø</li>
<li>引用完整性约束是一种普通的约束.<br>某个上下文出现的值也必须在另外相关的上下文中出现<br>领悟!</li>
<li>键约束 没有任何两个元组在键分量上具有相同的值</li>
<li>其他约束: 略懂;  满足某些条件的关系代数表达式 等于ø 或 ⊆关系</li>
</ul>
</li>
</ul>
<h4 id="数据库语言SQL"><a href="#数据库语言SQL" class="headerlink" title="数据库语言SQL"></a>数据库语言SQL</h4><p>select L (表达式列表)<br>from R (关系)<br>where C (条件)</p>
<ul>
<li><p>投影 </p>
</li>
<li><p>选择 </p>
</li>
<li><p>模式匹配</p>
<ul>
<li>s LIKE p (p是模式)<br>_表示可匹配一个字符<br>%表示可匹配任何形式字符串</li>
</ul>
</li>
<li><p>输出排序<br>在select-from-where语句后加上<br>order by <list of attributes> (默认序是升序)<br>DESC(表示降序),  ASC(表示升序,可省略)</p>
</li>
<li><p>SQL中的积和连接</p>
</li>
<li><p>消除属性歧义<br>A.a B.a</p>
</li>
<li><p>元组变量<br>A as A</p>
</li>
<li><p>多关系查询的解释</p>
<ul>
<li>嵌套循环</li>
<li>并行赋值</li>
<li>转换为关系代数</li>
</ul>
</li>
<li><p>查询的并,交,差(查询应该分别用括号括起来)</p>
<ul>
<li>UNION ∪</li>
<li>INTERSECT ∩</li>
<li>EXCEPT -</li>
</ul>
</li>
<li><p>子查询</p>
<ul>
<li>产生标量值得子查询</li>
<li>关系得条件表达式<ul>
<li>EXISTS R</li>
<li>s IN R</li>
<li>s &gt; ALL</li>
<li>s &gt; ANY</li>
</ul>
</li>
<li>元组的条件表达式</li>
<li>关联子查询</li>
<li>FROM子句中的子查询</li>
<li><strong>SQL的连接表达式</strong><ul>
<li>cross join 交叉连接</li>
<li>join R on θ连接 </li>
<li>natural join R 自然连接 </li>
<li>natural full outer join 外连接<br>natural left outer join<br>natural right outer join</li>
</ul>
</li>
</ul>
</li>
<li><p>全关系操作</p>
<ul>
<li>消除重复<br>SELECT DISTINCT (实际上从关系中消除重复的代价非常昂贵)</li>
<li>并,交,差<br>若要消除重复元组,必须在UNION,INTERSECT和EXCEPT后跟上保留字ALL即可<br>如: R intersect all S</li>
<li>聚集操作符<ul>
<li>SUM</li>
<li>AVG</li>
<li>MIN</li>
<li>MAX</li>
<li>COUNT </li>
</ul>
</li>
<li>分组 GROUP BY name</li>
<li>分组,聚集和空值<br>空值不对求和,取平均和计数做贡献,也不能是列的最大值或最小值</li>
<li>HAVING子句</li>
</ul>
</li>
<li><p>数据库更新</p>
<ul>
<li>插入<br>insert into R(A1,A2…An) values (v1,v2…vn);</li>
<li>删除<br>delete from R where &lt;条件&gt;;</li>
<li>修改<br>update R set&lt;新值赋值&gt; where &lt;条件&gt;;<br>||运算符表示字符串的连接</li>
</ul>
</li>
<li><p>SQL中的事务</p>
<ul>
<li>可串行化</li>
<li>原子性</li>
<li>事务<ul>
<li>START TRANSACTION可用来标记事务的开始</li>
<li>SQL语句COMMIT使得事务成功结束.</li>
<li>SQL语句ROLLBACK使得事务夭折或不成功结束,任何由该事务的SQL语句所引起的修改都被撤销,即它们被回滚 rooled back, </li>
</ul>
</li>
<li>只读事务 (即它不会修改数据库,)<br>SET TRANSACTION READ ONLY<br>这条语句必须在事务开始之前执行.可以通过如下语句通知SQL下一个事务可以写数据:<br>SET TRANSACTION READ WRITE;<br>不过,这个选项是默认选项</li>
<li>读脏数据<ul>
<li>脏数据: Dirty data 是表示还没有提交的事务所写的数据的通用术语</li>
<li>脏读 : 是对脏数据的读取</li>
<li>SQL允许指定一个给定的事务是否可以脏读:<br>  SET TRANSACTION READ WRITE<pre><code>ISOLATION LEVEL READ UNCOMMITTED;</code></pre>  上述语句做了两件事:<ol>
<li>第一行声明事务可以写数据</li>
<li>第二行声明事务用读未提交的”隔离层次”运行,即允许事务读脏数据    </li>
</ol>
</li>
</ul>
</li>
<li>其他隔离层次<ul>
<li>可串行化<br>SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;默认的;</li>
<li>读未提交(脏读)</li>
<li>读提交<br>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</li>
<li>可重复读<br>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;<h4 id="事务其他相关"><a href="#事务其他相关" class="headerlink" title="事务其他相关"></a>事务其他相关</h4></li>
</ul>
</li>
</ul>
</li>
<li><p>共享锁和排他锁</p>
</li>
<li><p>日志的flush,书上例子，output</p>
</li>
</ul>
<h4 id="约束与触发器"><a href="#约束与触发器" class="headerlink" title="约束与触发器"></a>约束与触发器</h4><ul>
<li><p>键和外键</p>
<ul>
<li><p>外键声明隐含的两层意思</p>
</li>
<li><p>两种声明外键的方法<br>a) 在属性的名字和类型后加 references &lt;表名&gt; (&lt;属性名&gt;)<br>b) create table语句的属性列表上追加一个或多个声明<br>foreign key (&lt;属性名列表&gt;) reference &lt;表名&gt; (&lt;属性名列表&gt;)</p>
</li>
<li><p>维护引用完整性</p>
<ul>
<li>缺省原则</li>
<li>级联原则</li>
<li>置空值原则<br>ON DELETE SET NULL<br>ON UPDATE CASCADE</li>
</ul>
</li>
<li><p>延迟约束检查<br>创建表时候在外键后添加缺省<br>DEFERRABLE<br>NOT DEFERRABLE<br>后可有<br>INITIALLY DEFERRED 检查仅被推迟到事务提交前执行,<br>或 INITIALLY IMMEDIATE 选项. 检查在每个语句后都立即被执行<br>SET CONSTRAINT Myconstraint deferred</p>
</li>
</ul>
</li>
<li><p>属性和元组上的约束</p>
<ol>
<li>在单一属性上的约束</li>
<li>在整个元组上的约束</li>
</ol>
<ul>
<li>非空值约束</li>
<li>基于属性的CHECK约束</li>
<li>基于元组的CHECK约束</li>
</ul>
</li>
<li><p>修改约束</p>
<ul>
<li>给约束命名<br>在约束前加保留字CONSTRAINT和约束的名字</li>
<li>修改表上的约束</li>
</ul>
</li>
<li><p>断言 : </p>
<ul>
<li><p>创建断言<br>CREATE ASSERTION &lt;断言名&gt; CHECK (&lt;条件&gt;)</p>
</li>
<li><p>使用断言</p>
</li>
<li><p>删除断言<br>DROP ASSERTION (&lt;断言名&gt;)</p>
</li>
</ul>
</li>
<li><p>触发器<br>  有事也称为 事件-条件-动作规则.或者ECA规则</p>
<ul>
<li>SQL中的触发器<ul>
<li>主要特征 : </li>
</ul>
</li>
<li>触发器设计的选项<h4 id="视图与索引"><a href="#视图与索引" class="headerlink" title="视图与索引"></a>视图与索引</h4></li>
</ul>
</li>
<li><p>虚拟视图 </p>
<ul>
<li>视图的定义:<br>CREATE VIEW &lt;视图名&gt; AS &lt;视图定义&gt;<br>视图定义是一个SQL查询</li>
<li>视图查询</li>
<li>属性重命名</li>
</ul>
</li>
<li><p>视图更新</p>
<ul>
<li><p>视图删除<br>DROP VIEW ParamountMovies<br>删除视图不会影响基本关系Movies<br>但是删除表MOVIES 不但使得表Movies 从此消失,也使得视图不可用</p>
</li>
<li><p><strong>可更新视图</strong><br>  该视图是由单个关系R选取出得一些元素组成</p>
<ul>
<li>WHERE 子句在子查询中不能使用关系R</li>
<li>FROM语句只能包含一个关系R,不能再有其他关系</li>
<li>SELECT语句中的属性列表必须包括足够多的属性,以保证对该视图进行元组插入时,能够用NULL或者适当的默认值来填充所有其他不属于该视图的属性.<br>比如,SELECT语句中不允许包括被定义为非空或者没有默认值的属性.</li>
</ul>
</li>
<li><p>视图中的替换触发器<br>  可以用INSTEAD OF 代替BEFORE,AFTER</p>
</li>
</ul>
</li>
<li><p>索引:<br>  一个表最多建一个索引</p>
<ul>
<li>定义:关系中属性A的索引时一种数据结构,他能提高在属性A上查找具有某个特定值的元组的效率.</li>
<li>建立索引的动机<br>当关系变得很大时,通过扫描关系中所有的元组来找出那些匹配给定查询条件的元组的代价太高.</li>
<li>索引的声明<br>  CREATE INDEX 索引名 ON movies(year,title);<br>  DROP INDEX 索引名.</li>
</ul>
</li>
<li><p>索引的选择<br>  索引的选择时衡量数据库设计成败的一个重要因素.</p>
<ul>
<li><p>设计索引主要考虑两个因素:<br>  1)如果属性上存在索引,则为该属性指定一个值或者取值范围能极大地提高查询的执行效率.同样,如果查询涉及该属性上的连接操作,也能带来性能上的改善</p>
</li>
<li><p>另一方面,为关系上的某个属性或者某个属性集建立的索引会使得对关系的插入,删除,和修改变得更复杂和更费时.</p>
</li>
<li><p>简单代价模型</p>
</li>
<li><p>一些有用的索引:</p>
</li>
</ul>
<ol>
<li>在查询中未主键指定值时比较普遍的,因此键上的索引通常会被频繁地使用</li>
<li>因为键值时唯一的,故与给定键值匹配的元组最多只有一个,因为索引返回的要么是这个元组的位置,要么什么也不返回.<ul>
<li>存在两种情况,即使不是建立在键属性上的索引页仍然有效<br>几乎可以看成是键<br>元组在该属性上是聚集的.</li>
</ul>
</li>
</ol>
<ul>
<li>计算最佳索引</li>
<li>所以的自动选择</li>
</ul>
</li>
<li><p>物化视图(不考) </p>
</li>
</ul>
<h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程 :"></a>存储过程 :</h4><ul>
<li><p>创建PSM函数和过程</p>
<ul>
<li>过程声明要素:<br>CREATE PROCEDURE &lt;名字&gt; (&lt;参数&gt;)<br>  &lt;局部声明&gt;<br>  &lt;过程体&gt;;</li>
<li>函数定义的要素:<br>CREATE FUNCTION &lt;名字&gt; (&lt;参数&gt;) RETURNS &lt;类型&gt;<br>  &lt;局部声明&gt;<br>  &lt;函数体&gt;;</li>
<li>参数是 模式-名字-类型<br>例如: IN oldAddr VARCHAR(255)</li>
</ul>
</li>
<li><p>PSM中的简单语句格式</p>
<ul>
<li>调用语句<br>CALL &lt;过程名&gt; (&lt;参数&gt;)</li>
<li>返回语句</li>
<li>局部变量声明<br>declare &lt;名字&gt;&lt;类型&gt;;</li>
<li>赋值语句<br>set &lt;变量&gt;=&lt;表达式&gt;;</li>
<li>语句组<br>begine…end</li>
<li>语句标号<br>用名字(标号名)和冒号作为前缀来标识语句</li>
</ul>
</li>
<li><p>分支语句</p>
<ul>
<li>用保留字END IF结束</li>
<li>嵌套在if语句中的else子句以单词ELSEIF开始</li>
</ul>
</li>
<li><p>PSM中的查询</p>
<ul>
<li>声明和使用游标<br>a)语句中不出现EXEC SQL<br>b)局部变量不适用冒号前缀</li>
</ul>
</li>
<li><p>PSM中的循环<br>LOOP<br>  &lt;语句列表&gt;<br>END LOOP;<br>中断循环: LEAVE&lt;循环标识&gt;</p>
</li>
<li><p>for 循环</p>
</li>
<li><p>PSM中的异常处理</p>
</li>
<li><p>使用PSM函数和过程</p>
<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4></li>
<li><p>九种类型的权限:</p>
<ul>
<li>select,insert,delete,update 应用到关系上</li>
<li>reference权限是指在完整性约束下引用关系的权力</li>
<li>usage 关系和断言之外的多种模式元素上.</li>
<li>trigger 触发器的权限</li>
<li>execute PSM过程或函数之类的代码权限</li>
<li>under 创建给定类型的子类型权限</li>
</ul>
</li>
<li><p>创建权限</p>
</li>
<li><p>检查权限的过程</p>
</li>
<li><p>授权<br>授权语句的格式如下:<br>GRANT &lt;权限列表&gt; ON &lt;数据库元素&gt; TO &lt;用户列表&gt;<br>其后可以加上with grant option.<br>ALL PRIVILEGES可能在这里出现 </p>
</li>
<li><p><strong>授权图</strong></p>
</li>
<li><p>收权<br>  REVOKE &lt;权限列表&gt; ON &lt;数据库元素&gt; FROM &lt;用户列表&gt;</p>
<ul>
<li>CASCADE</li>
<li>RESTRICT\ <h4 id="其他部分"><a href="#其他部分" class="headerlink" title="其他部分:"></a>其他部分:</h4></li>
</ul>
</li>
<li><p>数据库教父—-E.F.Codd<br>关系层次模型提出?</p>
</li>
<li><p>DBMS:数据库管理系统(Database Management System)是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS</p>
</li>
<li><p>DBA : 数据库管理员（Database Administrator，简称DBA），是从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称</p>
</li>
<li><p>关系规范性算法（闭包，函数依赖的投影，BC范式的分解<br>2范式消除了部分依赖，1范式:原子非多值<br>3范式消除了传递依赖</p>
</li>
<li><p>函数依赖集合，不是关系R的键：算闭包</p>
</li>
<li><p>BC范式能否保持无损连接，三范式</p>
</li>
<li><p>分关系代数（注意不是sql语句）<br>关系代数表示约束，用两种方式表达，等于空集或者属于</p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_37799190/article/details/79418322" target="_blank" rel="noopener">规范化理论</a></p>
</li>
<li><p>给一个调度（并行化，并发控制）</p>
</li>
<li><p>什么叫做冲突的（两个事务对同一个对象的写操作（至少一个）</p>
</li>
<li><p>如何判断调度是不是可串行化的（画优先图）；</p>
</li>
<li><p>关于日志恢复的问题，日志分三种类型，考undo，redo日志，</p>
</li>
<li><p>写出数据库的恢复子系统，恢复的过程，以及恢复之后是什么样子；</p>
</li>
<li><p>两阶段锁协议，书上例题，保证不会发生死锁；</p>
</li>
</ul>
<h4 id="数据库恢复技术"><a href="#数据库恢复技术" class="headerlink" title="数据库恢复技术"></a>数据库恢复技术</h4><h5 id="事务的基本概念"><a href="#事务的基本概念" class="headerlink" title="事务的基本概念"></a>事务的基本概念</h5><ul>
<li><p>1.定义：<br>   一个数据库操作序列<br>   一个不可分割的工作单位<br>   恢复和并发控制的基本单位</p>
</li>
<li><p>2.显示定义方式：<br>  COMMIT</p>
<ul>
<li><p>事务正常结束</p>
</li>
<li><p>提交事务的所有操作</p>
</li>
<li><p>事务中所有对数据库的更新写回磁盘上的物理数据库中.</p>
<p>ROLLBACK</p>
</li>
<li><p>事务异常终止</p>
</li>
<li><p>事务运行的过程中发生了故障,不能继续执行</p>
</li>
<li><p>系统将事务中对数据库的所有已完成的操作全部撤销</p>
</li>
<li><p>事务滚回到开始时的状态</p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">BEGIN TRANSACTION</th>
<th align="center">BEGIN TRANSACTION</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SQL语句1</td>
<td align="center">SQL语句1</td>
</tr>
<tr>
<td align="center">SQL语句2</td>
<td align="center">SQL语句2</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">COMMIT</td>
<td align="center">ROLLBACK</td>
</tr>
</tbody></table>
<ul>
<li><p>3.隐式定义：<br>当用户没有显式地定义事务时，DBMS按缺省规定自动划分事务</p>
</li>
<li><p>4.事务的特性（ACID特性)</p>
<ul>
<li>原子性 (Atomicity)</li>
<li>一致性 (Consistency)</li>
<li>隔离性 (Isolation)</li>
<li>持续性 (Durability)<blockquote>
<ul>
<li>保证事务ACID特性是事务管理的重要任务。</li>
<li>事务ACID特性可能遭到破坏的因素是：<br>1)多个事务并行运行时，不同事务的操作交叉执行<br>2)事务在运行过程中被强行终止</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>数据库管理系统要解决的问题：</p>
<ul>
<li><p>必须保证多个事务的交叉运行不影响这些事务的原子性</p>
</li>
<li><p>必须保证被强行终止的事务对数据库和其他事务没有任何影响</p>
</li>
<li><p>这两个问题就是数据库管理系统的恢复机制和并发控制机制的责任</p>
<h5 id="数据库恢复概述"><a href="#数据库恢复概述" class="headerlink" title="数据库恢复概述"></a>数据库恢复概述</h5></li>
<li><p>故障时不可避免</p>
<ul>
<li>计算机硬件故障</li>
<li>软件的错误</li>
<li>操作员的失误</li>
<li>恶意的破坏</li>
</ul>
</li>
<li><p>故障的影响</p>
<ul>
<li>运行事务非正常中断,影响数据库中数据的正确性</li>
<li>破坏数据库,全部或部分丢失数据</li>
</ul>
</li>
<li><p>数据库的恢复</p>
<blockquote>
<p>DBMS把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态)的功能,这就是数据库的恢复管理系统对故障的对策</p>
</blockquote>
</li>
<li><p>恢复子系统是数据库管理系统的一个重要组成部分</p>
</li>
<li><p>恢复技术是衡量系统优劣的重要指标</p>
</li>
</ul>
<h5 id="故障的种类"><a href="#故障的种类" class="headerlink" title="故障的种类"></a>故障的种类</h5><ul>
<li><p>1.事务内部的故障</p>
<blockquote>
<p>两个更新操作要么全部完成要么全部不做。否则就会使数据库处于不一致状态，例如只把账户甲的余额减少了而没有把账户乙的余额增加。在这段程序中若产生账户甲余额不足的情况，应用程序可以发现并让事务滚回，撤销已作的修改，恢复数据库到正确状态</p>
</blockquote>
</li>
<li><p>事务内部更多的故障是非预期的，是不能由应用程序处理的。</p>
<ul>
<li>运算溢出</li>
<li>并发事务发生死锁而被选中撤销该事务</li>
<li>违反了某些完整性限制而被终止等</li>
</ul>
</li>
<li><p>事务故障的恢复：撤消事务（UNDO）</p>
<ul>
<li>强行回滚事务</li>
<li>撤销该事务已经做出的任何对数据库的修改,使得该事务像根本没有启动一样.</li>
</ul>
</li>
<li><p>2.系统故障(软故障)<br>  指造成系统停止运转的任何事件，使得系统要重新启动</p>
<ul>
<li>特定类型的硬件错误（如CPU故障）</li>
<li>操作系统故障</li>
<li>DBMS代码错误</li>
<li>系统断电</li>
</ul>
</li>
<li><p>系统故障的影响</p>
<ul>
<li>整个系统的正常运行突然被破坏</li>
<li>所有正在运行的事务都非正常终止 (所有活跃事务都只运行了一部分,没有全部完成)</li>
<li>内存中数据库缓冲区的信息全部丢失(部分已完成事务更新后的数据还在缓存区,没有来得及刷到硬盘上,这些更新就丢失了)</li>
<li>不破坏数据库</li>
</ul>
</li>
<li><p>系统故障的恢复</p>
<ul>
<li>发生系统故障时，事务未提交 （恢复策略：强行撤消（UNDO）所有未完成事务）</li>
<li>发生系统故障时，事务已提交，但缓冲区中的信息尚未完全写回到磁盘上。（恢复策略：重做（REDO）所有已提交的事务）<blockquote>
<p>系统故障的恢复需要做两件事情:</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>1.撤销所有未完成的事务<br>2.重做所有已提交的事务</p>
<ul>
<li>介质故障（硬故障，指外存故障）<ul>
<li>磁盘损坏</li>
<li>磁头碰撞</li>
<li>瞬时强磁场干扰</li>
</ul>
</li>
<li>介质故障破坏数据库或部分数据库,并影响正在存取这部分数据的所有事务</li>
<li>截至故障比前两类故障的可能性小得多,但破坏性大得多</li>
<li>介质故障的恢复<ul>
<li>装入数据库发生介质故障前某个时刻的数据副本</li>
<li>重做自此时始的所有成功事务，将这些事务已提交的结果重新记入数据库</li>
</ul>
</li>
</ul>
<ol start="4">
<li>计算机病毒</li>
</ol>
<ul>
<li>故障小结<br>  对各类故障，对数据库的影响有两种可能性：<ul>
<li>数据库本身被破坏</li>
<li>数据库没有被破坏，但数据可能不正确，这是由于事务的运行被非正常终止造成的</li>
</ul>
</li>
<li>恢复操作的基本原理: 冗余<br>利用存储在系统别处的冗余数据来重建数据库中已被破坏或不正确的那部分数据</li>
<li>恢复的实现技术: 复杂</li>
</ul>
<p>问: 系统故障会导致什么问题?</p>
<h5 id="恢复的实现技术"><a href="#恢复的实现技术" class="headerlink" title="恢复的实现技术"></a>恢复的实现技术</h5><ul>
<li><p>恢复机制涉及到的关键：</p>
<ul>
<li>如何建立冗余数据<ul>
<li>数据转储</li>
<li>登陆日志文件</li>
</ul>
</li>
</ul>
</li>
<li><p>数据转储</p>
<ul>
<li>转储是指DBA将整个数据库复制到磁带或另一个磁盘上保存起来的过程</li>
<li>备用的数据成为后备副本或后援副本</li>
<li>数据库遭到破坏后可以将后备副本重新装入</li>
<li>重装后备副本只能将数据库恢复到转储时的状态</li>
<li>要想恢复到故障发生时的状态,必须重新运行自转储后的所有更新事务</li>
</ul>
</li>
<li><p>转储方法</p>
<ul>
<li>静态转储<ul>
<li>系统中无运行事务时进行的转储操作</li>
<li>转储期间不允许对数据库进行操作</li>
<li>转储开始时数据库处于一致性状态</li>
<li>得到的一定是一个数据一致性的副本<blockquote>
<p>优点:实现简单<br>缺点：</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>1.降低了数据库的可用性<br>2.转储必须等待正运行的用户事务结束<br>3.新的事务必须等转储结束</p>
<ul>
<li>动态转储<ul>
<li>转储操作与用户并发进行</li>
<li>转储期间允许对数据库进行存取或修改<blockquote>
<p>优点：</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>1.不用等待正在进行的事务结束<br>2.转储期间允许对数据库进行存取或修改<br>缺点：不能保证副本中的数据正确有效</p>
<ul>
<li><p>动态转储进行故障恢复<br>需要把动态转储期间各事务对数据库的修改活动登记下来，建立日志文件<br>后备副本加上日志文件才能把数据库恢复到某一时刻的正确状态</p>
</li>
<li><p>海量转储<br>每次转储全部数据库</p>
</li>
<li><p>增量转储<br>只转储上次转储后更新过的数据</p>
</li>
</ul>
<p>海量转储与增量转储的比较</p>
<blockquote>
<p>1.从恢复角度看，使用海量转储得到的后备副本进行恢复往往更方便<br>2.如果数据库很大，事务处理又十分频繁，则增量转储更有效<br><img src="https://img-blog.csdnimg.cn/20190603175459427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3ODY1OA==,size_16,color_FFFFFF,t_70" alt=""></p>
</blockquote>
<ul>
<li>登陆日志文件</li>
<li>1.日志文件<br>记录事务对数据库的更新操作文件</li>
<li>格式：<ul>
<li>以记录为单位的日志文件（事务标识，操作类型，操作对象，更新前数据的旧值，更新后数据的新值）</li>
<li>以数据为单位的日志文件（事务标识，被更新的数据块）</li>
</ul>
</li>
<li>内容：<ul>
<li>各个事务的开始标记</li>
<li>各个事务的结束标记</li>
<li>各个事务所有的更新操作</li>
</ul>
</li>
<li>作用：<ul>
<li>进行事务故障恢复</li>
<li>进行系统故障恢复</li>
<li>协助后备副本进行介质故障恢复</li>
</ul>
</li>
</ul>
<p>2.利用静态转储副本和日志文件进行恢复<br><img src="https://img-blog.csdnimg.cn/20190603180545304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3ODY1OA==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>对上图进行说明:</p>
<ol>
<li>系统在Ta时刻停止运行事务，进行数据库转储</li>
<li>在Tb时刻转储完毕，得到Tb时刻的数据库一致性副本</li>
<li>系统运行到Tf时刻发生故障</li>
<li>为恢复数据库，首先由DBA重装数据库后备副本，将数据库恢复到Tb时刻的状态</li>
<li>重新运行自Tb~Tf时刻的所有更新事务，把数据库恢复到故障发生前的一致状态</li>
</ol>
<ul>
<li>登记日志文件<br>基本原则：<blockquote>
<p>登记的次序严格按并行事务执行的时间次序<br>必须先写日志文件，后写数据库</p>
</blockquote>
</li>
</ul>
<h5 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h5><ul>
<li>事务故障的恢复<br>事务故障：事务运行至正常终止点前被终止<br>恢复方法：由恢复子系统利用日志文件撤销（UNDO）此事务已对数据库进行的修改</li>
</ul>
<p>注: 事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预</p>
<ul>
<li><p>恢复步骤:</p>
<ul>
<li>反向扫描文件日志（从后往前扫描），查找该事务的更新操作</li>
<li>对该事务的更新操作执行逆操作，即将日志记录中“更新前的值”写入数据库</li>
<li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。</li>
<li>如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。</li>
</ul>
</li>
<li><p>系统故障的恢复</p>
<ul>
<li>系统故障:<ul>
<li>未完成事务对 数据库的更新已写入数据库</li>
<li>提交事务对数据库的更新还留在缓存区没来得及写入数据库</li>
</ul>
</li>
<li>恢复方法:<ul>
<li>UNDO故障发生时未完成的事务</li>
<li>Redo已完成的事务<br>注:系统故障的恢复由系统在重新启动时自动完成，不需要用户干预</li>
</ul>
</li>
</ul>
</li>
<li><p>恢复步骤:</p>
<ul>
<li>正向扫描日志文件（</li>
</ul>
<p>  1.将在故障发生前已经提交的事务加入重做（REDO）队列，这些事务既有begin transaction记录，也有commit记录；<br>  2.将在故障发生时未完成的事务加入撤销（Undo）队列，这些事务中只有begin transaction记录，无相应的commit记录）</p>
<ul>
<li>撤销（Undo）队列事务进行撤销（Undo）处理（1.反向扫描日志文件，对每个undo事务的更新操作进行逆操作；2.将日志记录中“更新前的值”写入数据库）</li>
<li>对重做（Redo）队列事务进行重做（Redo）处理（1.正向扫描日志文件，对每个REDO事务重新执行登记的操作；2.将日志记录中“更新后的值”写入数据库）</li>
</ul>
</li>
<li><p>介质故障的恢复(需要DBA介入)</p>
</li>
</ul>
<ol>
<li>重装数据库</li>
<li>装入有关的日志文件副本,重做已完成的事务</li>
</ol>
<h5 id="具有检查点的回复技术"><a href="#具有检查点的回复技术" class="headerlink" title="具有检查点的回复技术"></a>具有检查点的回复技术</h5><ul>
<li><strong>解决问题</strong>：<ul>
<li>搜索整个日志将耗费大量的时间</li>
<li>REDO处理：重新执行，浪费了大量时间</li>
</ul>
</li>
<li><strong>解决方法</strong><ul>
<li>在日志文件中增加检查点记录</li>
<li>增加重新开始文件</li>
<li>恢复子系统在登录日志文件期间动态地维护日志<br><img src="https://img-blog.csdnimg.cn/20190603202218714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3ODY1OA==,size_16,color_FFFFFF,t_70" alt=""> </li>
</ul>
</li>
</ul>
<p>建立检查点：<br>恢复子系统可以定期或不定期地建立检查点,保存数据库状态<br>1.定期：按照预定的一个时间间隔，如每隔一小时建立一个检查点<br>2.不定期：按照某种规则，如日志文件已写满一半建立一个检查点<br>恢复:<br><img src="https://img-blog.csdnimg.cn/2019060320274211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3ODY1OA==,size_16,color_FFFFFF,t_70" alt="恢复"></p>
<ul>
<li><p>T1：在检查点之前提交</p>
</li>
<li><p>T2：在检查点之前开始执行，在检查点之后故障点之前提交</p>
</li>
<li><p>T3：在检查点之前开始执行，在故障点时还未完成</p>
</li>
<li><p>T4：在检查点之后开始执行，在故障点之前提交</p>
</li>
<li><p>T5：在检查点之后开始执行，在故障点时还未完成</p>
</li>
<li><p>利用检查点的恢复步骤</p>
<ul>
<li>1.从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录</li>
<li>2.由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST<ul>
<li>建立两个事务队列<br>undo-list<br>redo-list<br>把ACTIVE-LIST暂时放入UNDO-LIST队列，REDO队列暂为空。</li>
</ul>
</li>
<li>3.检查点开始正向扫描日志文件，直到日志文件结束<br>  如有新开始的事务Ti，把Ti暂时放入UNDO-LIST队列<br>  如有提交的事务Tj，把Tj从UNDO-LIST队列移到REDO-LIST队列</li>
<li>4.对UNDO-LIST中的每个事务执行UNDO操作<br>  对REDO-LIST中的每个事务执行REDO操作<h5 id="数据库镜像"><a href="#数据库镜像" class="headerlink" title="数据库镜像"></a>数据库镜像</h5></li>
</ul>
</li>
</ul>
<h3 id="2016-2017-如有错误-敬请指正-是应该这样说哈"><a href="#2016-2017-如有错误-敬请指正-是应该这样说哈" class="headerlink" title="2016-2017(如有错误,敬请指正??是应该这样说哈)"></a>2016-2017(如有错误,敬请指正??是应该这样说哈)</h3><p>一、单项选择题（25 题，每题 2 分）</p>
<ol>
<li><p>以下哪个选项是对脏读的描述？C<br>A.一个事务先后执行多次相同条件的查询，并且每次返回的数据都不相同。(不可重复读)<br>B.在一个事务期间，基于特定标准的搜索在执行连续搜索之后返回额外的行(幻影??)<br>C.一个事务读了另外一个事务修改还未提交的数据.(脏读)<br>D.两个事务读取并试图更新相同的数据，第二次更新将在第一次更新落实之前将其覆盖</p>
</li>
<li><p>C</p>
</li>
<li><p>如果使用下列语句创建tab1 CREATE TABLE tab1(<br>col1 INTEGER NOT NULL, col2 CHAR(3),<br>CONSTRAINT cst1 CHECK (col1 in (1,2,3,4)))<br>下列哪个语句会将记录成功插入表 TAB1？ <strong>C</strong><br>A.INSERT INTO tab1 VALUES (0, ‘a’)<br>B.INSERT INTO tab1 VALUES (NULL, ‘abc’)<br>C.INSERT INTO tab1 VALUES (4, ‘a’)<br>D.INSERT INTO tab1 VALUES (4, ‘abcdefhijklmnopq’)</p>
</li>
<li><p>数据库管理员需要在T1表中定义一个外关键字参考与T2表，下面描述正确是：C<br>A．在T1中外关键字属性可以是T2表的某个关键字属性的真子集。<br>B.在T1中外关键字属性名称必须与T2表的某个关键字属性名称相同。<br>C.在T1中外关键字属性的数据类型必须与T2表的某个关键字属性的数据完全相同（包括字符串的长度也要相同）<br>D.在T1中外关键字属性不能为空。(可以为空)</p>
</li>
<li><p>有T1和T2两个表，数据如下：<br>T1    T2</p>
</li>
</ol>
<p>C1    C2    C1    C2<br>5    4    5    1<br>5    2    5    2<br>5    5    5    3<br>下面哪个查询能够返回以下结果   (减法 B)<br>C1    C2<br>5    4<br>5    5</p>
<p>A.SELECT * FROM T1 MINUS SELECT * FROM T2<br>B.SELECT * FROM T1 EXCEPT SELECT * FROM T2<br>C.SELECT * FRM T2 UNION EXCEPT SELECT * FROM T1 (这是啥玩意??没见过)<br>D.SELECT * FROM T1 NOT EXISTS SELECT * FROM T2</p>
<ol start="6">
<li>下面哪个SQL语句可以引起触发器运行？  C<br>A. DROP    B. ALTER<br>C. DELETE    D. ROLLBACK<blockquote>
<p>update,delete,insert三种触发器</p>
</blockquote>
</li>
</ol>
<p>create trigger st<br>after update on &lt;表名&gt;<br>referencing<br>    new row as newrow<br>for each row<br>when()</p>
<ol start="7">
<li><p>下面关于索引说法正确的是？  B<br>A．索引可以提高insert语句的执行速度。<br>B．索引可以提高某些select语句的执行速度。<br>C．索引可以提高所有select语句的执行速度。<br>D．索引属性值不能为空。</p>
</li>
<li><p>张三需要在t1表上创建一个视图，在t1表上他最少需要什么权限： D<br>A. insert    B.    delete<br>C. query    D.    select</p>
<blockquote>
<p>知道视图咋建就应该知道这题咋写了.</p>
</blockquote>
</li>
<li><p>张三需要在t2表上定义一个外关键字，这个外关键字参考与t1表，下面说法正确的是： (我猜是 D)<br>A．张三需要有t2表上的select权<br>B．张三需要有t1表上的select权<br>C．张三需要有t2表上的references权<br>D．张三需要有t1表上的references权</p>
</li>
</ol>
<ol start="10">
<li><p>在使用JDBC编写的数据库应用中下面说法错误的是： D<br>Ａ．可以定义事务的隔离级<br>Ｂ．可以指定事务能否自动提交<br>Ｃ．可以调用数据库定义的存储过程<br>Ｄ．不能查询数据库中已有的表的名称</p>
</li>
<li><p>B?</p>
</li>
<li><p>关于第三范式描述正确的是 D<br>A.如果一个关系属于第三范式那么它没有数据冗余<br>B.一个关系模式不存在非主属性部分依赖,它就是属于第三范式<br>C.一个关系模式不存在非主属性传递依赖,它就是属于第三范式<br>D.一个关系模式属于 BC 范式,它就属于第三范式</p>
<blockquote>
</blockquote>
</li>
<li><p>下面视图定义是中哪个是可更新视图: D</p>
</li>
</ol>
<ul>
<li>A.Create view V1 as select    S.rating , avg(S.age) as avgage from Sailors S <code>group by</code> S.rating ()</li>
<li>B.Create view V2 as select    <code>*</code>    from saliros S1 where S.age &gt; 18 <code>union</code> select <code>*</code> from sailors S2 where S2.name like ‘%Tom’</li>
<li>C.Create view V3 as select    S.name, R.bid from Sailor R, Reserves R where S.sid=R.sid (有两个属性)</li>
<li>D.Create view V4 as select * from Boats B where B.bname like ‘%Happ%’(where子句不能用关系B)</li>
</ul>
<ol start="14">
<li><p>在数据库启动过程中恢复系统执行顺序是: (C)<br>A.分析阶段,取消阶段,重做阶段<br>B.取消阶段,分析阶段,重做阶段<br>C.分析阶段,重做阶段,取消阶段<br>D.取消阶段,重做阶段,分析阶段.</p>
<blockquote>
<p>分析,redo,undo</p>
</blockquote>
</li>
<li><p>一个企业有大量的数据需要存储在数据库中,由于某些原因要求存储的数据条带化分布,有冗余但冗余不能使用算法冗余.下面磁盘技术中采用哪种方法可以满足该要求: (D??)<br>A. RAID 0    B.RAID 1<br>C. RAID 0+1    D.RAID 5</p>
</li>
<li><p>在一个隔离级为读提交数据的事物中执行select * from sailors where 1=1查询，对该语句执行时在数据库中获得的锁下面哪个描述是最准确的？ (D??)<br>A.获得sailors表的S锁，记录上不加锁。<br>B.获得sailors表的IS锁及记录上的IS锁<br>C.获得sailors表的S锁及记录上的IS锁<br>D.获得sailors表的IS锁及记录上的S锁</p>
</li>
<li><p>数据库语言包括 DDL，DML 和DCL,下面哪个语句是 DML 语句: (D)<br>A.Create index<br>B.Drop table<br>C.Alter table<br>D.Update</p>
</li>
<li><p>有关系模式R(A,B,C)和三个合法实例(4,2,3),(4,2,3),(5,3,3),下面哪个函数依赖在关系模式R 上不成立  D<br>A.A-&gt;B    B.    BC-&gt;A    C. B-&gt;C    D. C-&gt;A</p>
</li>
<li><p>有关系模式R(A,B,C,D),其函数依赖集F={A-&gt;B,B-&gt;C,C-&gt;D,D-&gt;A},将R分解为AD，AB，BC请问该分解丢失了下面哪个函数依赖： C<br>A．A-&gt;C    B.B-&gt;D    C.C-&gt;D    D.没有丢失函数依赖</p>
</li>
<li><p>有关系模式R(A,B,C,D,E,F),其函数依赖集F={A-&gt;B,B-&gt;C,C-&gt;A,    D-&gt;E},在该关系模式上有几个关键字：C<br>A．1    B. 2    C.3    D.4</p>
<blockquote>
<p>L:D<br>R:<br>LR:ABC<br>N: F<br>DFA<br>DFB<br>DFC</p>
</blockquote>
</li>
<li><p>有关系模式 R(A,B,C,D,E),R 的函数依赖集 F={A-&gt; B,BC-&gt;E,ED-&gt;A},下面哪个说法是正确的: B<br>A.R 是BCNF    B.R 是 3NF<br>C.分解(ACD,BCE)是无损分解    D.分解(ABD,CDE)是无损分解</p>
<blockquote>
<p>ACD<br>BCD<br>EDC</p>
</blockquote>
</li>
<li><p>有关系模式 R(A,B,C,D)下面哪个函数依赖集使得 R 是 BCNF (D)<br>A. F={C-&gt;D,C-&gt;A,B-&gt;C}    B. F={ABC-&gt;D,D-&gt;A}<br>C. F={B-&gt;C,D-&gt;A}    D. F={AB-&gt;C,C-&gt;D,C-&gt;AB}</p>
</li>
<li><p>在遵循严格2PL锁(两阶段锁)的规则的情况下，下面哪个调度会出现死锁: (B)<br>A.T1:R(X),T2:W(X),T2:W(Y),T3:W(Y),T1:W(Y)<br>B T1:R(X),T2:W(Y),T2:W(X),T3:W(Y),T1:W(Y),<br>C T1:R(A),T2:W(B),T1:R(A),T3:R(C),T2:W(C),T4:W(A)<br>D.T1:R(A),T2:W(B),T3:W(C),T1: Commit,T2:W(A), T2:Commit,T3:W(B), T3:Commit</p>
</li>
<li><p>下面关于数据库事务处理描述正确的是:   C<br>A．原子性和一致性是由数据库的并发调度保证的.<br>B．隔离性和持久性是由数据库的并发调度保证的.<br>C．原子性和持久性是由数据库的恢复系统保证的<br>D．一致性和隔离性是由数据库的恢复系统保证的</p>
<blockquote>
<p>感觉隔离性和一致性保证并发调度</p>
</blockquote>
</li>
</ol>
<p>二．简单题（50 分）<br>在 mysql 中有 club 数据库，该数据库中有三个表分别是：</p>
<ul>
<li>Sailors(sid char(10),sname char(20),rating int,age int，gender char(2)),其中 sid 是主关键字，sid 表示水手的编号，sname 表示水手的姓名，rating 表示水手的级别，age 表示水手的年龄,gender 表示水手的性别。</li>
<li>Boats(bid char(10),bname char(20),color char(10)，),其中 bid 表示船的编号是主关键字，bname 是船的名字，color 是船的颜色。</li>
<li>Reserves(sid char(10),bid char(10),rdate date),Reserves 中记录水手在哪天订了那只船，其中 sid 是指向 Sailors 的外关字， bid 是指向 Boats 的外关键字,(sid,bid,rdate)合起来构成 Reserves 的主关键字。<br>用关系代数写出下面的查询                                                </li>
</ul>
<ol>
<li>查找只订过一艘红色船而没有订过其它颜色船的水手编号（该水手只订过一次船而且船的颜色是红色.）</li>
</ol>
<p>1)Boats 和 Reserves 做自然连接<br>找出 谁定了什么颜色的船 R1<br>2)Sailors 和 R1 做笛卡尔积<br>然后从中选出sid = sid2 and color = ‘red’ and color &lt;&gt; color2 R2<br>然后 Sailors 的 sid 减去 R2 的sid 即要查询的结果</p>
<p>用元组关系验算写出下面的查询</p>
<ol start="2">
<li>查找既订过红色船又订过绿色船水手的姓名和编号</li>
</ol>
<p>1)Boats 和 Reserves 做自然连接 bid,sid,color R1<br>2) R2是 R1重命名<br>3)R1×R2 后 color1=’red’,color2=’green’ sid1=sid2, R3<br>4)R3 和 Sailors 自然连接 R3.sid=S.sid 取出  s.sname和s.sid</p>
<p>用 SQL 语言写出下面的查询<br>3. 查找定了所有船的水手的编号和姓名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.sid,s.name</span><br><span class="line"><span class="keyword">from</span> saliors</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> b.bid </span><br><span class="line">    <span class="keyword">from</span> boats b</span><br><span class="line">    <span class="keyword">except</span> </span><br><span class="line">    <span class="keyword">select</span> r.bid</span><br><span class="line">    <span class="keyword">from</span> reserves r</span><br><span class="line">    <span class="keyword">where</span> r.sid=s.sid</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> s.sid,s.sname</span><br><span class="line">    <span class="keyword">from</span> sailors s</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">not</span> exist (</span><br><span class="line">            <span class="keyword">select</span> b.bid</span><br><span class="line">            <span class="keyword">from</span> boats b</span><br><span class="line">            <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">                    <span class="keyword">select</span> r.bid</span><br><span class="line">                    <span class="keyword">from</span> reserves r</span><br><span class="line">                    <span class="keyword">where</span> r.bid=b.bid</span><br><span class="line">                    <span class="keyword">and</span> r.sid=s.sid</span><br><span class="line">            )</span><br><span class="line">    )</span><br><span class="line">这个人如果都定过就不存在有没订过的船</span><br><span class="line"><span class="number">1</span>)找这人没定过的船,</span><br><span class="line"><span class="number">2</span>)没找到 <span class="keyword">not</span> exist 成立 选出这个人</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>查找订过红色船也订过绿色船水手的编号和姓名<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> s.sname <span class="keyword">from</span> sailors s,reserves r,boats b </span><br><span class="line"><span class="keyword">Where</span> s.sid=r.sid <span class="keyword">and</span> r.bid=b.bid <span class="keyword">and</span> b.color=’red’</span><br><span class="line"><span class="keyword">intersect</span> </span><br><span class="line"><span class="keyword">Select</span> s.sname <span class="keyword">from</span> sailors s,reserves r,boats b </span><br><span class="line"><span class="keyword">Where</span> s.sid=r.sid <span class="keyword">and</span> r.bid=b.bid <span class="keyword">and</span> b.color=’green’</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ul>
<li>students(sid: char(10),sname: char(20) , class:int)，Students 为软件学院 2015 级学生信息表，sid 表示学生的学号，sname 为学生的姓名，class 为学生的班级，sid 为主关键字。</li>
<li>course(cid:char(7),cname:string,teacher:string), Course 为软件学院 2015 级学生在2016-2017 学期可选课程信息表，cid 表示课程号,cname 表示课程名,teacher 表示教师，cid 是主关键字。</li>
<li>enrolled(sid:char(10),cid:char(7),grade:integer),Enrolled 为学生的选课信息表，sid 表示学号, cid 表示课程号, grade 表示成绩。<br>用 SQL 语言写出下面的查询</li>
</ul>
<ol start="5">
<li>统计各班学生的数据库原理的最高分。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(e.grade)</span><br><span class="line"><span class="keyword">from</span> students s,course c,enrolled e</span><br><span class="line"><span class="keyword">where</span> c.cid=e.cid <span class="keyword">and</span> cname= <span class="string">'数据库原理'</span> <span class="keyword">and</span> </span><br><span class="line">    s.sid = e.sid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.class</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="6">
<li>查找数据库原理课程平均分最高的班级中数据库原理课程的最低分。<br>创建一个视图??</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">min</span>(grade)</span><br><span class="line"> <span class="keyword">from</span> enrolled <span class="keyword">natural</span> <span class="keyword">join</span> students <span class="keyword">natural</span> <span class="keyword">join</span> course </span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">class</span></span><br><span class="line"> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">max</span>(grade) <span class="keyword">desc</span></span><br><span class="line"> <span class="keyword">limit</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>有关系模式 R(A,B,C,D,E,F,G,H,I),它的函数依赖集<br>F={AB-&gt;CD,A-&gt;E,B-&gt;FH,C-&gt;G,D-&gt;B,G-&gt;C,H-&gt;I}<br>7. 求解它的函数依赖集最小集<br>第一步: 拆右边<br>AB-&gt;C,AB-&gt;D,A-&gt;E,B-&gt;F,B-&gt;H,C-&gt;G,D-&gt;B,G-&gt;C,H-&gt;I<br>第二步: 拆左边?<br>第三步:算闭包?<br>去掉 AB-&gt;C 算 AB+: ABDEFHI 不能推出AB-&gt;C 保留<br>去掉 AB-&gt;D 算 AB+: ABCEFHGI 不能推出 AB-&gt;D 保留<br>去掉 A-&gt;E 算 A+ = AE<br>去掉 B-&gt;F 算  B+ =BHI<br>去掉 B-&gt;H 算 B+= BF<br>去掉 C-&gt;G 算 C+= CG<br>去掉 D-&gt;B 算 D+ = D<br>去掉 G-&gt;C 算 G+ = G<br>去掉 H-&gt;I 算 H+ = H 都保留<br>所以这就是 函数依赖集最小集是 (AB-&gt;C,AB-&gt;D,A-&gt;E,B-&gt;F,B-&gt;H,C-&gt;G,D-&gt;B,G-&gt;C,H-&gt;I)</p>
<ol start="8">
<li>将其分解为三范式，该分解要具有无损连接性和依赖保持性.<br>第一步:求最小依赖集 (AB-&gt;C,AB-&gt;D,A-&gt;E,B-&gt;F,B-&gt;H,C-&gt;G,D-&gt;B,G-&gt;C,H-&gt;I)<br>第二步:把每个依赖属性分解成一个关系<br>即(ABC),(ABD),(AE),(BF),(BH),(CG),(DB),(GC),(HI)<br>去掉(GC)<br>为: (ABC),(ABD),(AE),(BF),(BH),(CG),(DB),(HI)<br>L: A<br>R: E F I<br>LR:B C D G H<br>N:<br>第三步: 找关键字<br>A+ = AE<br>AB+ = ABCDEFGHI<br>AB在属性集内,所以三范式最后分解为 (ABC),(ABD),(AE),(BF),(BH),(CG),(DB),(HI)</li>
</ol>
<ol start="9">
<li>根据函数依赖公理即 Armstrong 公理，证明下面的定理 有关系模式 R，X,Y,W 是 R 的属性子集，如果 X-&gt;Y，YW-&gt;Z 成立，则 XW-&gt;Z 也成立。</li>
</ol>
<p>根据函数依赖的定义:因为X-&gt;Y,YW-&gt;Z成立,<br>所以对于关系模式R的任意一个实例中的两个元组<br>t1,t2.如果t1.X=t2.X那么t1.Y=t2.Y. 如果t1.Y=t2.Y.,t1.W=t2.W 那么t1.Z=t2.Z<br>所以  当 t1.X=t2.X,t1.w=t2.w,<br>则 t1.Z=t2.Z<br>所以 XW-&gt;Z </p>
<ol start="10">
<li>请详细描述数据库在启动时它的恢复算法</li>
</ol>
<p><strong>不考</strong></p>
<h3 id="2006-2007"><a href="#2006-2007" class="headerlink" title="2006-2007"></a>2006-2007</h3><h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><ol>
<li>关于数据库管理系统下面哪个描述是最正确的  C<br>A.数据库管理系统是数据的集合.<br>B.数据库管理系统是数据的集合,并且存储着数据与数据之间的关系.</li>
</ol>
<p><strong>C.数据库管理系统是由一个互相关联的数据的集合和一组用以访问这些数据的程序组成.</strong><br>D.数据库管理系统是由数据的集合和一组用以访问这些数据的程序组成</p>
<ol start="2">
<li><p>下面那项不是数据库管理系统组成部分:    D<br>A. 事务管理器          B.查询处理器.<br>C. 存储管理器            <strong>D.进程控制器.</strong></p>
</li>
<li><p>如果有两个关系T1,T2.客户要求每当给T2删除一条记录时,T1中特定记录就需要被改变,我们需要定义什么来满足该要求.   D<br>A.在T1上定义视图                B.在T2上定义视图<br>C.在T1和T2上定义约束        <strong>D.定义trigger</strong></p>
</li>
<li><p>关于数据库事务描述<strong>不正确</strong>的是  A</p>
</li>
</ol>
<p><strong>A. 一个事务中的所有对数据库的改变可以部分完成和部分不完成.</strong><br>B. 一个事务中的所有对数据库的改变必须全部完成或全部不完成.<br>C. 数据库的事务是不可以再次划分的.<br>D. 如果事务在完成前被中断,数据库管理系统能把那些由未完成事务所产生的数据变化从数据库中恢复<br>5. 某个企业的数据库包含以下信息:员工(由员工编号唯一确定,记为ssn),部门(由部门编号唯一确定记为did)员工工作在部门中,每个部门最多有一个管理者.下面哪个ER图能够正确的反映管理关系. B<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/ER1.png" alt=""></p>
<ol start="6">
<li>关于视图的描述下面说法哪些是正确的:  D<br>A. 数据库即存储视图的定义也存视图的数据.<br>B. 用带有聚集运算的SQL创建的视图是可更新视图 ×<br>C. 用带有group by字句的SQL创建的视图是可更新视图 ×                </li>
</ol>
<p><strong>D. 视图可以能在多个关系上创建</strong></p>
<ol start="7">
<li><p>某个企业的数据库包含以下信息.员工(由员工编号唯一确定,记为ssn),员工的子女<br>(属性为name,age),在双亲给定的情况下,每个孩子能由他的姓名唯一确定(假设他们的双亲中只有一个是公司的员工).一旦员工离开公司,那么企业不再对其子女信息感兴趣.下面哪个ER图能够正确的反映以上需求   B<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/ER2.png" alt=""> </p>
</li>
<li><p>如果将下面的ER图转换成数据库中的关系,那么在数据库中需要定义. D<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/ER3.png" alt=""></p>
<p>A. 2个关系                    B. 3个关系<br>C. 3个关系     ,1个断言        <strong>D. 2个关系,1个断言</strong></p>
</li>
<li><p>如果将下面的ER图转换成数据库中的关系(该ER图中要求员工的年龄在18到55岁之间),那么在数据库中至少需要定义.  B<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/ER4.png" alt=""><br>A. 3个关系,1个断言            B.2个关系,1个约束<br>C.3个关系                    D.2个关系</p>
</li>
</ol>
<ol start="10">
<li><p>我们在一个关系中 B<br>A.必须定义一个主关键字 (可以没有)         <strong>B.只能创建一个聚集索引(cluster index)</strong><br>C.只能创建一个稠密索引 ??        D.只能定义一个约束.(约束可以有很多)</p>
</li>
<li><p>在DBMS的关系中  B<br>A.关键字属性值可以为空            B.外关键字属性值可以为空<br>C.任何属性值都可以为空            D.任何属性值都不可以为空.</p>
<blockquote>
<p>关键字属性值不能为空,外关键字属性值可以为空</p>
</blockquote>
</li>
<li><p>下面关于外关键字描述不正确的是  C<br>A.外关键字必须是所参考表的主关键字.<br>B.外关键字属性必须与参考的属性是相同的数据类型</p>
</li>
</ol>
<p><strong>C.定义外关键字需要对所参考表拥有select权</strong><br>D.一个表中可以有多个外关键字.</p>
<ol start="13">
<li><p>我们在DBMS中记录数据库员工和员工工作信息,要求当某个员工离职后,数据库需要自动删除该员工的工作信息,在定义工作表时我们对于外关键字的删除规则应定义为 B<br>A. ON DELETE ROLLBACK            <strong>B.  ON DELETE CASCADE</strong><br>C.ON DELETE SET NULL            D.ON DELETE NO ACTION</p>
</li>
<li><p>在DBMS中执行GRANT update(col1) ON TABLE t.t1 TO user7,对于该语句下面哪个描述是正确的: B<br>A.user7可以在t1上定义视图    </p>
</li>
</ol>
<p><strong>B.user7可以更新t1中的col1属性的值</strong><br>C.user7在创建其他表时可以定义参考于t1中col1属性的外关键字<br>D.user7可以在t1中定义外关键字.<br>15. 关系模式R,R的属性集是{ABCDEG}有函数依赖集F={AB-&gt;C , C-&gt;A, BE-&gt;C, BC-&gt;D , CG-&gt;BD}计算(AB)的属性闭包.D<br>A. BDEG        B. BDC        C.  ABCDEG    <strong>D. ABCD</strong></p>
<ol start="16">
<li>staff的定义如下  C<br>id       INTEGER<br>name     CHAR(20)<br>dept     INTEGER<br>job      CHAR(20)<br>years    INTEGER<br>salary   DECIMAL(10,2)<br>comm     DECIMAL(10,2)<br>下面哪个语句可以按照job和salary的升序排序来返回所有员工的信息.<br>A. SELECT id,name,salary,dept,job,years,comm FROM staff ORDER BY 4,6<br>B. SELECT id,name,salary,dept,job,years,comm FROM staff GROUP BY 4,6</li>
</ol>
<p><strong>C. SELECT id,name,salary,dept,job,years,comm FROM staff ORDER BY 5,3</strong><br>D. SELECT id,name,salary,dept,job,years,comm FROM staff GROUP BY 5,3</p>
<ol start="17">
<li><p>关系模式Sailors(sid,lastname,firtname,age,ratring)其中lastname允许为空. 下面哪个语句能够查找出lastname属性值不为空的水手信息. C<br>A. SELECT * FROM SAILORS WHERE LASTNAME&lt;&gt;’NULL’<br>B. SELECT * FROM SAILORS WHERE LASTNAME&lt;&gt;NULL<br><strong>C. SELECT * FROM SAILORS WHERE LASTNAME IS not NULL</strong><br>D. SELECT * FROM SAILORS WHERE LASTNAME not LIKE ’NULL’</p>
</li>
<li><p>关系模式Sailors(sid,sname,age,ratring)下面哪个语句能够查找出sname属性值至少为四个字符长,并且开始和结束字符都是B的水手信息. B<br>A.SELECT * FROM SAILORS WHERE sname like ’B%%_B’</p>
</li>
</ol>
<p><strong>B.SELECT * FROM SAILORS WHERE sname like’B__%B’</strong><br>C. SELECT * FROM SAILORS WHERE sname like ’B??<em>B’<br>D. SELECT * FROM SAILORS WHERE sname like’B*</em>?B’</p>
<ol start="19">
<li><p>有关系模式R(A,B,C,D,E),R的函数依赖集F={A-&gt;BC,CB-&gt;E,B-&gt;D,E-&gt;A}下面哪个分解具有无损连接性.  B<br>A. (A,D,C),(A,B,C)                B. (A,B,C),(B,C,D,E)<br>C. (A,B,D),(C,D,E)                D. (B,C,D),(A,D,E)    </p>
</li>
<li><p>有关系模式R(A,B,C)和三个合法实例(6,4,6),(6,4,6),(7,4,8),下面哪个函数依赖在关系模式R上不成立  C<br>A.  A-&gt;B        B.  BC-&gt;A        C. B-&gt;C        D. C-&gt;A.</p>
</li>
<li><p>设有关系模式R(B,I,S,Q,D),其上函数依赖集F={S-&gt;D,I-&gt;B,IS-&gt;Q,B-&gt;Q,B-&gt;I}下面那些是R的关键字. A</p>
</li>
</ol>
<p><strong>A.IS</strong>        B.IB        C.IQ     D.ISB</p>
<blockquote>
<p>求闭包<br>IS+ = ISDBQ</p>
</blockquote>
<ol start="22">
<li><p>下面哪个改变可以通过alter table实现 D<br>A. 增加一个触发.        B. 增加一个索引.<br>C. 增加一调记录         <strong>D. 定义一个候选关键字</strong></p>
</li>
<li><p>下面的语句按顺序成功执行后  </p>
</li>
</ol>
<ul>
<li>CREATE TABLE tab1 (c1 CHAR(1))</li>
<li>INSERT INTO tab1 VALUES (‘b’)</li>
<li>CREATE VIEW view1 AS SELECT c1 FROM tab1 WHERE c1 =’a’</li>
<li>INSERT INTO view1 VALUES (‘a’)</li>
<li>INSERT INTO tab1 VALUES (‘b’)<br>  执行SELECT c1 FROM tab1可以选择出多少条记录  D<br>A.0                B.1                C.2                D.3<blockquote>
<p>OK</p>
</blockquote>
</li>
</ul>
<ol start="24">
<li>有一个关系模式employee(name,department,phone_number),下面哪句话允许user1可以修改phone_number列的值  C<br>A. GRANT MODIFY (phone_number) ON TABLE employee TO user1<br>B. GRANT ALTER (phone_number) ON TABLE employee TO user1</li>
</ol>
<p><strong>C. GRANT UPDATE (phone_number) ON TABLE employee TO user1</strong><br>D. GRANT REFERENCES (phone_number) ON TABLE employee TO user1</p>
<ol start="25">
<li>数据库中SAILORS表是由joe创建的.在DBMS完成下面的语句后 D</li>
</ol>
<ul>
<li>Grant select on Sailors To Art With Grant option—Joe执行</li>
<li>Grant select,update on Sailors To Bob With Grant option—Joe执行</li>
<li>Grant select on Sailors To Bob With Grant option—Art执行</li>
<li>Revoke select on Sailors From Art Cascade—Joe执行<br>Bob对Sailors表拥有<br>A. select权        B. Update权        C.没有任何权利    <strong>D.select和Update权</strong>  </li>
</ul>
<ol start="26">
<li><p>在使用数据库中使用索引的目的是: B  ? ?<br>A.提高数据文件的存储率.    <strong>B.可以更加有效的控制事务处理中的幻影问题.</strong><br>C.增加DBMS的安全性.        D.提高增加记录的效率.</p>
<blockquote>
<p>提高查询速度</p>
</blockquote>
</li>
<li><p>下面哪种文件格式对不等值搜索的效率最高 B<br>A.无序文件        <strong>B.排序文件</strong>        C.哈希文件        D.队列文件</p>
</li>
<li><p>下面关于主关键字描述不正确的是:  D<br>A.在表中可以通过主关键字唯一的确定一条记录.<br>B.主关键字可以由多个属性组成.<br>C.组成主关键字的属性值不能空. </p>
</li>
</ol>
<p><strong>D.一个表中可以有多个主关键字</strong></p>
<ol start="29">
<li>关于第三范式描述正确的是 B<br>A.一个关系属于第第一范式,它就属于第三范式</li>
</ol>
<p><strong>B. 一个关系模式属于BC范式,它就属于第三范式</strong><br>C. 一个关系实例有数据冗余,它就是属于第三范式<br>D.一个关系实例没有数据冗余,它就是属于第三范式</p>
<ol start="30">
<li>下面哪个调度是串行调度: B<br>A. T1:R(A),T2:R(B),T2:W(B),T1:W(A)</li>
</ol>
<p><strong>B. T1:R(B),T1:W(B),T2:R(A), T2:W(A)</strong><br>C. T1:R(A),T2:R(B),.T1:W(A),T2:W(B)<br>D. T2:R(A),T1:R(B),.T1:W(A),T2:W(B)</p>
<ol start="31">
<li>下面关于数据库事务处理描述错误的是: C<br>A.原子性:表示的是事务的所有操作在数据库中要么全部正确反映出来要么全部不反映.<br>B.一致性:事务在执行前如果数据库是一致性的那么执行后也是一致性的.</li>
</ol>
<p><strong>C.隔离性:事务在执行过程中可以感觉到系统中其他事务的执行</strong><br>D. 持久性:一个事务成功完成后,它对数据库的改变必须是永久的,即使是系统出现故障时也如此.</p>
<ol start="32">
<li>下面关于数据库事务处理描述正确的是:  C<br>A.原子性和一致性是由数据库的并发控制保证的.<br>B.隔离性和持久性是由数据库的并发控制保证的.</li>
</ol>
<p><strong>C.原子性和持久性是由数据库的恢复系统保证的</strong><br>D.一致性和隔离性是由数据库的恢复系统保证的</p>
<ol start="33">
<li>数据库系统的log中检查点的作用是: D<br>A.系统事务取消时数据库关系系统需要重检查点开始取消.<br>B.系统事务正确完成时数据库系统会在log中设置检查点.<br>C.数据库重新启动时恢复系统中的重做阶段从检查点开始.</li>
</ol>
<p><strong>D.数据库重新启动时恢复系统中的分析阶段从检查点开始</strong></p>
<ol start="34">
<li>下面哪个说法符合数据库系统WAL(log先写协议):  D<br>A.数据库内存中被事务修改的页面在事务成功完成时被强制写到磁盘中<br>B.数据库内存中被事务修改的页面在事务撤销时被写到标记为非脏页<br>C.事务成功完成时不需要将与其相关的log页面强制写回磁盘</li>
</ol>
<p><strong>D.事务中被修改的内存数据页面在写回磁盘前必须将与其相关的log写回磁盘</strong></p>
<ol start="35">
<li>一个企业提供了一个查询数据库,该数据库的数据可以很容易的重新构造.为了提供数据库中磁盘数据的访问速度,下面磁盘技术中采用哪种方法可以满足该要求: A</li>
</ol>
<p><strong>A. RAID 0</strong>        B.RAID 1    C. RAID 0+1        D.RAID 5</p>
<ol start="36">
<li><p>一个企业有大量的数据需要存储在数据库中,企业要求数据的稳定性存储和数据开速访问,但不想使用太多的磁盘进行冗余存储,下面磁盘技术中采用哪种方法可以满足该要求: D<br>A. RAID 0        B.RAID 1    C. RAID 0+1        <strong>D.RAID 5</strong></p>
</li>
<li><p>在JDBC提供的数据库编程方法中提供了几种JDBC和数据库的连接方法: C<br>A.5            B.2            <strong>C.4</strong>        D.1</p>
</li>
</ol>
<p>A．在死锁预防中，等待–死亡法是中止优先级高的事务 (终止优先级低的)<br>B．在死锁预防中，受伤–等待法是优先级高的事务可能等待优先级低的事务释放锁<br><strong>C．使用死锁预防的系统中不会出现死锁。</strong><br>D．使用死锁判断的系统会不会出现死锁。???</p>
<ol start="39">
<li>下面那个说法正确的是 B<br>A. 在嵌入式SQL编程中所有的查询都必须使用游标。</li>
</ol>
<p><strong>B. 如果内存中的某一页的pin_count=0,dirty=true,则该页在替换时该页的数据必须写会磁盘。</strong><br>C. Create table tab1( a int, b int ,c int ,primary key (a,b))  create table tab2(a int , c int, d int, foreign key(a) reference tabl(a))语句可以在DBMS中执行成功  //因为a不是主键<br>D. 如果关系模式R的每一个函数依赖XA都使得下面两个条件中的一个成立则该关系模式满足BC范式。条件:1.XA是平凡函数依赖 2.X是一个关键字</p>
<ol start="40">
<li>数据库系统管理员按照事务的方式执行下面的语句：C</li>
</ol>
<ul>
<li>Create table tab1 (a int,b int)</li>
<li>insert into tabl values(1,2)</li>
<li>insert into tab1 values(2,3)</li>
<li>commit </li>
<li>Insert into tab1 values(2,3)</li>
<li>Insert into tab1 values(1,6)</li>
<li>Commit </li>
<li>Delete from tab1 where a=1</li>
<li>Insert into tab1 values(1,7)</li>
<li>Delete from tab1 where a=1</li>
<li>Insert into tab1 values(1,8)<br>数据库系统突然崩溃，系统重新启动后，该管理员执行<br>Select count(<em>) from tab1<br>数据库系统的输出是多少：<br>A. 6        B.3        *</em>C.4**        D.5<br>???</li>
</ul>
<ol start="41">
<li>下面关于索引说法正确的是: A</li>
</ol>
<p><strong>A. 聚集索引必然是稠密索引</strong><br>B. 在数据库中只能创建一个稀松索引?<br>C.     在数据库中只能创建一个聚集索引<br>D. 索引文件中一定不包括记录的详细数据</p>
<ol start="42">
<li>有关系模式R(A,B,C,D,E),R的函数依赖集F={A-&gt;B,BC-&gt;E,ED-&gt;A},下面哪个说法是正确的: B<br>A.R是BCNF                     B.R是3NF<br>C.分解(ACD,BCE)是无损分解        D.分解(ABD,CDE)是无损分解<br>用眼看!<br><a href="https://blog.csdn.net/suguoliang/article/details/80880923" target="_blank" rel="noopener">例子</a></li>
<li>有关系模式R(A,B,C,D)下面哪个函数依赖集使得R索引<strong>不是</strong>BCNF BC<br>A. F={AB-&gt;CD,C-&gt;ABD }        B. F={ABC-&gt;D,D-&gt;A}<br>C. F={B-&gt;C,D-&gt;A}            D. F={AB-&gt;C,C-&gt;D,C-&gt;AB}</li>
</ol>
<p><strong>BCNF是左边必须是超键，3NF是左边是超键或者右边是主属性</strong></p>
<p>44.下面关于数据库事务并发调度正确的是 BD<br>A. 冲突可串行化调度一定是观测可串行化调度<br><strong>B. 冲突可串行化调度一定与某种串行调度的结果一样.</strong><br>C. 观测可串行化调度调度可以通过画图来判断<br><strong>D. 冲突可串行化调度可以通过画图来判断</strong></p>
<p>45.有两个关系TAB1,TAB2<br>    TAB1           |            TAB2<br>C1     C2            |       CX     CY<br>—    —-         |            —–  —-<br>A      11            |        A      21<br>B      12            |        C      22<br>C      13            |<br>   结果集如下<br>C1     C2  |  CX     CY<br>—-   —- |    —-   —-<br> A     11   | A      21<br> C     13   | C      22<br>哪个SQL语句能够生成该结果 AB<br><strong>A. SELECT * FROM tab1 right OUTER JOIN tab2 ON c1=cx</strong><br><strong>B. SELECT * FROM tab1 INNER JOIN tab2 ON c1=cx</strong><br>C. SELECT * FROM tab1 FULL OUTER JOIN tab2 ON c1=cx<br>D. SELECT * FROM tab1 LEFT OUTER JOIN tab2 ON c1=cx</p>
<p>46下面视图定义是中哪个是可更新视图 D<br>A.Create view V1 as select  S.rating , max(S.age) as avgage from Sailors S group by S.rating<br>B.Create view V2 as select  *  from saliros S1 where S.age&gt;18 expect select * from sailors S2 where S2.name like ‘%Tom’<br>C.Create view V3 as select  S.name, B.bname from Sailor, Boats where S.sid=B.sid<br><strong>D.Create view V4 as select * from Bailors B where B.name is not null</strong></p>
<p>47 下面哪个SQL正确表示查找红色船被订船情况. CD<br>A.Select * from Reserves R,Boat B where R.bid=B.bid and b.color=’red’<br>B.Select * from Reserves R, inner join Boats B on R.bid=B.bid where b.color=’red’<br><strong>C.Select * from Reserves R, right outer join Boats B on R.bid=B.bid and b.color=’red’</strong><br><strong>D.Select * from Reserves R, full outer join Boats B on R.bid=B.bid  and  S.age&gt;17</strong></p>
<ol start="48">
<li>下面说法正确的是: CD<br>A.在任何情况下严格的2PL锁能够保证调度的可串行化.<br>B.在一个表作查询时需要先给符合条件的查询上记录加上S锁然后给表加上IS锁.</li>
</ol>
<p><strong>C.在一个表作查询时需要先给表加上IS锁然后给符合条件的查询上记录加上S锁</strong><br><strong>D.在一个表上同时可以加上IS锁和IX锁</strong></p>
<ol start="49">
<li>下面哪个调度会出现死锁: A</li>
</ol>
<p><strong>A.T1:R(X),T2:W(X),T2:W(Y),T3:W(Y),T1:W(Y),T1:Commit, T2:Commit, T3:Commit</strong><br>B T1:R(X),T2:W(Y),T2:W(X),T3:W(Y),T1:W(Y), T1:Commit, T2:Commit, T3:Commit<br>C T1:R(A),T2:W(B),T1:R(A),T3:R(C),T2:W(C),T4:W(A),T3:W(B)<br>D.T1:R(A),T2:W(B),T3:W(C),T1: Commit,T2:W(A), T2:Commit,T3:W(B), T3:Commit</p>
<blockquote>
<p>卧槽真难<br>我就感觉 D 没有死锁</p>
</blockquote>
<ol start="50">
<li>下面哪个调度是冲突可串行的调度 ABD<br>A. T1:R(X),T1:R(Y),T1:W(X),T2:R(Y),T3:W(Y),T1:W(X),T2:R(Y)<br>B. T1:R(X),T2:R(Y),T3:W(X),T2(R(X),T1:R(X)<br>C. T1:R(X),T2:R(X),T1:W(X),T2:W(X)<br>D. T1:W(X),T2:R(Y),T1:R(Y),T2:R(X)<blockquote>
<p>A可以吗?<br>B可以?<br>C不可以我知道<br>D可以我也知道</p>
</blockquote>
</li>
</ol>
<h4 id="解答题"><a href="#解答题" class="headerlink" title="解答题"></a>解答题</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">有关系有关系模式</span><br><span class="line">- Sailors(sid:integer,sname:string,rating:integer),</span><br><span class="line">- Boats(bid:interger,bname:string,color:string)</span><br><span class="line">- Reserves(sid:integer,bid:integer,day:datetime)</span><br><span class="line">各关系模式的关键字用下划线表示，</span><br><span class="line">其中Reserver的关键字中sid来自Sailors，bid来自Boats，Reserver的记录表示水手的订船记录。</span><br><span class="line"></span><br><span class="line">1.请用关系代数表达式写出下面的查询（4分）</span><br><span class="line">  查找只定过同一艘船的水手的sid。</span><br><span class="line"></span><br><span class="line">不会写,答案也没看懂! </span><br><span class="line"></span><br><span class="line">2.用元组关系演算表达式写出下面的查询(2分)</span><br><span class="line">  查找定了红色船的水手的sid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3．请用SQL语句写出下面的查询（16分）</span><br><span class="line">  1) 查找订过红色船或订过绿色船水手的姓名(3分)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">Select</span> s.sname <span class="keyword">from</span> sailors s,reserves r,boats b </span><br><span class="line"><span class="keyword">Where</span> s.sid=r.sid <span class="keyword">and</span> r.bid=b.bid <span class="keyword">and</span> (b.color=’red’ <span class="keyword">or</span> b.color=’green’)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)将水手按级别(rating)分组,查找平均年龄最小的级别组(<span class="number">6</span>分)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Select</span> temp.rating,temp.avg_age</span><br><span class="line"><span class="keyword">From</span> (<span class="keyword">select</span> rating,<span class="keyword">avg</span>(age) <span class="keyword">as</span> avg_age <span class="keyword">from</span> sailors </span><br><span class="line">      <span class="keyword">Group</span> <span class="keyword">by</span> rating) <span class="keyword">as</span> temp</span><br><span class="line"><span class="keyword">Where</span> temp.avg_age=</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">min</span>(temp1.avg_age) <span class="keyword">from</span> temp temp1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) 查找定了所有红色船的水手的姓名(<span class="number">6</span>分)</span><br><span class="line"><span class="keyword">Select</span> s.sname  <span class="keyword">from</span> sailors s</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> b.bid <span class="keyword">from</span> boats b <span class="keyword">where</span> b.color=’red’ <span class="keyword">except</span> </span><br><span class="line">               <span class="keyword">Select</span> r.bid <span class="keyword">from</span> reserves r <span class="keyword">where</span> r.sid=s.sid)</span><br><span class="line"></span><br><span class="line">定了的红色船 - 所有的红色船 = <span class="literal">null</span> 那就说明定了所有的红色船</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>．有关系模式</span><br><span class="line">- employees(ssn:<span class="built_in">char</span>(<span class="number">10</span>),<span class="keyword">name</span>:<span class="built_in">char</span>(<span class="number">20</span>),age:<span class="built_in">int</span>),其中ssn是employees的主关键字，</span><br><span class="line">- departments(did:<span class="built_in">char</span>(<span class="number">5</span>),dname:<span class="built_in">char</span>(<span class="number">20</span>)), 其中did是departments的主关键字.</span><br><span class="line">- work_in( ssn:<span class="built_in">char</span>(<span class="number">10</span>),did:<span class="built_in">char</span>(<span class="number">5</span>),<span class="keyword">from</span>:<span class="built_in">date</span>,<span class="keyword">to</span>:<span class="built_in">date</span>), 其中(ssn,did,<span class="keyword">from</span>,<span class="keyword">to</span>)是work_in的主关键字,did,ssn分别是指向deparments,employess的外关键字。</span><br><span class="line"></span><br><span class="line">表示员工在某段时间内工作与某个部门。另外还要求每个的员工都要工作与某个部门，每个部门都要有人工作。请用<span class="keyword">SQL</span>语句创建work_in关系，并表达出每个的员工都要工作与某个部门，每个部门都要有人工作这个约束条件。（<span class="number">5</span>分）</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> work_in(</span><br><span class="line">   ssn   <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">   did   <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">   <span class="keyword">from</span>  <span class="built_in">date</span>,</span><br><span class="line">   <span class="keyword">to</span>    <span class="built_in">date</span>,</span><br><span class="line">   primary <span class="keyword">key</span>(ssn,did,<span class="keyword">from</span>,<span class="keyword">to</span>),</span><br><span class="line">   <span class="keyword">foreign</span> <span class="keyword">key</span> ssn <span class="keyword">reference</span> employees,</span><br><span class="line">   <span class="keyword">foreign</span> <span class="keyword">key</span> did <span class="keyword">reference</span> departments)</span><br><span class="line"><span class="keyword">create</span> assert e_d( </span><br><span class="line">    <span class="keyword">check</span>(<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> departments=<span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> did) <span class="keyword">from</span> work_in) <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">check</span>(<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> employees=<span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">sid</span>) <span class="keyword">from</span> work_in)</span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 请用Armstrong公理证明，若X-&gt;Y,Y-&gt;Z.则X-&gt;Z(<span class="number">5</span>分)</span><br><span class="line">&gt;根据函数依赖的定义:因为X-&gt;Y,Y-&gt;Z成立所以对于关系模式R的任意一个实例中的任意两个元组</span><br><span class="line">t1,t2.如果t1.X=t2.X那么t1.Y=t2.Y.如果t1.Y=t2.Y 那么t1.Z=t2.Z.</span><br><span class="line">所以对于任意的两个元组t1,t2 当t1.X=t2.X 则t1.Z=t2.Z</span><br><span class="line">所以XZ</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 设有关系模式R，F=&#123;A-&gt;C,C-&gt;A,B-&gt;AC,D-&gt;AC,BD-&gt;A&#125;是R的函数依赖集(<span class="number">8</span>分)</span><br><span class="line">&gt;<span class="number">1</span>)请求出R的函数依赖最小集（<span class="number">5</span>分）</span><br><span class="line">先将函数依赖的右边变成单个属性</span><br><span class="line">F=&#123; A-&gt;C,C-&gt;A ,B-&gt;A,B-&gt;C,D-&gt;A,D-&gt;C,DB-&gt;A&#125;</span><br><span class="line">除去函数依赖左边的多于属性</span><br><span class="line">因为AC,CA ,BA,BC,DA,DC左边都是单个属性不用检查</span><br><span class="line">对于DB-&gt;A,除去D后,B的属性闭包=BAC 包括A 所以D是多余属性则DB-&gt;A变成,B-&gt;A</span><br><span class="line">所以函数依赖集变为F1=&#123; AC,CA ,BA,BC,DA,DC&#125;</span><br><span class="line">除去多余的函数依赖</span><br><span class="line">a. 去掉A-&gt;C 在F1-&#123;A-&gt;C&#125;中 A的属性闭包=A 所以AC不是多于依赖</span><br><span class="line">b. 去掉C-&gt;A 在F1-&#123;C-&gt;A&#125;中 C的属性闭包=C 所以CA不是多于依赖</span><br><span class="line">c. 去掉B-&gt;A 在F1-&#123;B-&gt;A&#125;中 B的属性闭包=BCA 所以BA是多于依赖F1=&#123; A-&gt;C,C-&gt;A , B-&gt;C,D-&gt;A,D-&gt;C&#125;</span><br><span class="line">d. 去掉C-&gt;A 在F1-&#123;B-&gt;C&#125;中 B的属性闭包=B 所以BC不是多于依赖</span><br><span class="line">e. 去掉D-&gt;A 在F1-&#123;D-&gt;A&#125;中D的属性闭包=DCA 所以DA是多于依赖F1=&#123; A-&gt;C,C-&gt;A , B-&gt;C,D-&gt;C&#125;</span><br><span class="line">R的函数依赖最小集是 F’=&#123; A-&gt;C,C-&gt;A , B-&gt;C,D-&gt;C&#125;</span><br><span class="line">[click](https://blog.csdn.net/sumaliqinghua/article/details/<span class="number">86246762</span>)</span><br><span class="line">- 右侧编程单个属性</span><br><span class="line">- 删除多余属性</span><br><span class="line">- 再拆左边非单属性</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)找出一个关键字,并证明其是关键字(<span class="number">3</span>分)</span><br><span class="line">&gt;BD是一个关键字.</span><br><span class="line">因为BD的属性闭包=BDCA 是R的属性全集</span><br><span class="line">B的属性闭包是BCA不是R的属性全集</span><br><span class="line">D的属性闭包是DCA不是R的属性全集</span><br><span class="line">这样不存在BD的真子集也能是的该真子集的属性闭包是R的属性全集所以BD是R的关键字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 并发控制</span></span><br><span class="line">- 多用户数据库系统</span><br><span class="line">    允许多个用户同时使用的数据库系统</span><br><span class="line">    - 特点: 在同一时刻并发运行的事务数可达数百上千个</span><br><span class="line">- 多事务执行方式</span><br><span class="line">    - 事务串行执行</span><br><span class="line">        - <span class="number">1.</span>每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行</span><br><span class="line">        - <span class="number">2.</span>不能充分利用系统资源，发挥数据库共享资源的特点</span><br><span class="line">    - 交叉并发方式    </span><br><span class="line">        - <span class="number">1.</span>在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行</span><br><span class="line">        - <span class="number">2.</span>单处理机系统中的并行事务并没有真正地并行运行事务，但能够减少处理机的空闲时间，提高系统的效率</span><br><span class="line">    - 同时并发方式</span><br><span class="line">        - 多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行</span><br><span class="line">        - 最理想的并发方式,但受制于硬件环境</span><br><span class="line">        - 更复杂的并发方式机制</span><br><span class="line">- 事务并发执行带来的问题</span><br><span class="line">    - 会产生多个事务同时存取同一数据的情况</span><br><span class="line">    - 可能会存取和存储不正确的数据，破坏事务一致性和数据库的一致性</span><br><span class="line">- DBMS必须提供并发控制机制</span><br><span class="line">- 并发控制机制是衡量一个DBMS性能的重要标志直之一</span><br><span class="line"><span class="comment">##### 并发控制的概述</span></span><br><span class="line">**事务时并发控制的基本单位**</span><br><span class="line">- 并发控制机制的任务</span><br><span class="line">    - 对并发操作进行正确调度</span><br><span class="line">    - 保证事务的隔离性</span><br><span class="line">    - 保证数据库的一致性</span><br><span class="line">- 并发操作带来的数据不一致性</span><br><span class="line">    - 丢失修改</span><br><span class="line">![](https://rlj<span class="number">-1999</span><span class="number">-1259282223.</span>cos.ap-beijing.myqcloud.com/%E6%<span class="number">95</span>%B0%E6%<span class="number">8</span>D%AE%E5%BA%<span class="number">93</span>/%E4%B9%A0%E9%A2%<span class="number">98</span>/s1.png)</span><br><span class="line">    两个事务T1和T2读入同一数据并修改，T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失</span><br><span class="line">    - 不可重复读 </span><br><span class="line">        包括三种情况</span><br><span class="line">        - 事务T1读取某一数据后，**事务T2对其做了修改**，当事务T1再次读该数据时，得到与前一次不同的值 (读-修改)</span><br><span class="line">![](https://rlj<span class="number">-1999</span><span class="number">-1259282223.</span>cos.ap-beijing.myqcloud.com/%E6%<span class="number">95</span>%B0%E6%<span class="number">8</span>D%AE%E5%BA%<span class="number">93</span>/%E4%B9%A0%E9%A2%<span class="number">98</span>/s2.png)</span><br><span class="line">            - T1读取B=<span class="number">100</span>进行运算</span><br><span class="line">            - T2读取同一数据B，对其进行修改后将B=<span class="number">200</span>写回数据库。</span><br><span class="line">            - T1为了对读取值校对重读B，B已为<span class="number">200</span>，与第一次读取值不一致</span><br><span class="line">        - 事务T1按一定条件从数据库中读取了某些数据记录后，**事务T2删除了其中部分记录**，当T1再次按相同条件读取数据时，发现某些记录消失了 (读-删除)</span><br><span class="line">        - 事务T1按一定条件从数据库中读取某些数据记录后，**事务T2插入了一些记录**，当T1再次按相同条件读取数据时，发现多了一些记录。(读-插入)</span><br><span class="line">    **读插入和读删除有时也叫做幻影现象.</span><br><span class="line">    - 读 脏数据</span><br><span class="line">        - 事务T1修改某一数据，并将其写回磁盘</span><br><span class="line">        - 事务T2读取同一数据后，T1由于某种原因被撤销</span><br><span class="line">        - 这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致</span><br><span class="line">        - T2读到的数据就为“脏”数据，即不正确的数据</span><br><span class="line">        ![](https://rlj<span class="number">-1999</span><span class="number">-1259282223.</span>cos.ap-beijing.myqcloud.com/%E6%<span class="number">95</span>%B0%E6%<span class="number">8</span>D%AE%E5%BA%<span class="number">93</span>/%E4%B9%A0%E9%A2%<span class="number">98</span>/s3.png)</span><br><span class="line">        - T1将C值修改为<span class="number">200</span>，T2读到C为<span class="number">200</span></span><br><span class="line">        - T1由于某种原因撤销，其修改作废，C恢复原值<span class="number">100</span></span><br><span class="line">        - 这时T2读到的C为<span class="number">200</span>，与数据库内容不一致，就是“脏”数据</span><br><span class="line">- 数据不一致性: **由于并发操作破坏了事务的隔离性**</span><br><span class="line">- 并发控制就是要用**正确的方式调度并发操作**，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性</span><br><span class="line">- 对 数据库的应用有时允许有些不一致性,可以降低对一致性要求以减少系统开销</span><br><span class="line">- 并发控制的主要技术</span><br><span class="line">    - 封锁</span><br><span class="line">    - 时间戳</span><br><span class="line">    - 乐观控制法</span><br><span class="line">    - 多版本并发控制 (MVCC)</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 封锁</span></span><br><span class="line">- 基本封锁类型</span><br><span class="line">    - 排它锁 X锁</span><br><span class="line">    - 共享锁 S锁</span><br><span class="line"></span><br><span class="line">- 排它锁</span><br><span class="line">    - 若事务T对数据对象A加上X锁,则只允许T读取和修改A,其他任何事务都不能再对A加任何类型的锁,直到T释放A上的锁.</span><br><span class="line">    - 保证其他事务在T释放A上的锁之前不能再读取和修改A</span><br><span class="line">    - 排它锁又称写锁</span><br><span class="line">- 共享锁</span><br><span class="line">    - 若事务T对数据对象A机上S锁,则事务T可以读但不能修改A,其他事务只能再对A加S锁,而不能再加X锁,知道T释放A上的S锁</span><br><span class="line">    - 保证其他事务可以读A,但在T释放A上的S锁之前不能对A做任何修改</span><br><span class="line">    - 共享锁又称读锁</span><br><span class="line"></span><br><span class="line">![](https://rlj<span class="number">-1999</span><span class="number">-1259282223.</span>cos.ap-beijing.myqcloud.com/%E6%<span class="number">95</span>%B0%E6%<span class="number">8</span>D%AE%E5%BA%<span class="number">93</span>/%E4%B9%A0%E9%A2%<span class="number">98</span>/suo1.png)</span><br><span class="line"><span class="comment">##### 封锁协议</span></span><br><span class="line">- 在运用X锁和S锁对数据对象加锁时,需要约定一些规则,这些规则为封锁协议</span><br><span class="line">    - 合适申请X锁或S锁</span><br><span class="line">    - 持锁时间</span><br><span class="line">    - 何时释放</span><br><span class="line">- 一级封锁协议</span><br><span class="line">    - 事务T在修改数据R之前必须先对其加X锁,知道事务结束才释放</span><br><span class="line">    - 一级封锁协议可以防止丢失修改,并保持事务T是可恢复的</span><br><span class="line">    - 不能保证可重复读和脏读</span><br><span class="line">- 二级封锁协议</span><br><span class="line">    - 一级封锁协议加上事务T在读取数据R之前必须显对其加S锁,读完后即可释放S锁(短锁)</span><br><span class="line">    - 可以方式丢失修改和读脏数据</span><br><span class="line">    - 读完数据后即可释放S锁,所以不能保证可重复读</span><br><span class="line">- 三级封锁协议</span><br><span class="line">    - 一级封锁协议加上事务T在读取数据R之前必须显对其加S锁,事务结束才释放S锁(长锁)</span><br><span class="line">    - 都可防止</span><br><span class="line">- 小结: </span><br><span class="line">![](https://rlj<span class="number">-1999</span><span class="number">-1259282223.</span>cos.ap-beijing.myqcloud.com/%E6%<span class="number">95</span>%B0%E6%<span class="number">8</span>D%AE%E5%BA%<span class="number">93</span>/%E4%B9%A0%E9%A2%<span class="number">98</span>/suo2.png)</span><br><span class="line"><span class="comment">##### 活锁和死锁</span></span><br><span class="line">- 活锁</span><br><span class="line">&gt;事务T1封锁了数据R</span><br><span class="line">事务T2又请求封锁R，于是T2等待。</span><br><span class="line">T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。</span><br><span class="line">T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求……</span><br><span class="line">T2有可能永远等待，这就是活锁的情形</span><br><span class="line">- 解决方法:  采取先来先服务策略</span><br><span class="line">- 死锁:</span><br><span class="line">&gt;事务T1封锁了数据R1</span><br><span class="line">T2封锁了数据R2</span><br><span class="line">T1又请求封锁R2，因T2已封锁了R2，于是T1等待T2释放R2上的锁</span><br><span class="line">接着T2又申请封锁R1，因T1已封锁了R1，T2也只能等待T1释放R1上的锁</span><br><span class="line">这样T1在等待T2，而T2又在等待T1，T1和T2两个事务永远不能结束，形成死锁</span><br><span class="line">- 死锁的预防: </span><br><span class="line">    - 一次封锁法</span><br><span class="line">        每个事务必须一次将所有要使用的数据全部加锁</span><br><span class="line">        - 存在问题:</span><br><span class="line">            - <span class="number">1.</span>过早加锁,降低系统并发度</span><br><span class="line">            - <span class="number">2.</span>难于事先精确确定封锁对象</span><br><span class="line">    - 顺序封锁法</span><br><span class="line">        顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。</span><br><span class="line">        - 存在问题:</span><br><span class="line">            - <span class="number">1.1</span>.维护成本：数据库系统中封锁的数据对象极多，并且在不断地变化。</span><br><span class="line">            - <span class="number">2.</span>难以实现：很难事先确定每一个事务要封锁哪些对象</span><br><span class="line">- 死锁的诊断与解除:</span><br><span class="line">    - 超时法:</span><br><span class="line">        如果一个事务的等待时间超过了规定的时限,就认为发生了死锁</span><br><span class="line">        - 优点:实现简单</span><br><span class="line">        - 缺点:</span><br><span class="line">            - 可能误判死锁</span><br><span class="line">            - 时限若设置得太长,死锁发生后不能即使发现</span><br><span class="line">    - 事务等待法:（如果事务等待图存在回路，则表示系统中出现了死锁）</span><br><span class="line">- 解除死锁</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 并发调度的可串行性</span></span><br><span class="line">串行调度是正确的</span><br><span class="line">执行结果等价于穿行调度的调度也是正确的,称为可串行化调度</span><br><span class="line">- 可串行化调度</span><br><span class="line">- 可串行性</span><br><span class="line">    - 是并发事务正确调度的准则</span><br><span class="line">    - 一个给定的并发调度,当且仅当它是可串行化的,才认为是正确调度</span><br><span class="line">嗯,稍懂</span><br><span class="line"><span class="comment">##### 两阶段锁协议</span></span><br><span class="line">- 第一阶段是获得封锁,也称为扩展阶段</span><br><span class="line">    - 事务可以申请获得任何数据项上的任何类型的锁,但是不能释放任何锁</span><br><span class="line">- 第二阶段是释放封锁,也成为收缩阶段</span><br><span class="line">    - 事务可以释放任何数据项上的任何类型的锁,但是不能再申请任何锁</span><br><span class="line">遵循两阶段锁协议仍然可能产生死锁.</span><br><span class="line"><span class="comment">##### 封锁的粒度</span></span><br><span class="line">* 封锁对象的大小称为封锁粒度.</span><br><span class="line">* 封锁粒度与系统的并发度和并发控制的开销密切相关.</span><br><span class="line">封锁粒度越小,并发度越高.    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 其他并发控制机制</span></span><br><span class="line">- 意向锁</span><br><span class="line">    - <span class="keyword">IS</span> 意向共享锁</span><br><span class="line">    - IX</span><br><span class="line">    - SIX</span><br><span class="line">数据锁的相容矩阵</span><br><span class="line">![](https://rlj<span class="number">-1999</span><span class="number">-1259282223.</span>cos.ap-beijing.myqcloud.com/%E6%<span class="number">95</span>%B0%E6%<span class="number">8</span>D%AE%E5%BA%<span class="number">93</span>/%E4%B9%A0%E9%A2%<span class="number">98</span>/suo3.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 小结</span></span><br><span class="line">- 并发操作带的数据不一致性</span><br><span class="line">    - <span class="number">1.</span>丢失修改</span><br><span class="line">    - <span class="number">2.</span>不可重复读</span><br><span class="line">    - <span class="number">3.</span>读脏数据</span><br><span class="line">- 数据库的并发控制通常使用封锁机制</span><br><span class="line">    - 基本封锁(X锁和S锁)</span><br><span class="line">    - 多粒度封锁(意向锁)</span><br><span class="line">- 活锁和死锁</span><br><span class="line">    - 活锁</span><br><span class="line">    - 死锁(预防,检测)</span><br><span class="line">- 解决数据不一致的并发控制协议:三级封锁协议</span><br><span class="line">- 并发事务调度的正确性</span><br><span class="line">    - 可串行性</span><br><span class="line">        - 并发操作的正确性则通常由两阶段锁协议来保证</span><br><span class="line">        - 两阶段锁协议是可串行化调度的充分条件,但不是必要条件</span><br><span class="line">    - 冲突可串行性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[推荐阅读<span class="number">1</span>](https://blog.csdn.net/sumaliqinghua/article/details/<span class="number">86246762</span>)</span><br><span class="line">[推荐阅读<span class="number">2</span>](https://blog.csdn.net/sumaliqinghua/article/details/<span class="number">85872446</span><span class="comment">#commentBox)</span></span><br><span class="line">[不错的文章](https://blog.csdn.net/weixin_42578658/article/details/<span class="number">90744175</span>)</span><br><span class="line"></span><br><span class="line">有关系模式Sailors(<span class="keyword">sid</span>:<span class="built_in">char</span>(<span class="number">10</span>),sname:<span class="built_in">char</span>(<span class="number">20</span>),rating:<span class="built_in">int</span>,age:<span class="built_in">int</span>),其中<span class="keyword">sid</span>是主关键字，<span class="keyword">sid</span>表示水手的编号，sname表示水手的姓名，rating表示水手的级别，age表示水手的年龄。Boats(bid:<span class="built_in">char</span>(<span class="number">10</span>),bname:<span class="built_in">char</span>(<span class="number">20</span>),color:<span class="built_in">char</span>(<span class="number">10</span>)),其中bid表示船的编号是主关键字，bname是船的名字，color是船的颜色。Reserves(<span class="keyword">sid</span>:<span class="built_in">char</span>(<span class="number">10</span>),bid:<span class="built_in">char</span>(<span class="number">10</span>),rdate:<span class="built_in">date</span>),Reserves中记录水手在哪天定了那只船，其中<span class="keyword">sid</span>是指向Sailors的外关键字,bid是指向Boats的外关键字,(<span class="keyword">sid</span>,bid,rdate)合起来构成Reserves的主关键字。</span><br><span class="line"><span class="string">``</span><span class="string">`sql</span></span><br><span class="line"><span class="string">1.查找至少定过两艘不通船的水手的编号</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Reserves R1</span></span><br><span class="line"><span class="string">Πsid(sid1=sid and bid1&lt;&gt;bid)(R1×Reserves)</span></span><br></pre></td></tr></table></figure>
<p><img src="gx2.png" alt=""></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span>查找水手中年龄最大的水手编号。</span><br><span class="line">先找出所有小于过其他数的数</span><br><span class="line">然后减去这个集合就是最大的了</span><br><span class="line">age &lt; age1</span><br><span class="line"><span class="symbol">R1:</span>= Πage,sid(Sailors)</span><br><span class="line"><span class="symbol">R2:</span>= ρ<span class="built_in">R2</span>(age1,sid1)(<span class="built_in">R1</span>)</span><br><span class="line"><span class="symbol">R3:</span>= Πage,sid(<span class="built_in">R1</span> ∞(age&lt;age1)<span class="built_in">R2</span>)</span><br><span class="line"><span class="symbol">R4:</span>= <span class="built_in">R1</span>-<span class="built_in">R3</span></span><br><span class="line"><span class="symbol">R5:</span>= Πsid(<span class="built_in">R4</span>)</span><br></pre></td></tr></table></figure>
<p><img src="gx1.png" alt=""></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">3.查找所有水手的定船信息，并将结果按水手编号和船的编号排序（水手编号相同再排船的编号）。（5分）</span><br><span class="line"></span><br><span class="line">order by s1,s2 从小到大</span><br><span class="line">order by s1 desc; 从大到小</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> reserves </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> s.sid,b.bid</span><br><span class="line"><span class="number">4.</span>删除名字叫lubber的水手的定船信息。（<span class="number">5</span>分）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> R(a1,a2..) <span class="keyword">values</span> (v1,v2...)</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> reserves <span class="keyword">where</span> reserves.sid = (<span class="keyword">select</span> s.sid <span class="keyword">from</span> sailors <span class="keyword">where</span> s.sname=<span class="string">"lubber"</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>查找定了<span class="number">103</span>号船的水手的详细信息。（<span class="number">4</span>分）</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> sailors s, reserves r</span><br><span class="line"><span class="keyword">where</span> s.sid=r.sid <span class="keyword">and</span> b.bid = <span class="number">103</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>查找级别最高的水手中年龄最小的水手编号。（<span class="number">6</span>分）</span><br><span class="line"></span><br><span class="line">先找级别最高的还是用减法</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> s1.sid</span><br><span class="line"><span class="keyword">from</span> sailors s1</span><br><span class="line"><span class="keyword">where</span> s1.rating &gt;= <span class="keyword">ALL</span>(<span class="keyword">select</span> s2.rating <span class="keyword">from</span> sailors s2)</span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line"><span class="keyword">select</span> s1.sid</span><br><span class="line"><span class="keyword">from</span> sailors s1</span><br><span class="line"><span class="keyword">where</span> s1.age = <span class="keyword">min</span> (<span class="keyword">select</span> s2.age <span class="keyword">from</span> sailors s2)</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>根据下面的要求创建学生表  （<span class="number">5</span>分）</span><br><span class="line">某学院需要完成一个学生选课及成绩管理系统，该系统要求能够登记，修改，查询，统计学生、课程、选课的基本信息。</span><br><span class="line">学生的基本信息包括：学号(<span class="keyword">sid</span>:<span class="built_in">char</span>(<span class="number">10</span>))，姓名(<span class="keyword">name</span>:<span class="built_in">char</span>(<span class="number">10</span>))，性别(gender:<span class="built_in">char</span>(<span class="number">2</span>))，入学年份(grade:<span class="built_in">char</span>(<span class="number">4</span>)）。</span><br><span class="line">课程的基本信息包括：课程编号(cid:<span class="built_in">char</span>(<span class="number">10</span>))，课程名称(cname:<span class="built_in">char</span>(<span class="number">10</span>))，学分(credit:<span class="built_in">char</span>(<span class="number">10</span>))。</span><br><span class="line">选课信息：学生学号(<span class="keyword">sid</span>:<span class="built_in">char</span>(<span class="number">10</span>))，课程号(cid:<span class="built_in">char</span>(<span class="number">10</span>))，选课年份(<span class="keyword">years</span>:<span class="built_in">char</span>(<span class="number">4</span>))，成绩 (mark:<span class="built_in">int</span>)。要求学生基本信息中性别的可选着值只能是（男或女），所有的学生在<span class="number">2014</span>年全部都要选课。</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">    <span class="keyword">sid</span> <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">    gender <span class="built_in">char</span>(<span class="number">2</span>),</span><br><span class="line">    grade <span class="built_in">char</span>(<span class="number">4</span>),</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="keyword">sid</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">class</span>(</span><br><span class="line">    cid <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">    cname <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">    credit <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">    primary <span class="keyword">key</span> (cid)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> xuanke(</span><br><span class="line">    <span class="keyword">sid</span> <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">    cid <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">years</span> <span class="built_in">char</span>(<span class="number">4</span>),</span><br><span class="line">    mark <span class="built_in">int</span>,</span><br><span class="line">   <span class="keyword">constraint</span> fx_sid <span class="keyword">foreign</span> <span class="keyword">key</span> (<span class="keyword">sid</span>) <span class="keyword">references</span> student(<span class="keyword">sid</span>),</span><br><span class="line">   <span class="keyword">constraint</span> fx_cid <span class="keyword">foreign</span> <span class="keyword">key</span> (cid) <span class="keyword">references</span> <span class="keyword">class</span>(cid)</span><br><span class="line">)</span><br><span class="line"><span class="number">8.</span>设有关系模式R(A，B，C，D)，其上的函数依赖集：F＝&#123;A→C，C→A，B→AC，D→AC&#125;  （<span class="number">15</span>分）  </span><br><span class="line">(<span class="number">1</span>).计算(AD)+。      （<span class="number">2</span>分）</span><br><span class="line">AD+ = ADC</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>).求F的函数依赖最小等价依赖集。   （<span class="number">5</span>分） </span><br><span class="line">先拆右边不为单</span><br><span class="line">A→C,C→A,B→A,B→C,D→A,D→C</span><br><span class="line">因为B→A,A→C可以推出B→C 删除 B→C 同理删除 D→C</span><br><span class="line">然后剩下</span><br><span class="line">A→C,C→A,B→A,D→A</span><br><span class="line">若删除 A→C,A+=A</span><br><span class="line">若删除 C→A,C+=C</span><br><span class="line">同理</span><br><span class="line">最后F的最小等价依赖集为</span><br><span class="line">&#123;A→C,C→A,B→A,D→A&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>).求R的一个关键字。 （<span class="number">3</span>分）</span><br><span class="line"></span><br><span class="line">L:BD</span><br><span class="line">R:</span><br><span class="line">LR:A C </span><br><span class="line">N:</span><br><span class="line">BD+=BDAC</span><br><span class="line">所以BD是R的一个关键字</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>).将R分解成满足<span class="number">3</span>NF并具有无损连接性与保持依赖性。（<span class="number">5</span>分）</span><br><span class="line"></span><br><span class="line">已知R的最小依赖集为</span><br><span class="line">A→C,C→A,B→A,D→A</span><br><span class="line"></span><br><span class="line">BD是关键字</span><br><span class="line"></span><br><span class="line">AC,CA,BA,DA, BDC加入BD</span><br><span class="line">则 分解为AC,BA,DA,BD</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  有关系模式 employee(ssn:string,name:string,city:string)</span><br><span class="line">              department(did:string,cname:string,city:string)</span><br><span class="line">              works(ssn:string,did:stirng,salary:real)</span><br><span class="line">     各关系模式的关键字用下划线表示,其中works的关键字中的ssn来自employee,cid来自department. 关系模式work表示员工工作与某个部门,并且记录员工的工资.</span><br><span class="line">1.查找员工人数最少的部门编号.</span><br><span class="line">     <span class="keyword">Select</span>  temp.did</span><br><span class="line">     <span class="keyword">From</span> (<span class="keyword">Select</span> <span class="keyword">count</span>(*) <span class="keyword">as</span> nu,did</span><br><span class="line">           <span class="keyword">From</span> department D,works W</span><br><span class="line">           <span class="keyword">Where</span> D.did=W.did</span><br><span class="line">           <span class="keyword">Group</span> <span class="keyword">by</span>(did)) <span class="keyword">As</span> temp</span><br><span class="line">     <span class="keyword">Where</span> Temp.nu = (<span class="keyword">SELECT</span>  <span class="keyword">MIN</span> (Temp.nu) <span class="keyword">FROM</span>  Temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>查找在所有部门工作过的员工的姓名.</span><br><span class="line"><span class="keyword">SELECT</span>  e.name</span><br><span class="line"><span class="keyword">FROM</span>  employess e</span><br><span class="line"><span class="keyword">WHERE</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> </span><br><span class="line">              ((<span class="keyword">SELECT</span>  D.did</span><br><span class="line">                 <span class="keyword">FROM</span>  Department D)</span><br><span class="line">                <span class="keyword">EXCEPT</span></span><br><span class="line">                 (<span class="keyword">SELECT</span>  W.did</span><br><span class="line">                  <span class="keyword">FROM</span>  <span class="keyword">Work</span>  W</span><br><span class="line">                  <span class="keyword">WHERE</span>  W.ssn=e.ssn))</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">找出至少两种/三种.... group by havaing count() &gt;=2(3/4);</span><br><span class="line"><span class="keyword">SELECT</span>  M.maker</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">        (<span class="keyword">SELECT</span> maker,</span><br><span class="line">                R.model</span><br><span class="line">        <span class="keyword">FROM</span>    PC P,</span><br><span class="line">                Product R</span><br><span class="line">        <span class="keyword">WHERE</span>   SPEED &gt;= <span class="number">3.0</span></span><br><span class="line">            <span class="keyword">AND</span> P.model=R.model</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">UNION</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">SELECT</span>  maker,</span><br><span class="line">                R.model</span><br><span class="line">        <span class="keyword">FROM</span>    Laptop L,</span><br><span class="line">                Product R</span><br><span class="line">        <span class="keyword">WHERE</span>   speed &gt;= <span class="number">3.0</span></span><br><span class="line">            <span class="keyword">AND</span> L.model=R.model</span><br><span class="line">        ) M</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> M.maker</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(M.model) &gt;= <span class="number">2</span> ;</span><br><span class="line">至少三艘船...</span><br><span class="line"><span class="keyword">SELECT</span>  O.battle</span><br><span class="line"><span class="keyword">FROM</span>    Ships S  ,</span><br><span class="line">        Classes C,</span><br><span class="line">        Outcomes O</span><br><span class="line"><span class="keyword">WHERE</span>   C.Class = S.class</span><br><span class="line">    <span class="keyword">AND</span> O.ship  = S.name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> C.country,</span><br><span class="line">        O.battle</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(O.ship) &gt;= <span class="number">3</span>; </span><br><span class="line">3. 查找定了所有船的水手的编号和姓名</span><br><span class="line"></span><br><span class="line">sql</span><br><span class="line"><span class="keyword">select</span> s.sid,s.name</span><br><span class="line"><span class="keyword">from</span> saliors</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> b.bid </span><br><span class="line">    <span class="keyword">from</span> boats b</span><br><span class="line">    <span class="keyword">except</span> </span><br><span class="line">    <span class="keyword">select</span> r.bid</span><br><span class="line">    <span class="keyword">from</span> reserves r</span><br><span class="line">    <span class="keyword">where</span> r.sid=s.sid</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> s.sid,s.sname</span><br><span class="line">    <span class="keyword">from</span> sailors s</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">not</span> exist (</span><br><span class="line">            <span class="keyword">select</span> b.bid</span><br><span class="line">            <span class="keyword">from</span> boats b</span><br><span class="line">            <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">                    <span class="keyword">select</span> r.bid</span><br><span class="line">                    <span class="keyword">from</span> reserves r</span><br><span class="line">                    <span class="keyword">where</span> r.bid=b.bid</span><br><span class="line">                    <span class="keyword">and</span> r.sid=s.sid</span><br><span class="line">            )</span><br><span class="line">    )</span><br><span class="line">这个人如果都定过就不存在有没订过的船</span><br><span class="line"><span class="number">1</span>)找这人没定过的船,</span><br><span class="line"><span class="number">2</span>)没找到 <span class="keyword">not</span> exist 成立 选出这个人</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 找最大订船数量</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sid</span>,cbid</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(bid) cbid,<span class="keyword">sid</span></span><br><span class="line">    <span class="keyword">from</span> R</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">sid</span></span><br><span class="line">)T1</span><br><span class="line"><span class="keyword">where</span> T1.cbid = (<span class="keyword">select</span> <span class="keyword">max</span>(cbid) <span class="keyword">from</span> T1)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 查找订过红色船也订过绿色船水手的编号和姓名</span><br><span class="line"></span><br><span class="line"><span class="keyword">Select</span> s.sname <span class="keyword">from</span> sailors s,reserves r,boats b </span><br><span class="line"><span class="keyword">Where</span> s.sid=r.sid <span class="keyword">and</span> r.bid=b.bid <span class="keyword">and</span> b.color=’red’</span><br><span class="line"><span class="keyword">intersect</span> </span><br><span class="line"><span class="keyword">Select</span> s.sname <span class="keyword">from</span> sailors s,reserves r,boats b </span><br><span class="line"><span class="keyword">Where</span> s.sid=r.sid <span class="keyword">and</span> r.bid=b.bid <span class="keyword">and</span> b.color=’green’</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 统计各班学生的数据库原理的最高分。</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> s.class,<span class="keyword">max</span>(e.grade) </span><br><span class="line"><span class="keyword">from</span> students s,course c,enrolled e</span><br><span class="line"><span class="keyword">where</span> c.cid=e.cid <span class="keyword">and</span> cname= <span class="string">'数据库原理'</span> <span class="keyword">and</span> </span><br><span class="line">    s.sid = e.sid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.class </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(grade)  <span class="keyword">from</span> student <span class="keyword">natural</span> <span class="keyword">join</span> course <span class="keyword">natural</span> <span class="keyword">join</span> enrolled </span><br><span class="line"><span class="number">6.</span> 查找数据库原理课程平均分最高的班级中数据库原理课程的最低分。</span><br><span class="line">创建一个视图??</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(T1.avg_grade)</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">avg</span>(e.grade) <span class="keyword">as</span> avg_grade</span><br><span class="line"><span class="keyword">from</span> students s,course c,enrolled e</span><br><span class="line"><span class="keyword">where</span> c.cid=e.cid <span class="keyword">and</span> cname= <span class="string">'数据库原理'</span> <span class="keyword">and</span> </span><br><span class="line">    s.sid = e.sid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.class</span><br><span class="line">) T1</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 订过所有船的水手的姓名及编号</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.sid,s.name</span><br><span class="line"><span class="keyword">from</span> saliors</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> b.bid </span><br><span class="line">    <span class="keyword">from</span> boats b</span><br><span class="line">    <span class="keyword">except</span> </span><br><span class="line">    <span class="keyword">select</span> r.bid</span><br><span class="line">    <span class="keyword">from</span> reserves r</span><br><span class="line">    <span class="keyword">where</span> r.sid=s.sid</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 查找没有定过船的水手消息（<span class="keyword">sid</span>，sname，rating，age）</span><br><span class="line"><span class="keyword">select</span> s.sid,s.name,s.rating,s.age</span><br><span class="line"><span class="keyword">from</span> sailors</span><br><span class="line"><span class="keyword">except</span></span><br><span class="line"><span class="keyword">select</span> s.sid,s.name,s.rating,s.age</span><br><span class="line"><span class="keyword">from</span> sailors nature <span class="keyword">join</span> reserves</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>将水手的级别分为初级，中级，高级,其中初级表示为 rating &lt;=3,中级表示为 rating &gt;3 and rating &lt;=9,高级表示为 rating&gt;10.统计这三个级别（初，中，高）中水手的人数。 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">count</span>(*)  <span class="keyword">from</span> sailors <span class="keyword">where</span> rating &lt;=<span class="number">3</span>) chuji</span><br><span class="line">    <span class="keyword">cross</span> <span class="keyword">join</span></span><br><span class="line">    (<span class="keyword">count</span>(*)  <span class="keyword">from</span> sailors <span class="keyword">where</span> rating &gt;<span class="number">3</span> <span class="keyword">and</span> rating&lt;=<span class="number">9</span>) zhongji</span><br><span class="line">      <span class="keyword">cross</span> <span class="keyword">join</span></span><br><span class="line">     (<span class="keyword">count</span>(*)  <span class="keyword">from</span> sailors <span class="keyword">where</span>  rating&gt;<span class="number">9</span>) gaoji</span><br><span class="line">     )</span><br></pre></td></tr></table></figure>




</li>
</ol>
<ol start="6">
<li>统计每个水手订船的次数，并按订船次数降序排序<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> sname, <span class="keyword">count</span>(*) <span class="keyword">num</span></span><br><span class="line"><span class="keyword">from</span> sailors <span class="keyword">natural</span> <span class="keyword">join</span> reserves </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">num</span>  <span class="keyword">desc</span></span><br></pre></td></tr></table></figure></li>
<li>在 club 数据库中定义一个合适的对象，能够实现下面的功能<br>当使用 insert 语句对 sailors 表插入记录时如果某些记录的 age 值小于 19，同时将这些 age 小于 19 的记录插入到 yangsaliors 表中。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> ST</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> sailors</span><br><span class="line"><span class="keyword">referencing</span></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">row</span> <span class="keyword">as</span> newrow</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">when</span> (new.age &lt;<span class="number">19</span> )</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> yangsaliors(<span class="keyword">sid</span>,<span class="keyword">name</span>,age) <span class="keyword">values</span>(newrow.sid,new.name,new.age)</span><br></pre></td></tr></table></figure>
<p>查找选修了全部课程的学生的学号、姓名 (两种语法  )</p>
<p>工资大于某个数值的 员工的ID以及最高的工资 并按照员工的序号进行排序<br>某一列进行重命名，给最高的工资重命名 要求这一列都是最高的工资</p>
<p> 关系代数 5分<br>查找至少选择了两门、三门课程的学生<br>关系代数表示约束 主键外键 用两种方式来表的<br> 两个学生的学号是一样的 =空集 属于</p>
<p> 规范化理论 8分</p>
<p> 问答题24分<br>1.授权图 画图<br>2.给一个调度 有读写 什么叫有冲突的<br>两个事物对同一个事物的读与写<br>看一个调度是否是可串行化的 画一个优先图 没有环 然后给等价的串行调度<br>3.关于日志恢复的 日志记录 redo日志 undo日志<br>书上例子 根据这段日志 来恢复磁盘上的数据  以及恢复之后是什么样子的 书上的例题<br>4.数据库设计题 12分<br>给一个描述  如图书馆、购物网站的设计图 主键必须写下划线。</p>
<p>冲突是指<font color =red size = 5>  不同的事务对同一数据的读写操作和写写操作**</font></p>
]]></content>
      <categories>
        <category>期末</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统习题整理</title>
    <url>/2020/01/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="操作系统习题"><a href="#操作系统习题" class="headerlink" title="操作系统习题"></a>操作系统习题</h2><h3 id="虎哥语录"><a href="#虎哥语录" class="headerlink" title="虎哥语录"></a>虎哥语录</h3><p>本次考试题型: 选择题(30道,60分)+ 计算题 +<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/os7.png" alt=""></p>
<a id="more"></a>
<ul>
<li><p>四个状态的转移过程</p>
<ul>
<li>running到blocked状态由进程自己进入。</li>
<li>running到ready状态是由调度程序进行的。</li>
<li>ready到running状态是由调度程序进行的。</li>
<li>blocked到ready状态是靠中断进行。<br>Running,Ready,Block,是怎么转化的,为什么可以转换,为什么不能转换?</li>
</ul>
</li>
<li><p>Ready状态是暂时没有CPU分配给他</p>
</li>
<li><p>进程执行一个系统调用调用进入阻塞态</p>
</li>
<li><p>当进程等待的一个外部事件发生时(如一些输入到达),则 block转换为ready,如果此时没有其他进程运行,立即又转换为了running</p>
<ul>
<li>A 运行状态 进程占用着CPU，并且在CPU上运行。显然处于这种状态的进程数量&lt;=CPU的数目。若只有一个CPU那么任何时刻最多只能有一个进程处于运行状态。</li>
<li>B 就绪状态 进程已经具备了运行的条件，但由于CPU正忙着运行其他的进程，所以暂时不能运行。不过只要把CPU分给它，它就立刻可以运行。正所谓万事俱备只欠东风。 </li>
<li>C 阻塞状态 进程因为某种事件的发生暂时不能运行的状态。例如它正等待某个输入输出的操作完成，或者它与其他线程之间存在同步关系，需要等待其他进程给它输入数据。这种情况下即使CPU已经空闲下来，这个进程还是不能运行。 </li>
<li>D 状态切换 运行可转化为阻塞、就绪。 阻塞可转化为就绪。 就绪可转化为运行。</li>
</ul>
</li>
<li><p>线程:</p>
<ul>
<li>引入了多线程机制之后，进程的职责发生了变化，进程只负责资源的管理，线程负责运行。(调度分派的最小单位吗???)</li>
<li>同一个进程里的多个线程会共享资源，每个线程都有自己的栈，局部变量在计算机真正执行的时候不存在，局部变量都是栈。</li>
</ul>
</li>
<li><p>线程实现的机制:</p>
<ul>
<li>内核空间:调度的颗粒度更细了，但是每一次调度都在内核调度，所以时间开销很大。内核的调度策略是固定的，不够灵活。</li>
<li>用户空间:调度灵活，可以定制自己的调度策略，不需要切换到内核态，时间开销很小，但调度颗粒度大。</li>
</ul>
</li>
<li><p>调度:</p>
<ul>
<li>FCFS 先来先服务</li>
<li>SJF (shortest job first) 最短作业优先</li>
<li>HRF (high response-radio first.) 最高相应比优先</li>
<li>SRF (shortest remaining-time first) 最短剩余时间优先</li>
</ul>
</li>
<li><p>实时系统的调度算法重要的思想：</p>
<ul>
<li>round robin：时间片轮转，体现公平性，但无法体现出优先级，新来的永远放在队列尾，时间片定多大合适没有准确值。</li>
<li>priority：优先级调度算法，有可能出现“饥饿”现象，在一般执行过程中优先级会有动态调整。(饥饿现象就是 长时间没有获得资源,类似很长时间没吃饭就饿了)</li>
</ul>
</li>
<li><p>race condition：</p>
<ul>
<li>四个标准: 最重要的两个: 互斥,progress(简称)</li>
<li>progress: 不在临界区的进程不能阻止其他想进入的进程进入。</li>
<li>critical regions(临界区)：访问共享资源的一段代码。</li>
</ul>
</li>
<li><p>解决互斥问题(软件):</p>
<ul>
<li>严格轮转法（strict alternation）：理解思想。可以解决互斥，但无法保证progress</li>
<li>Peterson方法：都可以解决，但只能解决两个进程之间的问题。可以有解决多个进程之间的问题，但我们没有学。</li>
</ul>
</li>
<li><p>解决互斥问题(硬件)</p>
<ul>
<li>TSL（TEST AND LOCK）机器指令级的原子操作（？好像是这么说的）<br>我记得罡哥说:<strong>TSL</strong>指令 (背下来)<br>附上代码<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>信号量(PV题):</p>
<ul>
<li>忙等待(无法保证谁先进去)和睡眠与唤醒</li>
<li>信号量只能通过PV操作进行改变</li>
</ul>
</li>
<li><p>死锁:</p>
<ul>
<li>四个必要条件<ul>
<li>(1)互斥使用(资源独占)：一个资源每次只能给一个进程使用</li>
<li>(2)占有且等待(请求和保持，部分分配)：进程在申请新的资源的同时保持对原有资源的占有</li>
<li>(3)不可抢占(不可剥夺)：资源申请者不能强行的从资源占有者手中夺取资源，资源只能由占有者自愿释放</li>
<li>(4)循环等待：存在一个进程等待队列 {P1 , P2 , … , Pn}，其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路。</li>
</ul>
</li>
</ul>
</li>
<li><p>解决死锁的方法:</p>
<ul>
<li>检测与恢复<ul>
<li>检测算法:<ul>
<li>（1）利用图，如果出现环，则有可能出现死锁。</li>
<li>（2）利用资源分配矩阵。</li>
</ul>
</li>
<li>恢复:<ul>
<li>抢占</li>
<li>回滚</li>
<li>杀死 (杀死年轻的进程,或者优先级低的)</li>
</ul>
</li>
</ul>
</li>
<li>死锁避免<ul>
<li>银行家算法</li>
</ul>
</li>
<li>死锁预防<ul>
<li>（1）如何解决互斥：Spooling.</li>
<li>（2）如何解决部分持有并等待：要么全部分配，要么不分配，即不会出现部分持有但是该方法实际上不可行，因为必须事先知道需要用到哪些资源。</li>
<li>（3）如何解决循环等待：对所有资源编号，然后按序分配。</li>
</ul>
</li>
</ul>
</li>
<li><p>存储模型:<br>金字塔模型,从上到下规律<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/os8.png" alt=""></p>
</li>
<li><p>固定分区:启动时把内存分为不等的固定大小，然后采用best fit算法决定要把进程放到哪里，解决外碎片的利用问题。固定分区没有外碎片，所以需要解决的是内碎片问题，内碎片无法被再利用。</p>
</li>
<li><p>可变分区：有各种fit算法，需要了解。</p>
<ul>
<li>BF</li>
<li>WF</li>
</ul>
</li>
<li><p>Swap（交换）：为了让内存容纳更多的进程（透明）。</p>
</li>
<li><p>Overlay（部分交换）：需要自己写代码实现Overlay（不透明）。</p>
</li>
<li><p>虚拟内存:</p>
<ul>
<li>分页:页号，页帧号，需要会算页号，物理地址。</li>
<li>TLB:时间计算</li>
<li>多级页表：需要会算需要几级页表。</li>
<li>倒排页表：根据内容查下标，提速方法：哈希。</li>
<li>页面置换算法<ul>
<li>最优页面置换算法(OPT)<br>  置换以后不再被访问，或者在将来最迟才会被访问的页面，缺页中断率最低，但是该算法需要知道后面各页面的使用情况，而现实中一个进程正在运行时，很难知道后面的过程，所以该算法无法被实现。</li>
<li>最近未使用页面置换(NRU)算法<br>  系统为每一个页面设置两个标志位：当页面被访问时设置R位，当页面被修改时设置M位。当发生缺页中断时，系统会检查所有的页面，并根据当前的R位和M位的值分为四类：（0）未被访问也未被修改（1）未被访问但被修改（2）被访问但未被修改（3）已被访问且已被修改</li>
<li>FIFO算法<br>  置换最先调入内存的页面，即置换在内存中驻留时间最长的页面。</li>
<li>second chance算法<br>  这是FIFO算法的一种改进方法，第二次机会算法给每个界面增加一个R位，每次先从链表头部开始查找，如果R置位，则清除R位并且把该页面的节点放到链表结尾；如果R是0，那么就直接替换掉。</li>
<li>clock算法<br>  这种算法是一个环形链表的第二次机会算法，指针指向最老的页面，缺页中断时，检查表针指向的页面，如果R位为0，淘汰页面，如果R位为1，则清除R位并向前移动表针。</li>
<li>LRU算法<ul>
<li>在缺页中断时，置换未使用时间最长的页面。但是完全实现LRU的代价很高。</li>
<li>下面介绍一个使用软件实现的解决方案<br>将每一个页面与一个计数器关联，每次时钟终端，扫描所有页面，把每个页面的R位加到计数器上，这样就跟踪了每个页面的使用情况。这种算法被称为最不常用（NFU）算法。<br>但这样还是存在一个问题，即很久之前的使用与最近的使用权重相等。<br>所以再次进行改进，将计数器在每次时钟滴答时，右移一位，并把R位加在最高位上，这种算法被称为老化（Aging）算法，增加了最近使用的权重。</li>
</ul>
</li>
</ul>
</li>
<li>缺页中断:<ul>
<li>与普通中断的区别:<ul>
<li>在指令执行期间产生和处理中断信号</li>
<li>一条指令在执行期间，可能会产生多次缺页中断</li>
<li>缺页中断返回时，会重新执行产生中断的那一条指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>硬链接和符号链接的区别:</p>
<ul>
<li>硬链接（Hard Link）：文件A是文件B的硬链接，则A的目录项中的inode节点号与B的目录项中的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说完全平等。删除其中一个对另外一个没有影响。只是inode节点上的链接数变化而已。           </li>
<li>符号链接（Symbolic Link）：A是B的符号链接，A的目录项中的inode节点号与B的目录项中的inode节点号不相同，A和B指向的是两个不同的inode，继而指向两块不同的数据块。但是A的数据块中存放的只是B的路径名。A和B之间是“主从“关系，如果B被删除了，A仍然存在，但指向的是一个无效的链接。</li>
</ul>
</li>
<li><p>文件的权限</p>
<ul>
<li>r:read</li>
<li>w:write</li>
<li>x:execute<br>第一部分属于用户，第二部分属于用户组，第三部分属于其他<br>例如 -rw-r-r– 644</li>
</ul>
</li>
<li><p>多级索引:<br>  会算能够支持的最大文件</p>
</li>
<li><p>调度</p>
<ul>
<li>FIFO调度</li>
<li>最短寻道优先</li>
<li>SCAN调度</li>
<li>CSCAN调度<br>类似于SCAN调度，C-SCAN调度移动磁头从磁盘一端到磁盘另一端，并且处理行程上的请求，但是当磁头到达另一端时，它立即返回到磁盘的开头，不处理任何回程上的请求。<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3></li>
</ul>
</li>
</ul>
<h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><ol>
<li><p>若磁盘转速为7200转/分，平均寻道时间为8ms,每个磁道包含1000个扇区，则访问一个扇区<br>的平均存取时间大约是(B)<br>A．8.1ms B．12.2ms C．16.3ms D．20.5ms</p>
<blockquote>
<p>这题跟扇区没啥关系,大骗子</p>
</blockquote>
</li>
<li><p>设某文件为索引顺序文件，由 5 个逻辑记录组成，每个逻辑记录的大小与磁盘块的大小相等， 均为 512B，并依次存放在 50、121、75、80、63 号磁盘块上。若要存取文件的第 1569 逻辑字节处的信息，则要访问的磁盘块号是<br>A. 3    B. 75    C. 80    D. 63</p>
</li>
<li><p>某磁盘的转速为10000转/分，平均寻道时间是6 ms，磁盘传输速率是20 MB/s，磁盘控制器延迟为0.2 ms，读取一个4 KB的扇区所需的平均时间约为 B<br>A. 9 ms    B. 9.4 ms    C. 12 ms    D. 12.4 ms</p>
<blockquote>
<p>第一部分 找到磁道的时间 = 平均寻道时间 = 6ms<br>第二部分 找到扇区的时间 = 磁盘转一圈的时间÷2（因为不知道扇区具体在哪按半圈算）=（60秒）/（2*10000转/分）=3ms<br>第三部分 磁盘控制器延迟时间 = 0.2ms<br>第四部分 数据传输时间 = 传输字节数 / 磁盘传输速度 = 4K / 20M = 0.2ms（1K≈10的3次方）<br>综上 6ms+3ms+0.2ms+0.2ms=9.4ms。</p>
</blockquote>
</li>
<li><p>若某文件系统索引结点（inode）中有直接地址项和间接地址项，则下列选项中，与单个文件长度无关的因素是 A<br>A.索引结点的总数    B.间接地址索引的级数    C.地址项的个数    D.文件块大小</p>
<blockquote>
<blockquote>
<p>A<br>Linux使用索引节点来记录文件信息，作用类似于Windows下的文件分配表。索引节点是一个结构，它包含了一个文件的长度、创建及修改时间、权限、所属关系、磁盘中的位置等信息。</p>
</blockquote>
</blockquote>
</li>
<li><p>一个磁盘的转速为 7200 转/分，每个磁道有 160 个扇区，每个扇区为 512B， 那么理想情况下，其数据传输率为<br>A. 576000KB/s B. 7200KB/s C. 9600KB/s D. 19200KB/s</p>
<blockquote>
<p>C<br>[解析] 磁盘的转速为7200r/min=120r/s，转一圈经过160个扇区，每个扇区有512B所以数据传输率为120×160×512/1024=9600KB/s。<br>[归纳总结] 磁盘的数据传输率=每一道的容量/旋转一圈的时间=每一道的容量×转速</p>
</blockquote>
</li>
<li><p>现有容量为10GB的磁盘分区，磁盘空间以簇（cluster）为单位进行分配， 簇的大小为4KB。若采用位图法管理该分区的空闲空间，即用一位（bit）标识一个簇是否被分配，则存放该位图所需要簇的个数为：<br>A. 80 B. 320 C. 80K D. 320K</p>
<blockquote>
<p>方法一：设磁盘容量为A,则<br>A=10G=10 * 1024 M<br>=10 * 1024 * 1024 K<br>=10 * 1024 * 1024 * 1024 byte<br>=10 * 1024 * 1024 * 1024 * 8 bit<br>设簇大小为B,则<br>B=4K<br>=4 * 1024byte<br>=4 * 1024*8bit<br>设C为10G所需标识的位数，则<br>C=A/B<br>=320K<br>320K/4K=80个<br>方法二：<br>磁盘簇个数：10 * 1024 * 1024KB/4KB=2621440bit，<br>一个簇能容纳的bit数：4 * 1024 * 8= 32768bit<br>则存放该位图所需簇的个数 2621440/ 32768=80个簇</p>
</blockquote>
</li>
<li><p>在文件的索引节点中存放直接索引指针10个，一级二级索引指针各1 个，磁盘块大小为1KB。每个索引指针占4个字节。若某个文件的索引节点已在内存中，到把该文件的偏移量（按字节编址）为1234和307400处所在的磁盘块读入内存。需访问的磁盘块个数分别是（B）<br>A．1，2    B．1，3    C．2，3    D．2，4<br>已知在UNIX文件系统中,</p>
</li>
<li><p>执行命令touch file1新建一个文件，然后执行命令ln -s file1 link1为file1创建一个符号链接link1，再 执行ln link1 link2为link1创建一个（硬）链接，则此时file1的link counter为<strong>B_</strong>。<br>A．0 B．1 C．2 D．3</p>
</li>
<li><p>执行命令rm link1删除link1成功，则此时尝试显示link2的内容，执行cat link2，结果为 _B__。<br>A．提示文件不存在 B．打开文件file1 C．打开一个空文件 D．link2被删除</p>
<h4 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h4></li>
<li><p>UNIX操作系统中，给文件分配外存空间采用的是混合索引分配方式。索引节点（inode）中包含10个直接块指针、1个一级间接块指针、1个二级间接块指针和1个三级间接块指针，间接块指向的是一个索引块，每个索引块和数据块的大小均为4KB，地址指针所占空间为4B。假设该索引节点已经被加载进内存中，则：<br>（1）该文件能支持的最大容量是多少。<br>（2）若要读取文件的第1000B的内容，需要访问磁盘多少次。<br>（3）若要读取文件的第10MB的内容，需要访问磁盘多少次。</p>
<blockquote>
<p>解：（1）一个指针块有 4KB/4B=1K 个指针，故最大支持的文件大小为：<br>[10+2^10 +(2^10) ^2+ (2^10) ^3]  * 4KB 约等于 4TB 即可 （2 分）<br>（2）1000B &lt; 4KB ，直接指针，一个数据块即可访问到，1 次。（2 分）<br>（3）(10+2^10)*4KB &lt; 1000MB &lt; [10+ 2^10 +(2^10) ^2] * 4KB，需要使用二级间接指针，访问两次间接索引块和一个数据块，共 3 次。（2 分</p>
</blockquote>
</li>
<li><p>、当前磁盘读写位于柱面号20，并向柱面号增大方向运动。此时有以下磁盘请求序列：10、22、2、40、6、38。寻道时移动一个柱面需要1ms，则按照先来先服务（FCFS）算法的总寻道时间为多少，电梯算法（优化SCAN）的总寻道时间为多少</p>
<blockquote>
<p>解：(1) FCFS = |20-10| + |10-22| + |22-2| + |2-40| + |40-6| + |6-38| = 10+12+20+38+34+32=146 寻道时间<br>146<em>1ms = 146ms（3 分）<br>(2) SCAN 算法，访问顺序：20-&gt;22-&gt;38-&gt;40-&gt;10-&gt;6-&gt;2，磁道数 = 2+16+2+30+4+4=58，寻道时间<br>58</em>1ms=58ms（3 分）</p>
</blockquote>
</li>
<li><p>xv6操作系统中，给文件分配外存空间采用的是混合索引分配方式。索引节点（inode）中包含12 个直接块指针和1个一级间接块指针，间接块指向的是一个索引块，每个索引块和数据块的大小均为一个扇区，即512B，地址指针所占空间为4B。<br>1）该文件系统能支持的文件最大容量是 (1) 70KB    。<br>2）为了支持更大的文件，在不增加 inode 中的指针个数的前提下，取消一个直接块指针，增加一个二级间接块指针，则能支持的文件最大容量是     (2)(11+128+128<em>128) * 512B 。<br>3）在上一问的基础上，若将数据块的大小修改为 1KB，则该文件系统能支持的文件最大容量是 (3)(11+256+256</em>256) * 1KB    。<br>4）在上一问的基础上，假设该索引节点已经被加载进内存中，则若要读取文件的第 10MB 的内容，需要访问磁盘     (4) 3次。<br>5）若 inode 的大小为 128B，NBPI (Number of Bytes Per Inode) 为 2048，则一个 32GB 大小的文件系统中，用于存放数据和间接指针的数据块总大小约为     (5) 30GB。</p>
<blockquote>
<p>答：<br>(1) (12+128)<em>512B = 71680B = 70KB<br>(2) (11+128+128</em>128) * 512B = 8459776B = 8261.5KB =8.068MB<br>(3) (11+256+256<em>256) * 1KB = 65803KB = 64.261MB<br>(4)3次。由上一问知，10MB需要通过二级间接索引访问，故需要访问二个索引块和一个数据块。<br>(5)30GB。inode大小:NBPI = 1:16，故1/16空间存放inode，15/16空间存放数据块。32</em>15/16=30GB。</p>
</blockquote>
</li>
<li><p>在某UNIX操作系统中，文件系统给文件分配外存空间采用的是混合索引分配方式。索引节点（inode）中包含13个直接块指针、1个一级间接块指针和1个二级间接块指针，间接块指向的是一个索引块，每个索引块和数据块的大小一致， 均为1KB，地址指针所占空间为4B。<br>13 * 1 + 256 * 1 +256 * 256 * 1<br>(1) 若某inode共有2个硬链接（hard link），分别为a和b，另有1个符号链接<br>（symbolic link）x-&gt;a，则该inode的link counter为 C。<br>A．0    B．1    C．2    D．3</p>
</li>
</ol>
<p>(2)将a删除后，访问x，结果为 A。<br>A．提示文件不存在    B．打开文件b C．打开一个空文件    D．x已被删除<br><a href="https://blog.csdn.net/kang19970201/article/details/88931745" target="_blank" rel="noopener">软连接和硬链接</a></p>
<p>(3)    假设该索引节点已经被加载进内存中，则若要读取文件的第1MB的内容，需要访问磁盘 C 次。<br>A．1    B．2    C．3    D．4<br> 1级 一个间接块 == 256个指针  256KB  269KB<br>需要访问二级间接  然后再访问数据 3次</p>
<p>(3)    该文件系统能支持的文件最大容量约为     。<br>A．64KB    B．64MB    C．4GB    D．16GB</p>
<blockquote>
<p>B<br>13 * 1 + 256 * 1 +256 * 256 * 1 </p>
</blockquote>
<p>(4)  若将数据块的大小修改为4KB，则该文件系统能支持的文件最大容量约为     。<br>A．64KB    B．64MB    C．4GB    D．16GB</p>
<blockquote>
<p>C<br>13 * 4+1024 * 4 +1024 * 1024 * 4 =4GB </p>
</blockquote>
<p>(5)    若保持数据块大小1KB不变，在不增加inode中的指针个数的前提下，取<br>消一个直接块指针，增加一个三级间接块指针，则能支持的文件最大容量约为     。<br>A．64KB    B．64MB    C．4GB    D．16GB</p>
<blockquote>
<p>D<br>主要看三级指针 256 * 256 * 256 * 1 KB = 2 ^ 24 = 16GB</p>
</blockquote>
<p>(6)    若inode的大小为128B，NBPI (Number of Bytes Per Inode) 为1024，则一个32GB大小的文件系统中，用于存放数据和间接指针的数据块总大小约为         。<br>A．4GB    B．8GB    C．24GB    D．28GB</p>
<blockquote>
<p>D<br>1024/128 = 8  1/8放 inode 7/8 放数据<br>7/8 * 32 = 28GB</p>
</blockquote>
<h4 id="解答题"><a href="#解答题" class="headerlink" title="解答题"></a>解答题</h4><p>关于四种磁盘调度策略的统一说明：</p>
<ul>
<li>1．SCAN算法，磁臂从磁盘的一端向另一端移动，当磁头移过每一个柱面时，处理位于该柱面上的请求服务。当到达另一端时，改变方向继续处理。（每次都运动到顶端）</li>
<li>2．C-SCAN算法，C-SCAN也是将磁头从磁盘一端移到另一端，随着移动不断的处理请求。但是，当磁头移到另一端时，会马上返回到磁盘开始，返回时不处理请求. （每次都运动到顶端）</li>
<li>3．LOOK算法：是改进的SCAN算法，与SCAN相似，只是每次都不运动到顶端，在最大磁道号和最小磁道号之间移动。</li>
<li>4．C-LOOK算法：是改进的C-SCAN算法，与C-SCAN相似，只是每次都不运动到顶端，在最大磁道号和最小磁道号之间移动。</li>
</ul>
<ol>
<li><p>在使用 Linux 操作系统管理文件时，你有一个 2TB 的大数据文件要存放到硬盘上，但是现在只有<br>二个 1TB 大小的硬盘。如果不考虑硬件上购买 RAID 等设备，请问你有什么办法来操作系统软件<br>层面上解决这个问题吗？</p>
<blockquote>
<p>答：使用 LVM 逻辑卷管理。（2 分）将两个硬盘设置成两个物理卷 VG（PV），再加入一个卷组（VG）<br>中，在卷组中创建一个 2TB 的逻辑卷，此时就可以将大数据文件放入此逻辑卷内的文件系统中。（3分）</p>
</blockquote>
</li>
<li><p>假如你刚刚成为一台服务器的管理员，这台服务器安装的是 Linux操作系统。<br>服务器上只有一块容量为 250GB 的硬盘，系统只划分了一个文件系统，所有<br>的数据都在根文件系统中。根据规划，这台服务器将要满足以下的需求：<br>（1） 开放给多个用户使用，限制每个用户在自己的主目录下最多只能存放<br>500MB 数据。另外，每个用户的邮箱限制只能容纳 200MB 的邮件。<br>（2） 目前计划支持的用户数 300 人，但是日后可能扩大，希望空间可以很<br>方便的扩充，但不能影响数据的正常使用。<br>（3） 服务器上安装数据库软件，需要一个很大的文件系统存放数据文件，<br>一个单独的数据文件甚至可能达到 2TB，文件系统则需要随时增长。<br>可以适当购买一些新硬盘，但是市场上能购买到的硬盘最大只有容量<br>为 1TB 的。<br>（4） 因节约成本，服务器没有安装硬件 RAID 支持，也没有购买 SAN 存储<br>阵列的。在这方面近期也没有新的预算。<br>请问你应该如何规划存储方案，满足上述要求？</p>
<blockquote>
<p>答：<br>（1）应该分别新建二个文件系统，一个用于用户主目录，挂载到/home 下，一个用于用<br>户邮箱，挂载到/var 下。使用用户磁盘配额设置，/home 设置每用户 500MB 配额，/var<br>设置每用户 200MB 配额。<br>（2）由于最大的文件系统可能要大于所有的硬盘，并且要满足文件系统可扩充的需求，<br>可以采用逻辑卷管理（LVM）技术。<br>在逻辑卷管理中，硬盘作为物理卷，组成卷组，在卷组中划分逻辑卷，逻辑卷中可以存<br>放文件系统。由于逻辑卷可以跨物理卷，并且可以动态调整大小，所以其中的文件系统<br>也可以具备这些好处</p>
</blockquote>
</li>
<li><p>在 inode 的多级索引指针中，为什么保留了直接指向数据块的指针，而不是<br>设计成只使用一个指向多级间接索引块的指针，就可以访问到所有的数据块？<br>数据块的大小可以影响文件系统能支持的最大文件的大小，但是数据块的大<br>小对文件系统的性能和空间利用率之间有什么关系？为什么？</p>
<blockquote>
<p>答：虽然只使用一个指向三级间接索引块的指针就可以访问到所有的数据块，但是小文<br>件也需要多级寻址，多次访问硬盘，影响速度。保留直接指向数据块的指针后，小文件<br>可以直接定位数据块，节约了访问硬盘的时间，ᨀ高了存取效率。</p>
</blockquote>
</li>
<li><p>、假设计算机系统采用 CSCAN(循环扫描)磁盘调度策略,使用 2KB 的内存空间<br>记录 16384 个磁盘块的空闲状态。<br>6<br>(1) 请说明在上述条件下如何进行磁盘块空闲状态的管理。<br>(2) 设某单面磁盘旋转速度为每分钟6000 转,每个磁道有100 个扇区,相邻磁<br>道间的平均移动时间为1ms。若在某时刻,磁头位于100 号磁道处,并沿着<br>磁道号增大的方向移动(如下图所示),磁道号请求队列为50,90,30,120,对<br>请求队列中的每个磁道需读取1 个随机分布的扇区,则读完这4 个扇区<br>点共需要多少时间?要求给出计算过程。<br>(3) 如果将磁盘替换为随机访问的Flash 半导体存储器(如U 盘、SSD 等),是<br>否有比CSCAN 更高效的磁盘调度策略?若有,给出磁盘调度策略的名称<br>并说明理由;若无,说明理由<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/os3.png" alt=""></p>
<blockquote>
<p>(1)位矢图法<br>(2)CSCAN:190.4ms<br>寻道时间: 20+90+20+40 = 170ms<br>旋转时间: 10ms /2 *4 =20ms<br>读数据: 10ms/100 *4 = 0.4ms<br>(3)FCFS</p>
</blockquote>
</li>
<li><p>在磁盘臂调度算法中，循环扫᧿算法（或称为循环电梯算法）（C-SCAN）对扫᧿算法（或称 为电梯算法）（SCAN）有什么改进之处？</p>
<blockquote>
<p>SCAN算法对两端磁道的响应时间过长，相对中间磁道而言不公平，而C-SCAN公平处理各磁道的请求</p>
</blockquote>
</li>
<li><p>Linux 中的为安全起见，一个用户不能进入另一个用户的主目录。现有一个文件需要<br>共享给二个用户，放在各自主目录下共同使用。如何实现？</p>
<blockquote>
<p>答：<br>方法 1：为这个文件设置两个（硬）连接，分别放在两个用户的主目录下即可。<br>方法 2：将这个文件放在两个用户均可访问的目录中，然后做两个（硬）连接或符号连<br>接，分别入在两个用户的主目录下即可。</p>
</blockquote>
</li>
<li><p>产生死锁的必要条件中，在实际操作系统里，哪个条件最有可能被破坏？如何做到<br>这一点？举例说明。</p>
<blockquote>
<p>答：最容易破坏的条件是：资源互斥使用。部分资源，如打印机，可以通过 SPOOLing<br>机制，为此类资源配备一个等待队列，即可破坏资源互斥使用。</p>
</blockquote>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3></li>
</ol>
<ul>
<li>进程与程序的区别?<br>操作系统中最核心的概念是进程,对正在运行程序的一个抽象.<br>进程是程序的 一次执行 过程，程序是进程 赖以存在 的基础。</li>
<li>多道程序 (伪并行):<br>在1秒钟期间,它可能运行多道程序,给人一种同时并行的错觉<br>拥有1个CPU实现多任务同时进行</li>
<li>在一个单CPU系统中，若有5个用户进程。假设当前系统为用户态，则处于就绪状态的用户进程最多有 4 个，最少有 0 个。<blockquote>
<p>注意，题目里给出的是假设当前系统为用户态，这表明现在有一个进程处于运行状态，因此最多有4个进程处于就绪态。也可能除一个在运行外，其他4个都处于阻塞。这时，处于就绪的进程一个也没有。</p>
</blockquote>
</li>
<li>可以把CPU的指令分为两类，一类是操作系统和用户都能使用的指令，一类是只能由操作系统使用的指令。前者称为“非特权”指令，后者称为“特权”指令。<h4 id="选择题-1"><a href="#选择题-1" class="headerlink" title="选择题"></a>选择题</h4></li>
</ul>
<ol>
<li><p>下列选项中，降低进程优先级的合理时机是<strong>A_</strong>。<br>A. 进程的时间片用完 B. 进程刚完成 I/O ,进入就绪队列<br>C. 进程长期处于就绪队列中 D. 进程从就绪态转为运行态</p>
</li>
<li><p>用户程序发出磁盘I/O请求后，系统的正确处理流程是（B）<br>A. 用户程序-&gt;系统调用处理程序-&gt;中断处理程序-&gt;设备驱动程序<br>B. 用户程序-&gt;系统调用处理程序-&gt;设备驱动程序-&gt;中断处理程序<br>C. 用户程序-&gt;设备驱动程序-&gt;系统调用处理程序-&gt;中断处理程序<br>D. 用户程序-&gt;设备驱动程序-&gt;中断处理程序-&gt;系统调用处理程序</p>
</li>
<li><p>在缺页处理过程中，操作系统执行的操作可能是（D）<br>I. 修改页表 II. 磁盘 I/O III. 分配页框<br>A. 仅 I, II B. 仅 II C. 仅 III D. I, II 和 III</p>
<blockquote>
<p>为什么?</p>
</blockquote>
</li>
<li><p>当系统发生抖动（trashing）时，可以采取的有效措施是（A）<br>I. 撤销部分进程 II. 增加磁盘交换区的容量 III. ᨀ高用户进程的优先级<br>A. 仅 I B. 仅 II C. 仅 III D. 仅 I, II</p>
</li>
</ol>
<ul>
<li>系统抖动，解释为在请求分页存储管理中，从主存（DRAM）中刚刚换出（Swap Out）某一页面后（换出到Disk），根据请求马上又换入（Swap In）该页，这种反复换出换入的现象。</li>
<li>产生该现象的主要原因是置换算法选择不当。<ul>
<li>1.如果分配给进程的存储块数量小于进程所需要的最小值，进程的运行将很频繁地产生缺页中断，这种频率非常高的页面置换现象称为抖动。解决方案优化置换算法。</li>
<li>2.在请求分页存储管理中，可能出现这种情况，即对刚被替换出去的页，立即又要被访问。需要将它调入，因无空闲内存又要替换另一页，而后者又是即将被访问的页，于是造成了系统需花费大量的时间忙于进行这种频繁的页面交换，致使系统的实际效率很低，严重导致系统瘫痪，这种现象称为抖动现象。解决方案运用局部性原理优化置换算法。</li>
</ul>
</li>
<li>危害：系统时间消耗在低速的I/O上，大大降低系统效率。进程对当前换出页的每一次访问，与对RAM中页的访问相比，要慢几个数量级。</li>
</ul>
<ol start="5">
<li><p>若系统S1 采用死锁避免方法，S2采用死锁检测方法，下列叙述中正确的是（）<br>Ⅰ. S1 会限制用户申请资源的顺序<br>Ⅱ．S1 需要进行所需资源总量信息，而 S2 不需要<br>Ⅲ．S1 不会给可能导致死锁的进程分配资源，S2 会<br>A．仅Ⅰ Ⅱ B．仅Ⅱ Ⅲ C．仅Ⅰ Ⅲ D．Ⅰ Ⅱ Ⅲ</p>
</li>
<li><p>两个进程合作完成一个任务。在并发执行中，一个进程要等待其合作伙伴发来消息，或者<br>建立某个条件后再向前执行，这种制约性合作关系被称为进程的（ ）。<br>A．同步 B．互斥 C．调度 D．执行</p>
</li>
<li><p>当一个进程处于(B)状态时,称其为等待(或阻塞)状态.<br>A. 它正等待中央处理机        B.它正等待合作进程的一个消息<br>C. 它正等待分给它一个时间片   D.它正在进入内存</p>
</li>
<li><p>下面关于线程的叙述中,正确的是(C)<br>A.不论是系统支持线程还是用户级线程,其切换都需要内核的支持.<br>B.线程是资源管理的分配单位,进程是调度和分配的单位<br>C.不管系统中是否有线程,进程都是拥有资源的独立单位.<br>D.在引入线程的系统中,进程仍是资源分配和调度分配的基本单位.</p>
</li>
<li><p>段页式存储管理汲取了页式管理和段式管理的长处,其实现原理结合了页式和段式管理的基本思想,即用分段式方法分配和管理用户地址空间,用分页方法管理物理存储空间.</p>
</li>
<li><p>下列调度算法中，不可能导致饥饿现象的是：A<br>A.时间片轮转    B.静态优先级调度    C.非抢占式作业优先    D.抢占式短作业优先</p>
</li>
<li><p>一个进程调用了阻塞式系统调用read()进行读磁盘操作，操作完成后，操作系统针对该进程必须做的是： A<br>A.修改进程状态为就绪态    B.降低进程优先级<br>C.进程分配用户内存空间    D.增加进程的时间片大小  </p>
</li>
<li><p>设m为同类资源数，n为系统中并发线程数。当n个进程共享m个互斥资源时，每个进程的最大需求是w；则下列情况会出现系统死锁的是：D<br>A. m=2,n=1,w=2    B. m=2,n=2,w=1    C. m=4,n=3,w=2    D. m=4,n=2,w=3</p>
</li>
<li><p>下列关于银行家算法的叙述中，正确的是 B<br>A.银行家算法可以预防死锁<br>B.当系统处于安全状态时，系统中一定无死锁进程<br>C.当系统处于不安全状态时，系统中一定会出现死锁进程<br>D.银行家算法破坏了死锁必要条件中的“请求和保持”条件</p>
</li>
<li><p>在多进程的系统中，为了保证公共变量的完整性，各进程应互斥进入临界区。所<br>谓临界区是指<strong><em>D</em></strong>。<br>A．一个缓冲区 B．一段数据区 C．同步机制 D．一段程序</p>
</li>
<li><p>某单CPU系统中有输入和输出设备各1台，现有3个并发执行的作业，每个作业的<br>输入、计算和输出时间均分别为2ms、3ms和4ms，且都按输入、计算和输出的顺序执<br>行，则执行完3个作业需要的时间最少是<strong>B</strong>。<br>A. 15ms B. 17ms C. 22ms D.27ms</p>
</li>
<li><p>下面对进程的描述中，错误的是 D 。<br>A．进程是动态的概念 B．进程的执行需要CPU<br>C．进程具有生命周期 D．进程是指令的集合</p>
</li>
<li><p>既考虑作业等待时间，又考虑作业执行时间的作业调度算法是 A 。<br>A．响应比高者优先 B．短作业优先<br>C．优先级调度 D．先来先服务</p>
<h4 id="计算题-1"><a href="#计算题-1" class="headerlink" title="计算题"></a>计算题</h4></li>
<li><p>有3个CPU密集型批处理作业，按照A、B和C的顺序间隔4分钟依次ᨀ交。预计运行时间分别为12， 8和4分钟。对于下列每种调度算法，忽略进程切换的开销，计算其平均进程周转时间。<br>(1) 采用先来先服务调度算法，平均进程周转时间为多少。 (2) 采用最短作业优先调度算法，平均进程周转时间为多少。</p>
</li>
</ol>
<p>FCFS，作业调度顺序：A-&gt;B-&gt;C</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">到达日期</th>
<th align="center">运行时间</th>
<th align="center">等待时间</th>
<th align="center">结束时间</th>
<th align="center">周转时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">0</td>
<td align="center">12</td>
<td align="center">0</td>
<td align="center">12</td>
<td align="center">12</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">20</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">8</td>
<td align="center">4</td>
<td align="center">12</td>
<td align="center">24</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">故平远周转时间：(12+16+16)/3 = 14.67 min（3 分）</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2）SJF，作业调度顺序：A -&gt;C-&gt;B</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">到达日期</td>
<td align="center">运行时间</td>
<td align="center">等待时间</td>
<td align="center">结束时间</td>
<td align="center">周转时间</td>
</tr>
<tr>
<td align="center">:-:</td>
<td align="center">:-:</td>
<td align="center">:-:</td>
<td align="center">:-:</td>
<td align="center">:-:</td>
<td align="center">:-:</td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">0</td>
<td align="center">12</td>
<td align="center">0</td>
<td align="center">12</td>
<td align="center">12</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">12</td>
<td align="center">24</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">8</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">16</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">故平远周转时间：(12+20+8)/3 = 13.33 min（3 分）</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2. 银行家算法问题</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="解答题-1"><a href="#解答题-1" class="headerlink" title="解答题"></a>解答题</h4><ol>
<li><p>你需要在一个很古老的 UNIX 上编写支持多线程的程序，它的内核不支持线程，内核代码也未公开，所以很难改造内核。请问如何解决这个问题？</p>
<blockquote>
<p>答:应该使用用户态线程。<br>在进程中设计运行时环境，由运行时控制多个线程的调度运行。内核不感知线程的<br>存在，只调度进程。资源分配给进程使用。</p>
</blockquote>
</li>
<li><p>在 UNIX 中父进程通过 fork()产生与自己一模一样的子进程，请问执行什么系统调用后，子进程才拥有自己独立的新代码段。这个系统调用的返回值是如何规定的？</p>
<blockquote>
<p>答:exec    系列函数，如 execlp()等。该系统调用替换进程的正文段，如果成功，没<br>有返回值，如果失败，返回值为-1。</p>
</blockquote>
</li>
<li><p>当检测到死锁发生时，如果必须杀死一个进程以解除死锁，请问以什么标准来选择被杀死的进程比较合理？</p>
<blockquote>
<p>答:一般选择运行时间较短的进程，因为这样重新运行的代价较小，另外，程序<br>需要可以多次运行不影响执行结果。还要考虑杀死优先级较低的进程等</p>
</blockquote>
</li>
<li><p>有三个批处理作业，第一个作业 10:00 到达，需要执行 2 小时;第二个作业在 10:10<br>到 达，需要执行 1 小时;第三个作业在 10:25 到达，需要执行 25 分钟。分别采用<br>先来先服务，短作业优先和最高响应比优先三种调度算法，各自的平均周转时间是多<br>少?</p>
<blockquote>
<p>解：<br>FCFS：执行顺序1-&gt;2-&gt;3，平均周转时间为(120+170+180)/3=156.7分=2.61小时<br>SJF：执行顺序1-&gt;3-&gt;2，平均周转时间为(120+195+120)/3=145分=2.42小时<br>HRF：执行顺序 1-&gt;3-&gt;2，平均周转时间为(120+195+120)/3=145 分=2.42 小时<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/os4.png" alt=""></p>
</blockquote>
</li>
<li><p>某系统有三个作业：<br><img src="https://img-blog.csdn.net/20180920030652549?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDMzNzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>系统确定在它们全部到达后，开始采用响应比高者优先调度算法，并忽略系统调度时间。试问对它们的调度顺序是什么？各自的周转时间是多少？</p>
</li>
</ol>
<p>响应比= 等待时间/所需cpu时间；响应比最高开始运行</p>
<p>解：三个作业是在9.5时全部到达的。这时它们各自的响应比如下：<br>作业1的响应比 =（9.5 – 8.8）/ 1.5 = 0.46<br>作业2的响应比 =（9.5 – 9.0）/ 0.4 = 1.25<br>作业3的响应比 =（9.5 – 9.5）/ 1.0 = 0<br>因此，最先应该调度作业2运行，因为它的响应比最高。它运行了0.4后完成，这时的时间是9.9。再计算作业1和3此时的响应比：<br>作业1的响应比 =（9.9 – 8.8）/ 1.5 = 0.73<br>作业3的响应比 =（9.9 – 9.5）/ 1.0 = 0.40<br>因此，第二个应该调度作业1运行，因为它的响应比最高。它运行了1.5后完成，这时的时间是11.4。第三个调度的是作业3，它运行了1.0后完成，这时的时间是12.4。整个实施过程如下。<br><img src="https://img-blog.csdn.net/20180920031138869?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDMzNzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<ol start="6">
<li><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/os5.png" alt=""><br> ① 系统中资源总量为某时刻系统中可用资源量与各进程已分配资源量之和，所以各种资源总<br>数为(9,3,6)。各进程对资源的需求量为各进程对资源的最大需求量与进程已分配资源量之差，<br> <img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/os6.png" alt=""></p>
</li>
<li><p>死锁是一种对操作系统正常运行危害很大的现象，但是大多数死锁的解决方法只<br>停留在理论探讨中，无法应用于实际的操作系统系统。请列举中哪些方法是实际操作<br>系统中采用的应对死锁的可行方法。如果操作系统发现死锁已经发生，应如何应对使<br>造成的损失较小？</p>
<blockquote>
<p>答:实际常采用的方法:    1、鸵鸟算法。因为处理死锁成本太高，而死锁出现的频<br>率较低，故可以忽略死锁的发生。 2、Spooling 技术。假脱机技术。为临界资源增<br>加一个等待队列，使其好像可以被共享使用，如打印机。 当死锁发生时，杀死运<br>行时间较短的进程，损失较小，因为容易恢复。</p>
</blockquote>
</li>
<li><p>在多道程序设计系统中，如何理解“内存中的多个程序的执行过程交织在一起，大家都在走走停停”这样一个现象？</p>
<blockquote>
<p>答：在多道程序设计系统中，内存中存放多个程序，它们以交替的方式使用CPU。因此，从宏观上看，这些程序都开始了自己的工作。但由于CPU只有一个，在任何时刻CPU只能执行一个进程程序。所以这些进程程序的执行过程是交织在一起的。也就是说，从微观上看，每一个进程一会儿在向前走，一会儿又停步不前，处于一种“走走停停”的状态之中。</p>
</blockquote>
</li>
<li><p>作业调度与进程调度有什么区别？</p>
<blockquote>
<p>答：作业调度和进程调度（即CPU调度）都涉及到CPU的分配。<br>但作业调度只是选择参加CPU竞争的作业，它并不具体分配CPU。<br>而进程调度是在作业调度完成选择后的基础上，把CPU真正分配给某一个具体的进程使用。</p>
</blockquote>
</li>
<li><p>为什么说响应比高者优先作业调度算法是对先来先服务以及短作业优先这两种调度算法的折中？</p>
<blockquote>
<p>答：先来先服务的作业调度算法，重点考虑的是作业在后备作业队列里的等待时间，因此对短作业不利；<br>短作业优先的作业调度算法，重点考虑的是作业所需的CPU时间（当然，这个时间是用户自己估计的），因此对长作业不利。<br>“响应比高者优先”作业调度算法，总是在需要调度时，考虑作业已经等待的时间和所需运行时间之比，即：<br>该作业已等待时间 / 该作业所需CPU时间</p>
</blockquote>
</li>
<li><p>进程可以在运行、就绪和阻塞三个状态之间转换，试分析各种转换的发生时机和引发者</p>
<blockquote>
<p>答：运行-&gt;就绪：运行态进程时间片用完，由scheduler剥夺处理器进行调度。 就绪-&gt;运行：处理器空闲时，由scheduler挑选一个就绪进程，分配其处理器开始运行。 运行-&gt;阻塞：正在运行的进程，发现缺少资源或等待特定事件发生时，主动放弃处理器。 阻塞-&gt;就绪：阻塞态进程，阻塞其运行的条件消失，如缺少的资源可用，或特定的事件发生， 这时该进程被释放该资源或引发该事件的进程唤醒被阻塞的进程，被阻塞的进程转入就绪状态，等待 被调度运行。</p>
</blockquote>
</li>
<li><p>什么是系统调用（System call或称为System API）？简述一下系统调用的使用方法和执行过程。在Shell中执行一个命令，从输入命令开始到命令结束，至少可能会涉及到哪些系统调用，这些系统调用的功能分别是什么？</p>
<blockquote>
<p>答：系统调用是由操作系统内核提供的服务例程。用户程序通过软中断的形式调用系统调用，执行过<br>程与中断相似。在shell中执行的命令，至少要涉及到以下系统调用：<br>fork() 创建一个子进程<br>exec() 替换进程代码段<br>wait() 等待其他进程结束<br>exit() 结束当前进程</p>
</blockquote>
</li>
<li><p>分时操作系统中进程调度算法中对普通进程常常采用的是优先级轮转法，请问如何保证不会有进程因为优先级太低而饥饿？</p>
<blockquote>
<p>答：采用动态调整进程优先级的方法。动态降低长时间占用CPU进程的优先级，低优先级的进程的优先级则相对升高，最终得到运行。</p>
</blockquote>
</li>
<li><p>死锁是一种对操作系统正常运行危害很大的现象，但是大多数死锁的解决方法只停留在理论探讨中，无法应用于实际的操作系统系统。请列举中哪些方法是实际操作系统中采用的应对死锁的可行方法。如果操作系统发现死锁已经发生，应如何应对使造成的损失较小？</p>
<blockquote>
<p>答：实际常采用的方法：<br>1、鸵鸟算法。因为处理死锁成本太高，而死锁出现的频率较低，故可以忽略死锁的发生。<br>2、Spooling技术。假脱机技术。为临界资源增加一个等待队列，使其好像可以被共享使用，如打印机。<br>当死锁发生时，杀死运行时间较短的进程，损失较小，因为容易恢复。</p>
</blockquote>
</li>
<li><p>简述进程与线程的区别与联系。进程间通信和线程间通信有什么异同？<br>答：</p>
<blockquote>
<p>线程是进程中的执行序列，进程是资源分配的单位，进程和线程都可以被调度。进程间一般不共享资源，所以进程间通信需要操作系统内核支持，使用信号、管道、SysV IPC或sockets等技术实现共享信号、信号量、共享内存、队列等信息。同一个进程内的线程间共享进程的所有资源，所以很容易实现通信。进程间与线程间通信都面临互斥和同步问题，也都需要加锁、信号量等方法来解决。</p>
</blockquote>
</li>
<li><p>在引入线程概念的操作系统中，操作系统将资源分配给线程还是进程？为什么？在线程实现<br>的二种方案中，线程实现在用户级与实现在内核级相比，有什么缺点？</p>
<blockquote>
<p>答：资源分配给进程，因为进程是资源分配的最小单位，线程是在进程内，共享使用进程的资<br>源。线程实现在用户级，当一个线程阻塞时，内核会阻塞这个线程所在进程，导致这个进程中<br>其他可以运行的线程也被阻塞。</p>
</blockquote>
</li>
<li><p>什么是 SPOOLing 技术？它是如何在解决死锁问题中得到应用的？</p>
<blockquote>
<p>SPOOLing 技术又称为“假脱机技术“。它可以破坏”独占使用“条件。例如打印机为临界资<br>源，可以在硬盘上开辟一个目录，所有的打印任务都ᨀ交的这个目录下的队列中，由一个打印<br>队列监控程序（daemon）负责将任务送到打印机上打印。</p>
</blockquote>
</li>
<li><p>为什么要使用倒排页表？倒排页表面临的最大的问题是什么？如何解决？</p>
<blockquote>
<p>答：在 64 位系统中，由于虚拟地址太大，普通页表会非常大，无法存储。另一方面，实际内存<br>相对较小，所以建立一张从物理地址索引得到相对地址的倒排页表。<br>最大的问题的难于从相对地址查找到绝对地址。可以采用 hash 表ᨀ高查找效率，并使用 TLB<br>加速查找。</p>
</blockquote>
</li>
<li><h4 id="PV题"><a href="#PV题" class="headerlink" title="PV题"></a>PV题</h4></li>
</ol>
<ul>
<li>“虚拟化与云计算”课程安排上机，假设机房共有 2m 台机器，有 2n 名学生选该课，<br>其中 m,n 为正整数且 m&lt;n。规定：<br>（1） 按到达顺序，两个学生组成一组，每人占一台机器，协同完成上机实习；<br>（2） 两个学生到齐，并且此时机房有空闲机器时，方可进入机房；<br>试用类 C 语言，使用 PV 操作实现上述要求。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore computer=<span class="number">2</span>m; <span class="comment">//控制对机器使用的信号量</span></span><br><span class="line">semaphore pair=<span class="number">0</span>; <span class="comment">//保证学生成对进入的信号量</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>; <span class="comment">//保证变量互斥访问的信号量</span></span><br><span class="line"><span class="keyword">int</span> sc=<span class="number">0</span>; <span class="comment">//到达学生的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">student</span><span class="params">()</span></span>&#123;</span><br><span class="line">P(mutex); <span class="comment">//加锁，保证变量 sc 互斥使用</span></span><br><span class="line">sc=sc+<span class="number">1</span>; <span class="comment">//学生以到达顺序编号</span></span><br><span class="line"><span class="keyword">if</span> (sc%<span class="number">2</span>==<span class="number">1</span>) &#123; <span class="comment">//奇数编号的学生到达</span></span><br><span class="line"> V(mutex); <span class="comment">//解锁</span></span><br><span class="line"> P(pair); <span class="comment">//申请结对进入</span></span><br><span class="line">&#125; <span class="keyword">else</span> ( <span class="comment">//偶数编号的学生到达</span></span><br><span class="line"> V(mutex); <span class="comment">//解锁</span></span><br><span class="line"> V(pair); <span class="comment">//完成结对</span></span><br><span class="line">&#125;</span><br><span class="line">P(computer); <span class="comment">//申请计算机</span></span><br><span class="line">上机实习…</span><br><span class="line">V(computer); <span class="comment">//释放计算机</span></span><br><span class="line">&#125;</span><br><span class="line">评分标准：</span><br><span class="line">（<span class="number">1</span>） 正确定义信号量和共享变量，并赋初值。（<span class="number">2</span> 分）</span><br><span class="line">（<span class="number">2</span>） 正确使用信号量（mutex），保证共享变量（sc）被互斥使用。（<span class="number">2</span> 分）如存在死锁</span><br><span class="line">可能，如在 V(mutex)前就做 P(pair)，则此处只得 <span class="number">1</span> 分。</span><br><span class="line">（<span class="number">3</span>） 正确使用信号量（pair），保证学生结对。（<span class="number">2</span> 分）</span><br><span class="line">（<span class="number">4</span>） 正确使用共享变量（sc），实现对学生编号的判断。（<span class="number">2</span> 分）</span><br><span class="line">（<span class="number">5</span>） 正确使用信号量（computer），实现对计算机资源的控制。（<span class="number">2</span> 分）</span><br><span class="line">解法不唯一，如有其他解题思想，酌情给分。</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>某停车场有 M 个大型车车位和 N 个小型车车位，大型车必须停大型车车位内，小型车优先停小型<br>车车位，在小型车车位全满的情况下，也可以停入大型车车位。大型车与小型车分别从两个入口<br>进入停车场。当车位已满时，车辆在停车场外排队等候。为实现上述控制，请用 PV 原语和信号<br>量，分别描述大型车和小型车使用停车场的过程。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore big=M; <span class="comment">//大型车车位</span></span><br><span class="line">Semaphore all=M+N; <span class="comment">//总车位</span></span><br><span class="line">BigCar()&#123;</span><br><span class="line">P(big); <span class="comment">//如果有大型车车位，则占大型车车位</span></span><br><span class="line">P(all); <span class="comment">//占一个总车位</span></span><br><span class="line">大型车进车位</span><br><span class="line">V(big); <span class="comment">//释放一个大型车车位</span></span><br><span class="line">V(all); <span class="comment">//释放一个总车位</span></span><br><span class="line">&#125;</span><br><span class="line">SmallCar() &#123;</span><br><span class="line">P(all); <span class="comment">//占一个总车位</span></span><br><span class="line">小型车进车位</span><br><span class="line">V(all); <span class="comment">//释放一个总车位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设有两个优先级相同的进程 P1 和 P2，共享 x、y、z 三个变量，执行代码见下表。信号量 s1 和s2 的初值均为 0。试问 P1、P2 并发执行后，x、y、z 的值各是多少？给出解题过程。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">进程 P1</th>
<th align="left">进程 P2</th>
</tr>
</thead>
<tbody><tr>
<td align="left">y=1;</td>
<td align="left">x=1;</td>
</tr>
<tr>
<td align="left">y=y+2;</td>
<td align="left">x=x+2;</td>
</tr>
<tr>
<td align="left">V(s1);</td>
<td align="left">P(s1);</td>
</tr>
<tr>
<td align="left">z=y+1;</td>
<td align="left">x=x+y;</td>
</tr>
<tr>
<td align="left">P(s2);</td>
<td align="left">V(s2);</td>
</tr>
<tr>
<td align="left">y=z+y;</td>
<td align="left">z=x+z;</td>
</tr>
</tbody></table>
<blockquote>
<p>答：<br>P1 的 6 条语句，分别用 P1-1 ~ P1-6 表示，P2 的 6 条语句，分别用 P2-1 ~ P2-6 表示。<br>根据信号量的约束，P1-6 一定晚于 P2-5 执行，而 P2-4 一定晚于 P1-3，而其他顺序不受<br>限制。执行顺序不同后导致结果不同的语句有：P1-6, P2-4, P2-6<br>(1) 由于 P2-4 一定晚于 P1-3，但一定早于 P1-6，而 P1-3~P1-6 期间 y=3，所以最终 x=6<br>(2) 如果 P2-6 早于 P1-4 执行，则 P2-6 使 z=6，然后 P1-4 使 z=4，P1-6 使 y=7<br>(3) 如果 P2-6 晚于 P1-4，但早于 P1-6 执行，则 P1-4 使 z=4，P2-6 使 z=10，P1-6 使 y=13<br>(4) 如果 P2-6 晚于 P1-6 执行，则 P1-4 使 z=4，P1-6 使 y=7，P2-6 使 z=10<br>综上所述：<br>如果 P2-6 早于 P1-4 执行，则 x=6, y=7, z=4<br>如果 P2-6 晚于 P1-4，但早于 P1-6 执行，则 x=6, y=13, z=10<br>如果 P2-6 晚于 P1-6 执行，则 x=6, y=7, z=10</p>
</blockquote>
<p>2.理发师问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>;    <span class="comment">//互斥信号量，初值为1.</span></span><br><span class="line">Semaphore  Wait = <span class="number">0</span>;     <span class="comment">//等待服务的顾客数 </span></span><br><span class="line">Semaphore  barbers= <span class="number">0</span>;    <span class="comment">//等待顾客的理发师数</span></span><br><span class="line">Int custNum = <span class="number">0</span>;    <span class="comment">//等待的顾客(还没理发的)  </span></span><br><span class="line"></span><br><span class="line">Costumer()</span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">　　&#123;</span><br><span class="line">        P(mutex);            <span class="comment">//申请理发</span></span><br><span class="line">        <span class="keyword">if</span>(custNum&gt;<span class="number">0</span>)         </span><br><span class="line">　　　　　&#123;</span><br><span class="line">            <span class="keyword">if</span>(custNum&lt;N)   <span class="comment">//若等待人数小于N</span></span><br><span class="line">　　　　　　　&#123;</span><br><span class="line">                V(mutex);     <span class="comment">//释放进程等待</span></span><br><span class="line">                CustNum++；     <span class="comment">//增加等待人数</span></span><br><span class="line">            &#125;</span><br><span class="line">　　　　　　　<span class="keyword">else</span>            <span class="comment">//若等待人数超过N</span></span><br><span class="line">　　　　　　　　&#123;</span><br><span class="line">                V(mutex);   <span class="comment">//释放进程等待</span></span><br><span class="line">                离开；</span><br><span class="line">             &#125;</span><br><span class="line">　　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">else</span>                <span class="comment">//若目前无人等待</span></span><br><span class="line">　　　　&#123;</span><br><span class="line">            V(mutex);        <span class="comment">//释放进程等待</span></span><br><span class="line">            V(barbers)；     <span class="comment">//如果必要的话，唤醒理发师</span></span><br><span class="line">            理发；</span><br><span class="line">            离开；</span><br><span class="line">            P(mutex);        <span class="comment">//要求进程等待</span></span><br><span class="line">            custNum--；        <span class="comment">//顾客人数减1</span></span><br><span class="line">            V(mutex);       <span class="comment">//释放进程等待</span></span><br><span class="line">            V(wait);        <span class="comment">//等待人数减1</span></span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Barber()</span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">　　&#123;</span><br><span class="line">        P(mutex);            <span class="comment">//要求进程等待</span></span><br><span class="line">        <span class="keyword">if</span>(custNum ==<span class="number">0</span>)    <span class="comment">//目前无顾客</span></span><br><span class="line">　　　　 &#123;</span><br><span class="line">            V(mutex);        <span class="comment">//释放进程等待</span></span><br><span class="line">            P(barbers);        <span class="comment">//理发师睡觉</span></span><br><span class="line">　　     &#125;</span><br><span class="line">　　　　<span class="keyword">else</span></span><br><span class="line">　　　　&#123;</span><br><span class="line">            V(mutex);        <span class="comment">//释放进程等待</span></span><br><span class="line">            理发;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、烟—吸烟者问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore S = <span class="number">1</span>;                <span class="comment">//供应者</span></span><br><span class="line">Semaphore S1,S2,S3;                <span class="comment">//三个吸烟者</span></span><br><span class="line">S1 = S2 = S3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> flag1,flag2,fiag3;            <span class="comment">//三种吸烟原料</span></span><br><span class="line">fiag1=flag2=flag3=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">Apply()                            <span class="comment">//供应者</span></span><br><span class="line">&#123;</span><br><span class="line">　　While(<span class="literal">true</span>)</span><br><span class="line">　　&#123;</span><br><span class="line">          P(S);</span><br><span class="line">　　   　　 取两样香烟原料放桌上，由flagi标记；</span><br><span class="line">　　　     <span class="keyword">if</span> (flag2 &amp;&amp; flag3) <span class="comment">//供纸和火柴</span></span><br><span class="line">　　　　　　&#123;</span><br><span class="line">　　　        V(S1);          <span class="comment">//唤醒吸烟者一</span></span><br><span class="line">　　　       &#125;</span><br><span class="line">　　       <span class="keyword">else</span> <span class="keyword">if</span>(flag1 &amp;&amp; fiag3) <span class="comment">//供烟草和火柴</span></span><br><span class="line">　　　　　　&#123;</span><br><span class="line">　　　        V(S2);                <span class="comment">//唤醒吸烟者二</span></span><br><span class="line">　　　       &#125;</span><br><span class="line">　　   　　<span class="keyword">else</span>                      <span class="comment">//供烟草和纸</span></span><br><span class="line">　　　　　　&#123;</span><br><span class="line">　　　        V(S3);                <span class="comment">//唤醒吸烟者三</span></span><br><span class="line">           &#125;</span><br><span class="line">　　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Smoker1()                         <span class="comment">//吸烟者一</span></span><br><span class="line">&#123;</span><br><span class="line">　　　While(<span class="literal">true</span>)</span><br><span class="line">　　 &#123;</span><br><span class="line">　　　    P(S1);</span><br><span class="line">　　　    取原料；</span><br><span class="line">　　　    做香烟；</span><br><span class="line">　　　    V(S);                    <span class="comment">//唤醒供应者</span></span><br><span class="line">　　　    吸香烟；</span><br><span class="line">　　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker2()                        <span class="comment">//吸烟者二</span></span><br><span class="line">&#123;</span><br><span class="line">　　　While(<span class="literal">true</span>)</span><br><span class="line">　　　&#123;</span><br><span class="line">　　　    P(S2);</span><br><span class="line">　　　    取原料；</span><br><span class="line">　　　    做香烟；</span><br><span class="line">　　　    V(S);                    <span class="comment">//唤醒供应者</span></span><br><span class="line">　　　    吸香烟;</span><br><span class="line">　　　&#125;</span><br><span class="line">&#125;　　</span><br><span class="line"></span><br><span class="line">Smoker3()                        <span class="comment">//吸烟者三</span></span><br><span class="line">&#123;</span><br><span class="line">　　　While(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">　　　    P(S3);</span><br><span class="line">　　     取原料；</span><br><span class="line">　　     做香烟；</span><br><span class="line">　　　    V(S);                    <span class="comment">//唤醒供应者</span></span><br><span class="line">　　　   吸香烟;</span><br><span class="line">　　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.面包师问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore buyer= <span class="number">0</span>;                <span class="comment">//顾客人数</span></span><br><span class="line">Semaphore seller = n;            <span class="comment">//销售人员数</span></span><br><span class="line">Semaphore mutex_s = <span class="number">1</span>;            <span class="comment">//用于销售人员的互斥信号量</span></span><br><span class="line">Semaphore mutex_b = <span class="number">1</span>;            <span class="comment">//用于顾客的互斥信号量</span></span><br><span class="line"><span class="keyword">int</span> count_s = <span class="number">0</span>;                <span class="comment">//记录取号的值</span></span><br><span class="line"><span class="keyword">int</span> count_b = <span class="number">0</span>;                <span class="comment">//记录叫号的值 </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Buy</span><span class="params">()</span>                    <span class="comment">//顾客进程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     进店；</span><br><span class="line">    P(mutex_b);          <span class="comment">//取号</span></span><br><span class="line">    count_b++; </span><br><span class="line">　　 V(mutex_b);</span><br><span class="line">　　 V(buyer);</span><br><span class="line"> 　　P(seller);            <span class="comment">//等待叫号</span></span><br><span class="line">    买面包；</span><br><span class="line">    离开             </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         P(buyer);</span><br><span class="line">         P(mutex_s);   <span class="comment">//叫号</span></span><br><span class="line">        </span><br><span class="line">         count_s++;</span><br><span class="line">         </span><br><span class="line">         叫编号为count_s的顾客；</span><br><span class="line">         V(mutex_s);</span><br><span class="line">         V(seller)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.</p>
<blockquote>
<p>桌子上有一只盘子，最多可容纳两个水果，每次只能放入或取出一个水果。爸爸专向盘<br>子放苹果（ apple），妈妈专向盘子中放桔子（ orange）；两个儿子专等吃盘子中的桔子，<br>两个女儿专等吃盘子中的苹果。请用 P、 V 操作来实现爸爸、妈妈、儿子、女儿之间的<br>同步与互斥关系。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>;      <span class="comment">//互斥信号量, 其初值为1</span></span><br><span class="line">Semaphore empty = <span class="number">2</span>;       <span class="comment">//记录允许向盘子中放入水果的个数，初值为2</span></span><br><span class="line">Semaphore orange = <span class="number">0</span>;      <span class="comment">//盘子中已放入的苹果的个数，初值为0</span></span><br><span class="line">Semaphore apple = <span class="number">0</span>;      <span class="comment">//盘子中已放入的桔子的个数，初值为0</span></span><br><span class="line">main()  </span><br><span class="line">&#123;   </span><br><span class="line">Cobegin  </span><br><span class="line">&#123;   </span><br><span class="line">　 father                    <span class="comment">//父亲进程  </span></span><br><span class="line">    &#123;   </span><br><span class="line">　　　　<span class="keyword">while</span> (<span class="literal">true</span>)  </span><br><span class="line">       &#123;   </span><br><span class="line">　　　　　　　　  P(empty);           <span class="comment">//减少盘中可放入的水果数  </span></span><br><span class="line">                P(mutex);           <span class="comment">//申请向盘中取、放水果  </span></span><br><span class="line">                向盘中放苹果;  </span><br><span class="line">                V(mutex);           <span class="comment">//允许向盘中取、放水果  </span></span><br><span class="line">                V(apple);           <span class="comment">//递增盘中的苹果数  </span></span><br><span class="line">        &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">    mother                    <span class="comment">//母亲进程  </span></span><br><span class="line">    &#123;   </span><br><span class="line">　　　　<span class="keyword">while</span> (<span class="literal">true</span>)  </span><br><span class="line">       &#123;   </span><br><span class="line">　　　　　　　　　 P(empty);           <span class="comment">//减少盘中可放入的水果数  </span></span><br><span class="line">                P(mutex);           <span class="comment">//申请向盘中取、放水果  </span></span><br><span class="line">                向盘中放桔子;  </span><br><span class="line">                V(mutex);           <span class="comment">//允许向盘中取、放水果  </span></span><br><span class="line">                V(orange);          <span class="comment">//递增盘中的桔子数  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    daughteri（i=<span class="number">1</span>,<span class="number">2</span>）      <span class="comment">//两女儿进程  </span></span><br><span class="line">    &#123;   </span><br><span class="line">　　　　<span class="keyword">while</span> (<span class="literal">true</span>)  </span><br><span class="line">       &#123;   </span><br><span class="line">　　　　　　      P(apple);           <span class="comment">//减少盘中苹果数  </span></span><br><span class="line">                P(mutex);           <span class="comment">//申请向盘中取、放水果  </span></span><br><span class="line">                取盘中苹果;  </span><br><span class="line">                V(mutex);           <span class="comment">//允许向盘中取、放水果  </span></span><br><span class="line">                V(empty);           <span class="comment">//递增盘中可放入的水果数  </span></span><br><span class="line">        &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">    sonj（j=<span class="number">1</span>,<span class="number">2</span>）           <span class="comment">//两儿子进程  </span></span><br><span class="line">    &#123;   </span><br><span class="line">　　　　<span class="keyword">while</span> (<span class="literal">true</span>)  </span><br><span class="line">       &#123;   </span><br><span class="line">　　　　　　　　  P(orange);          <span class="comment">//减少盘中桔子数  </span></span><br><span class="line">                P(mutex);           <span class="comment">//申请向盘中取、放水果  </span></span><br><span class="line">                取盘中桔子;  </span><br><span class="line">                V(mutex);           ／/允许向盘中取、放水果  </span><br><span class="line">                V(empty);           <span class="comment">//递增盘中可放入的水果数  </span></span><br><span class="line">        &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">    Coend  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.有一个仓库，可以存放 A 和 B 两种产品，仓库的存储空间足够大，但要求：<br>（ 1）一次只能存入一种产品（ A 或 B）；<br>（ 2） -N &lt; (A 产品数量-B 产品数量) &lt; M。<br>其中， N 和 M 是正整数。试用“存放 A”和“存放 B”以及 P、 V 操作描述产品 A 与<br>产品 B 的入库过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>;   <span class="comment">//互斥信号量</span></span><br><span class="line">Semaphore a = M<span class="number">-1</span> ;   <span class="comment">//存放A的资源信号量，初值为M-1</span></span><br><span class="line">Semaphore b = N<span class="number">-1</span>;      <span class="comment">//存放B的资源信号量，初值为N-1</span></span><br><span class="line">存放 A:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">        Get A；</span><br><span class="line">        P(&amp;a); </span><br><span class="line">         P(&amp;mutex); </span><br><span class="line">Put A；  </span><br><span class="line">V(&amp;mutex);  </span><br><span class="line">V(&amp;b);</span><br><span class="line">&#125;  </span><br><span class="line">&#125; </span><br><span class="line">存放B:</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123; </span><br><span class="line">        Get B；</span><br><span class="line">        P(&amp;b);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        Put B；</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        V(&amp;a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>三个进程 P1、 P2、 P3 互斥使用一个包含 N(N&gt;0)个单元的缓冲区。 P1 每次用 produce()<br>生成一个正整数并用 put()送入缓冲区某一空单元中;P2 每次用 getodd()从该缓冲区中<br>取出一个奇数并用 countodd()统计奇数个数;P3 每次用 geteven()从该缓冲区中取出一<br>个偶数并用 counteven()统计偶数个数。请用信号量机制实现这三个进程的同步与互斥活<br>动,并说明所定义信号量的含义。要求用伪代码描述。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1()</span><br><span class="line">&#123;  </span><br><span class="line">　　　While(<span class="literal">true</span>)</span><br><span class="line">　　　&#123;</span><br><span class="line">　　　    X = produce();      <span class="comment">//生成一个数</span></span><br><span class="line">　　　 　 P(empty);     <span class="comment">//是否有空单元格</span></span><br><span class="line">　　　    P(mutex);    <span class="comment">//进入临界区</span></span><br><span class="line">　　　    Put();  </span><br><span class="line">　　　    <span class="keyword">if</span>(X%<span class="number">2</span> == <span class="number">0</span>)  </span><br><span class="line">　　　         V(s2);   <span class="comment">//如果是偶数，向P3发出信号 </span></span><br><span class="line">　　　    <span class="keyword">else</span>  </span><br><span class="line">　　　          V(s1);   <span class="comment">//如果是奇数，向P2发出信号 </span></span><br><span class="line">　　　    V(mutex);         <span class="comment">//离开临界区，释放互斥信号量  </span></span><br><span class="line">　　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()</span><br><span class="line">&#123;  </span><br><span class="line">　　　While(<span class="literal">true</span>)</span><br><span class="line">　　　&#123;</span><br><span class="line">　　　    P(s1);     <span class="comment">//收到P1发送来的信号，已产生奇数</span></span><br><span class="line">　　　 　 P(mutex);         <span class="comment">//进入临界区     </span></span><br><span class="line">　　　    getodd();  </span><br><span class="line">　　　    countodd():=countodd()+<span class="number">1</span>; </span><br><span class="line">　　　    V(mutex);    </span><br><span class="line">　　　    V(empty);         <span class="comment">//离开临界区，释放互斥信号量   </span></span><br><span class="line">　　　&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">P3()</span><br><span class="line">&#123;</span><br><span class="line">　　　While(<span class="literal">true</span>)</span><br><span class="line">　　　&#123;</span><br><span class="line">　　　 　 P(s2)        <span class="comment">//收到P1发送来的信号，已产生偶数   </span></span><br><span class="line">　　　   P(mutex);         <span class="comment">//进入临界区  </span></span><br><span class="line">　　　   geteven();  </span><br><span class="line">　　　   counteven():=counteven()+<span class="number">1</span>;  </span><br><span class="line">　　　   V(mutex);    </span><br><span class="line">　　　   V(empty);         <span class="comment">//离开临界区，释放互斥信号量   </span></span><br><span class="line">　　　&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>8.在天津大学与南开大学之间有一条弯曲的小路，这条路上每次每个方向上只允许一辆自<br>行车通过。但其中有一个小的安全岛 M，同时允许两辆自行车停留，可供两辆自行车已<br>从两端进入小路的情况下错车使用。如图所示。<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/pv.png" alt=""><br>下面的算法可以使来往的自行车均可顺利通过。其中使用了 4 个信号量， T 代表天大路<br>口资源， S 代表南开路口资源， L 代表从天大到安全岛一段路的资源， K 代表从南开到<br>安全岛一段路的资源。程序如下，请在空白位置处填写适当的 PV 操作语句，每处空白<br>可能包含若干个 PV 操作语句。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">    t:=<span class="number">1</span>;s:=<span class="number">1</span>;l:=<span class="number">1</span>;k:=<span class="number">1</span>;</span><br><span class="line">    cobegin</span><br><span class="line">    从天大到南开的进程</span><br><span class="line">        begin</span><br><span class="line">            ______(<span class="number">1</span>)______</span><br><span class="line">           通过 L 路段;</span><br><span class="line">           进入安全岛 M；</span><br><span class="line">           ______(<span class="number">2</span>)______</span><br><span class="line">           通过 K 路段</span><br><span class="line">           ______(<span class="number">3</span>)______</span><br><span class="line">        end</span><br><span class="line">   从南开到天大的进程</span><br><span class="line">       begin</span><br><span class="line">          略，与“从天大到南开的进程”相反。</span><br><span class="line">       end</span><br><span class="line">    coend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>9.有桥如下图所示，车流如箭头所示，桥上不允许两车交汇，但允许同方向多辆车依次<br>通过（即桥上可以有多个同方向的车）。用P、V操作实现交通管理以防止桥上堵塞。<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/pv2.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这题和读者写者问题类似</span></span><br><span class="line">semaphore fmutex=<span class="number">1</span>, normutex=<span class="number">1</span>, sormutex=<span class="number">1</span>,<span class="built_in">queue</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sou_count = <span class="number">0</span>, nor_count = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tonorth</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">while</span>( TRUE )&#123; </span><br><span class="line">P(<span class="built_in">queue</span>)</span><br><span class="line">P(normutex); </span><br><span class="line"><span class="keyword">if</span>( nor_count == <span class="number">0</span> ) &#123; P(fmutex); &#125; </span><br><span class="line">nor_count = nor_count + <span class="number">1</span>; </span><br><span class="line">V(normutex); </span><br><span class="line">V(<span class="built_in">queue</span>); </span><br><span class="line"><span class="comment">//过去了 ... </span></span><br><span class="line">P(normutex); </span><br><span class="line">nor_count = nor_count - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span>( nor_count == <span class="number">0</span> ) &#123; V(fmutex); &#125; </span><br><span class="line">V(normutex); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tosouth</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">while</span>( TRUE )&#123; </span><br><span class="line">P(<span class="built_in">queue</span>); </span><br><span class="line">P(sormutex);</span><br><span class="line"><span class="keyword">if</span>(sor_count==<span class="number">0</span>) &#123;P(fmutex);&#125;</span><br><span class="line">sor_count = sor_count++;</span><br><span class="line">V(sormutex);</span><br><span class="line">V(<span class="built_in">queue</span>);</span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">P(sormutex)</span><br><span class="line">sor_count = sor_count + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(sorcount==<span class="number">0</span>)&#123;V(fmutexl)&#125;</span><br><span class="line">V(sormutex); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>10.用 P、V 操作和信号量实现下图中的前趋关系。其中 S1~S5 是 5 个具有同步关系的<br>进程。<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/pv1.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore s1 =<span class="number">0</span>,s2=<span class="number">0</span>,s3=<span class="number">0</span>,s4=<span class="number">0</span>,s5=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//s1....</span></span><br><span class="line">    V(s1);</span><br><span class="line">    V(s1);</span><br><span class="line">    V(s1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(s1);</span><br><span class="line">    <span class="comment">//s2...</span></span><br><span class="line">    V(s2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(s1);</span><br><span class="line">    <span class="comment">//s3...</span></span><br><span class="line">    V(s3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(s2);</span><br><span class="line">    <span class="comment">//s4....</span></span><br><span class="line">    V(s4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(s1);</span><br><span class="line">    P(s3);</span><br><span class="line">    P(s4);</span><br><span class="line">    <span class="comment">//s5...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="11">
<li>2010 世博会在上海成功举行，很多场馆都给人留下了深刻的印象。中国馆有很多<br>观众参观。为保持场内卫生，需要不定期的清馆打扫卫生。为保证秩序，相关部门做出了以下的管理规定：<br>1) 同时进入场馆的人数上限为 N；如果场内观众人数达到上限，新观众在场外排队等候。<br>2) 为保证打扫卫生工作的正常开始，保洁人员首先会暂停新观众进场，新观众在场外排队等候；<br>3) 如果场内无观众，则打扫卫生立即开始，如还有剩余观众，则待场内观众全部离开后，即开始打扫卫生；<br>4) 完成后重新开放。</li>
</ol>
<p>为实现上述控制，请用 PV 原语和信号量，分别描述观众和保洁人员的行为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>(人数加减的锁),r=N,w=<span class="number">1</span>,s=<span class="number">1</span>; (w是保持场馆状态)</span><br><span class="line"><span class="keyword">int</span> rc=<span class="number">0</span>;</span><br><span class="line">reader()</span><br><span class="line">&#123;</span><br><span class="line">P(s);<span class="comment">//给别人(特别是writer)看</span></span><br><span class="line">P(mutex);</span><br><span class="line">rc++;</span><br><span class="line"><span class="keyword">if</span> (rc==<span class="number">1</span>) P(w);</span><br><span class="line">P(r);</span><br><span class="line">V(mutex);</span><br><span class="line">V(s);</span><br><span class="line">读文件;</span><br><span class="line">P(mutex);</span><br><span class="line">rc--;</span><br><span class="line"><span class="keyword">if</span> (rc==<span class="number">0</span>) V(w);</span><br><span class="line">V(r);</span><br><span class="line">V(mutex);</span><br><span class="line">&#125;</span><br><span class="line">writer()<span class="comment">//w给别人看</span></span><br><span class="line">&#123;</span><br><span class="line">P(s);</span><br><span class="line">P(w);</span><br><span class="line">写文件;</span><br><span class="line">V(w);</span><br><span class="line">V(s);</span><br><span class="line">&#125;</span><br><span class="line">只有reader 会拿着 w</span><br><span class="line">只有写者 会拿着 s</span><br><span class="line">s 保证了门口只能站着一个人在等着进去</span><br></pre></td></tr></table></figure>
<ol start="12">
<li>某火车订票系统，可共多个用户同时共享一个订票数据库。规定允许多个用户同时查询该数据库，有查询者时，用户不能订票；有用户订票而需要更新数据库时，不可以有其他用户使用数据库。当有用户申请订票时，后续的查询者的请求会被暂时挂起直到订票操作完成。请在下面程序的空格处填入 P、 V 操作写出查询者和订票者的同步执行程序，一个空格处可能会有一条或多条 P、V 操作<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">答：程序中没有出现对信号量直接读写的语句，且 P、V 操作中没有出现非信号</span><br><span class="line">量作为参数。（<span class="number">1</span> 分）（程序中的给分项必须 P、V 操作成对完整且位置正确方可</span><br><span class="line">得分，分值标在相应的 P 操作上）</span><br><span class="line">semaphore mutex=<span class="number">1</span>（<span class="number">1</span> 分）,db=<span class="number">1</span>（<span class="number">1</span> 分）,w=<span class="number">1</span>（<span class="number">1</span> 分）; <span class="comment">//此处为信号量初始</span></span><br><span class="line">化</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>; <span class="comment">//共享变量，查询用户的个数</span></span><br><span class="line">query() <span class="comment">//查询过程</span></span><br><span class="line">&#123;</span><br><span class="line">P(mutex) （<span class="number">1</span> 分）;P(w) （<span class="number">1</span> 分）;</span><br><span class="line">count=count+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (count==<span class="number">1</span>) &#123; <span class="comment">//是第一个查询者</span></span><br><span class="line">P(db) （<span class="number">1</span> 分）; &#125;</span><br><span class="line">V(w);V(mutex);</span><br><span class="line">查询余票; P(mutex) （<span class="number">1</span> 分）;</span><br><span class="line">count=count<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (count==<span class="number">0</span>)&#123; <span class="comment">//是最后一个查询者</span></span><br><span class="line">V(db);</span><br><span class="line">&#125;</span><br><span class="line">V(mutex);</span><br><span class="line">&#125;</span><br><span class="line">book() <span class="comment">//订票过程</span></span><br><span class="line">&#123;</span><br><span class="line">P(w) （<span class="number">1</span> 分）;P(db) （<span class="number">1</span> 分）;</span><br><span class="line">订票;</span><br><span class="line">V(db);V(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>(1)读者优先(考试重点)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore fmutex=<span class="number">1</span> <span class="comment">//fmutex --&gt; access to file; </span></span><br><span class="line">sepaphore rdcntmutex=<span class="number">1</span>; <span class="comment">// rdcntmutex --&gt; access to reader_count </span></span><br><span class="line"><span class="keyword">int</span> reader_count = <span class="number">0</span>; <span class="comment">// reader_count --&gt; the number of readers </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">while</span> ( TRUE )&#123; </span><br><span class="line">P(rdcntmutex); </span><br><span class="line"><span class="keyword">if</span>( reader_count == <span class="number">0</span> ) &#123; P(fmutex); &#125; </span><br><span class="line">reader_count = reader_count + <span class="number">1</span>; </span><br><span class="line">V(rdcntmutex); </span><br><span class="line"><span class="comment">//Do read operation ... </span></span><br><span class="line">P(rdcntmutex); </span><br><span class="line">reader_count = reader_count - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span>( reader_count == <span class="number">0</span>) &#123; V(fmutex); &#125; </span><br><span class="line">V(rdcntmutex); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">while</span> ( TRUE )&#123; </span><br><span class="line">P(fmutex); </span><br><span class="line"><span class="comment">//Do write operation ... </span></span><br><span class="line">V(fmutex); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)写者优先</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore fmutex=<span class="number">1</span>, rdcntmutex=<span class="number">1</span>, wtcntmutex=<span class="number">1</span>, <span class="built_in">queue</span>=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">int</span> reader_count = <span class="number">0</span>, writer_count = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">while</span>( TRUE )&#123; </span><br><span class="line">P(<span class="built_in">queue</span>); </span><br><span class="line">P(rdcntmutex); </span><br><span class="line"><span class="keyword">if</span>( reader_count == <span class="number">0</span> ) &#123; P(fmutex); &#125; </span><br><span class="line">reader_count = reader_count + <span class="number">1</span>; </span><br><span class="line">V(rdcntmutex); </span><br><span class="line">V(<span class="built_in">queue</span>); </span><br><span class="line"><span class="comment">//Do read operation ... </span></span><br><span class="line">P(rdcntmutex); </span><br><span class="line">reader_count = reader_count - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span>( reader_count == <span class="number">0</span> ) &#123; V(fmutex); &#125; </span><br><span class="line">V(rdcntmutex); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">while</span>( TRUE )&#123; </span><br><span class="line">P(wtcntmutex); </span><br><span class="line"><span class="keyword">if</span>( writer_count == <span class="number">0</span> ) &#123; P(<span class="built_in">queue</span>); &#125; </span><br><span class="line">writer_count = writer_count + <span class="number">1</span>; </span><br><span class="line">V(wtcntmutex); </span><br><span class="line">P(fmutex); </span><br><span class="line"><span class="comment">//Do write operation ... </span></span><br><span class="line">V(fmutex); </span><br><span class="line">P(wtcntmutex); </span><br><span class="line">writer_count = writer_count - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span>( writer_count == <span class="number">0</span> ) &#123; V(<span class="built_in">queue</span>); &#125; </span><br><span class="line">V(wtcntmutex); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)公平竞争</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore fmutex=<span class="number">1</span>, rdcntmutex=<span class="number">1</span>, wtcntmutex=<span class="number">1</span>, <span class="built_in">queue</span>=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">int</span> reader_count = <span class="number">0</span>, writer_count = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">while</span>( TRUE )&#123; </span><br><span class="line">P(<span class="built_in">queue</span>); </span><br><span class="line">P(rdcntmutex); </span><br><span class="line"><span class="keyword">if</span>( reader_count == <span class="number">0</span> ) &#123; P(fmutex); &#125; </span><br><span class="line">reader_count = reader_count + <span class="number">1</span>; </span><br><span class="line">V(rdcntmutex); </span><br><span class="line">V(<span class="built_in">queue</span>); </span><br><span class="line"><span class="comment">//Do read operation ... </span></span><br><span class="line">P(rdcntmutex); </span><br><span class="line">reader_count = reader_count - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span>( reader_count == <span class="number">0</span> ) &#123; V(fmutex); &#125; </span><br><span class="line">V(rdcntmutex); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">while</span>( TRUE )&#123; </span><br><span class="line">P(<span class="built_in">queue</span>); </span><br><span class="line">P(fmutex); </span><br><span class="line">V(<span class="built_in">queue</span>); </span><br><span class="line"><span class="comment">//Do write operation ... </span></span><br><span class="line">V(fmutex); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解答题-2"><a href="#解答题-2" class="headerlink" title="解答题"></a>解答题</h4><ol>
<li><p>当操作系统发现死锁已经发生时，通常采用哪些方法来解决这个问题？哪种方法的代价相对比较小？</p>
<blockquote>
<p>答：可以重启操作系统、或结束死锁状态的一个或多个进程。回答剥夺死锁进程的部分资源也可以给分。<br>选择结束死锁状态中最年轻的进程的生命，代价较小，因为重新运行到这个状态相对比较容易。 </p>
</blockquote>
</li>
<li><p>请讨论一下使用 TSL 语句实现加锁的方法和原理。如果在不支持 TSL 的 x86 系列 CPU 上，如何使<br>用 XCHG 语句来代替 TSL 语句实现同样的功能？</p>
<blockquote>
<p>答：设置一个变量 LOCK，约定其值为 0 代表资源空闲，为 1 代表资源占用。(1 分)<br>进入临界区前执行下面的判断<br>(1) TSL 指令将变量 LOCK 的值存入寄存器 REGISTER 中，并将 LOCK 的值设置为 1。由于这是在一条指<br>令中完成，这两件事是原子性的，即“同时、不可被打断”。<br>(2) 判断寄存器 REGISTER 的值是 1 吗？是，重新执行第（1）步。<br>离开临界区前，将变量 LOCK 的值设为 0。（2 分）<br>如果使用 XCHG 替代 TSL 语句，可以改为：<br>进入临界区前执行下面的判断<br>(1) 将寄存器 REGISTER 的值设置为 1。<br>(3) 使用 XCHG 交换变量 LOCK 的值和寄存器 REGISTER 的值。由于这是在一条指令中完成，这个交换<br>是原子性的，即“同时、不可被打断”。<br>(4) 判断寄存器 REGISTER 的值是 1 吗？是，重新执行第（1）步。<br>离开临界区前，将变量 LOCK 的值设为 0。（2 分）</p>
</blockquote>
</li>
</ol>
<p>代码:?</p>
<ol start="3">
<li><p>根据你了解的 Linux 对于进程的管理机制，回答下面的问题：<br>（1）Linux 中各个进程是彼此平等的，还是存在父子族亲关系？<br>（2）内核创建的第一个进程叫什么名字？<br>（3）如果一个进程即将结束，而它尚有活动的子进程，该进程会正常结束，从而形成孤儿进程吗？<br>（4）使用什么命令，可以起动一个进程，在其父 shell 退出后，可以继续在后台运行？</p>
<blockquote>
<p>答：(1) 存在父子族亲关系（1 分）<br>(2) 第一个进程叫 init（1 分）<br>(3) 不会形成孤儿进程。（1 分）一般情况下有两种处理方法，一是先将它的子进程杀死后再结束自己，另一种是将子进程的父进程变更为 init 后再结束自己。（1 分）<br>(4) 使用 nohup 语句（1 分）</p>
</blockquote>
</li>
<li><p>操作系统通过系统调用向用户程序提供服务,讨论一下问题<br>1)以fork()为例,说明用户程序如何调用系统调用.<br>2)以xv6系统为例,说明设计并实现一个系统调用需要哪些步骤.</p>
<blockquote>
<p>答:1)用户调用fork(),如果进程分裂成功,当前进程为父进程,fork()的返回值为子进程的PID,子进程中fork()的返回值为0.如果分裂失败,返回值为-1.<br>2)要点,需要修改一下文件:</p>
</blockquote>
</li>
</ol>
<ul>
<li>syscall.h 增加系统调用编号</li>
<li>syscall.c 增加系统调用声明</li>
<li>sysproc.c 实现系统调用</li>
<li>user.h 增加系统调用的声明</li>
<li>usys.S 增加系统调用相关的宏</li>
</ul>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><h5 id="选择题-2"><a href="#选择题-2" class="headerlink" title="选择题"></a>选择题</h5><ol>
<li><p>下列措施中，能加快虚实地址转换的是：C<br>I. 增大快表（TLB）    II. 让页表常驻内存    III. 增加交换区<br>A.  仅 I    B. 仅 II    C. 仅 I,II    D. 仅 II,III</p>
</li>
<li><p>下列选项中，属于多级页表优点的是：D<br>A.加快地址变换速度            B.减少缺页中断次数<br>C. 减少一个页表项所占字节数     D.减少页表所占的内存空间</p>
</li>
<li><p>若用户进程访问内存时产生缺页，则下列选项中，操作系统可能执行的操作是 B<br>I.处理越界错    II.置换页    III.分配内存<br>A.仅I、II    B.仅II、III    C. 仅I、III    D. I、II和III</p>
<blockquote>
<p>增大TLB，是为了避免去内存中匹配页表。TLB本身就在***里，而且能并行计算。把页表都放在内存里，也是可以的，但一般页表很大，可以经过多级页表和反置页表处理后再放在内存里。交换区是内存不够用时的解决手段，增大交换区能腾出更多地方。</p>
</blockquote>
</li>
<li><p>在⼀个请求分页系统中，采⽤ LRU 页⾯转换算法时，加⼊⼀个作业的页⾯⾛向为：<br>1，3，2，1，1，3，5，1，3，2，1，5.当分配给该作业的物理块数分别为 3 和 4 时，在访问过程中所发⽣的缺页率为  C<br>A. 25%，33%    B. 50%，25%    C.50%,33%    D. 50%，75%</p>
<blockquote>
<p>M=3<br>1 3 2<br>请求5 缺页 1 3 5<br>请求2 缺页 1 3 2<br>请求5 缺页 1 5 2<br>6/12 = 25%<br>M=4<br>1 3 2 5<br>4 / 12 = 33%</p>
</blockquote>
</li>
<li><p>某作业的逻辑地址空间为4页，页⾯⼤⼩为2048，已知页表如下所⽰，则逻辑地址<br>4865（⼗进制）对应的物理地址为（<strong>C</strong>）。<br>页号    0    1    2    3<br>块号    2    4    6    8<br>A、4865    B、8961    C、13057    D、6865</p>
<blockquote>
<p>4865 = 1301H = ‭0001001100000001‬<br>2对应6<br>11001100000001‬ = 13057<br>ok</p>
</blockquote>
</li>
<li><p>若⽤户进程访问内存时产⽣缺页，则下列选项中，操作系统可能执⾏的操作是 B<br>I.处理越界错    II.置换页    III.分配内存<br>A.仅I、II    B.仅II、III    C.  仅I、III    D. I、II和III</p>
<blockquote>
<p>用户进程访问内存时缺页会发生缺页中断。发生缺页中断，系统会执行的操作可能是置换页面或分配内存。系统内没有越界的错误，不会进行越界出错处理</p>
</blockquote>
</li>
<li><p>考虑页⾯置换算法，系统有 m 个物理块供调度，初始时全空，页⾯引⽤串长度为p，包含了 n 个不同的页号，⽆论⽤什么算法，缺页次数不会少于（<strong>C</strong>）<br>A、m<br>B.p<br>C. n<br>D. min(m,n)</p>
<blockquote>
<p>无论采用什么置换算法,每种页面第一次访问时不可能在内存中.必然发生缺页.</p>
</blockquote>
</li>
<li><p>把进程地址空间中使⽤的逻辑地址变成内存中物理地址的过程称为：<strong>A</strong><br>A、重定位    B、物理化    C、逻辑化    D、加载</p>
<blockquote>
<p>由程序中逻辑地址组成的地址范围叫做逻辑地址空间，或简称为地址空间。而由内存中的一系列存储单元所限定的地址范围称为内存空间，也称为物理空间或者绝对空间。<br>程序和数据装入内存时需对目标程序中的地址进行修改。这种把逻辑地址转变为内存的物理地址的过程叫重定位。<br>对程序进行重定位的技术按重定位的时机可分为两种：静态重定位和动态重定位。</p>
</blockquote>
</li>
</ol>
<h5 id="计算题-2"><a href="#计算题-2" class="headerlink" title="计算题"></a>计算题</h5><ol>
<li>某操作系统的内存管理器采用请求式分页，页面大小为 4KB，某计算机主存按字节编址，逻辑地<br>址和物理地址都是 32 位，页表项大小为 4 字节。若使用二级页表的分页存储管理方式，逻辑地<br>址结构为</li>
</ol>
<table>
<thead>
<tr>
<th align="center">页目录号(10位)</th>
<th align="center">页表索引(10位)</th>
<th align="center">页内偏移量(12位)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TLB（快表）采用全相联映射，有 4 个页表项，内容如下表所示。</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">有效位</td>
<td align="center">页号</td>
<td align="center">页框号</td>
</tr>
<tr>
<td align="center">:-</td>
<td align="center">:-</td>
<td align="center">:-</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">FF180H</td>
<td align="center">——</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3FFF1H</td>
<td align="center">0F035H</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">FFFC6H</td>
<td align="center">3054CH</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">03FFFH</td>
<td align="center">0C153H</td>
</tr>
<tr>
<td align="center">(1) 该系统的页表项中,最多可以保存多少位标志位.</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">(2) 若该进程共用到了3072个页,则此时此二级页表占用的总空间最小为多少.</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">(3) 对逻辑地址3FFF1880H转换为物理地址的结果是什么.</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>解：(1) 页面大小为 4KB =&gt; 页内偏移量 12 位<br>物理地址 32 位 =&gt; 页框号 20 位<br>页表项大小为 4 字节（即，32 位）=&gt; 标志位最多 = 页表项长度 32 – 页框号 20 = 12 位（2 分）<br>(2) 一个页表索引 10 位 =&gt; 一个小页表有 2^10=1024 个页表项<br>逻辑地址空间 3072 个页 =&gt; 需要 3072/1024=3 个小页表，加上一个页目录表，共 4 个页表 =&gt; 页<br>表最小 4*4KB=16KB（2 分）<br>(3) 页内偏移量 12 位 =&gt; 逻辑地址 3FFF1880H 的页号是 3FFF1H，查快表可知，对应页框号为<br>0F035H =&gt; 物理地址是 0F035880H（2 分）</p>
</blockquote>
<ol start="2">
<li>某操作系统的内存管理器采⽤请求式分页，页⾯⼤⼩为 4KB，逻辑地址空间为 32 位， 物理地址空间为 36 位，⼀个页表项⼤⼩为 4B。⼀次快表（TLB）的访问时间是 10ns，⼀次内存的访问时间是 100ns，处理⼀次缺页的平均时间 10^8 ns（已含更新 TLB 和页表的时间）。进程的驻留集⼤⼩固定为 2,采⽤最近未使⽤置换算法(NRU)和局部淘汰策略。假设（1） TLB 初始为空;（2）地址转换时先访问 TLB,若 TLB 未命中,再访问页表(忽略访问页表之后的 TLB  更新时间);（3）有效位为  0  表⽰页⾯不在内存,产⽣缺页中断,缺页中断处理后,返回到产⽣缺页中断的指令处重新执⾏。进程的部分页表如下所⽰：</li>
</ol>
<table>
<thead>
<tr>
<th align="left">页号</th>
<th align="left">页框(Page Frame)号</th>
<th align="left">P存在位</th>
<th align="left">R访问位</th>
<th align="left">M修改位</th>
</tr>
</thead>
<tbody><tr>
<td align="left">00000H</td>
<td align="left">——</td>
<td align="left">0</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">00001H</td>
<td align="left">007F61H</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">00002H</td>
<td align="left">101254H</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">00003H</td>
<td align="left">——</td>
<td align="left">0</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
</tbody></table>
<p>(1)该系统的页表项中，最多可以保存 <strong>B</strong>位标志位。<br>A．4    B．8    C．12    D．16</p>
<blockquote>
<p>页表项32位, (36-12)算出页框号<br>所以32 - (36- 12) = 8<br>41、若采⽤多级页表，要求每级页表均可以装⼊⼀个页⾯内，则应该采⽤  <strong>C</strong>级页表较合适。<br>A．0    B．1    C．2    D．3<br>ok</p>
</blockquote>
<p>(2)如果不考虑缺页的情况，对于已经载⼊内存的页⾯，快表命中率为90%，则访问内存中数据的平均有效访问时间是  <strong>A</strong>。<br>A．20ns    B．110ns    C．120ns    D．320ns</p>
<blockquote>
<p>10<em>0.9+110</em>0.1=20ns +不+100呢?</p>
</blockquote>
<p>(3)⾸先，访问逻辑地址00001618H，则读⼊所需数据需要的总时间是 <strong>D</strong>。<br>A．约 10^8ns    B．110ns    C．200ns    D．210ns</p>
<blockquote>
<p>内存是P位<br>10 + 100 +100</p>
</blockquote>
<p>(4)然后，访问逻辑地址00000FA6H，则读⼊所需数据需要的总时间是 <strong>A</strong>    。<br>A．约 10^8ns    B．110ns    C．200ns    D．210ns</p>
<blockquote>
<p>缺页中断了.</p>
</blockquote>
<p>(5)最后，访问逻辑地址0000126CH，则读⼊所需数据需要的总时间是 <strong>B</strong>    。<br>A．约 10^8ns    B．110ns    C．200ns    D．210ns</p>
<blockquote>
<p>页表1 在快表中了</p>
</blockquote>
<p>(6)在依次访问完上述三个逻辑地址后，页框101254H对应的页号为 <strong>A</strong>。<br>A．00000H    B．00001H    C．00002H    D．00003H</p>
<blockquote>
<p>(这题我也没太理解)是不是访问00000FA6H时候缺页中断 置换了页表2</p>
</blockquote>
<ol start="3">
<li><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%861.png" alt=""></p>
<blockquote>
<p>答案:(1) 4KB (2) 4MB (3) (LA&gt;&gt;22)&amp;0x000003FF (4) (LA&gt;&gt;12)&amp;0x000003FF (5)  4×4K<br>(6) 00200020H (7) 00200040H (8) 00900H (9) 00901H (10)00901000H</p>
</blockquote>
</li>
<li><p>已知某系统页⾯长 4KB，页表项 4B，虚拟地址空间为 64 位。<br>（1）如采⽤多层分页策略，限定各分层页表最多占 1 页⼤⼩，请问可以采⽤⼏层分页<br>策略？<br>（2）如采⽤倒排页表⽅式，请问倒排页表的⼤⼩？是每个进程⼀张倒排页表还是系统<br>维护⼀张倒排页表？如何解决倒排页表不便于逻辑地址向物理地址转换的问题？</p>
<blockquote>
<p>(1)页面长 4KB，说明页内偏移地址占 12 位，虚拟地址空间 64 位，说明页号总长<br>为 64-12=52 位。页面长 4KB，页表项 4B，故每张页表不超过<br>4K/4=1K=2^10    项，即每级 页表地址长度不应该超过 10 位。页号总长 52 位/<br>每页表最长 10 位=5.2，向上取整为 6。 即采用六层分页策略。<br>(2)如采用倒排页表，因为物理地址空间 4GB，故倒排页表应该有 4GB/4KB=1M个页 表项，每页表项大小为 4B，倒排页表大小为 1M*4B=4MB。系统维护一张倒排页表。可以使用 Hash 散列，解决倒排页表不便于逻辑地址向物理地址转换的问题。</p>
</blockquote>
</li>
</ol>
<h5 id="解答题-3"><a href="#解答题-3" class="headerlink" title="解答题"></a>解答题</h5><ol>
<li>缺页中断产生后，被中断的进程应该转入什么运行状态？讨论一下缺页中断的执行过程，并说明<br>中断处理完毕后返回被中断的进程时应该执行哪条语句。<blockquote>
<p>（1）转入阻塞态（或者说 blocked 态、睡眠态、sleep 态都可以）(1 分)<br>（2）保护现场、陷入内核态、如果内存空间不足则选择页面淘汰(1 分)；调需要的页面进内存、更新页表和快表(1 分)；返回用户态，恢复现场、重新执行 被中断的语句(1 分)。<br>（3）执行被中断的语句(1 分)</p>
</blockquote>
</li>
<li>某系统的页面淘汰算法采用老化(Aging)算法，每个页面分配一个 8 位二进制数的计数器。某进程共有 6 个页面，在时刻 0 之前所有页面均未被引用过。下表是前 5 个 clock tick 中各页面的被引用情况，被引用者标 1，未被引用者标 0。</li>
</ol>
<table>
<thead>
<tr>
<th align="center">Clock tick</th>
<th align="center">Page 0</th>
<th align="center">Page 1</th>
<th align="center">Page 2</th>
<th align="center">Page 3</th>
<th align="center">Page 4</th>
<th align="center">Page 5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1） 在 clock tick 4 过后，需要淘汰一个页面，应选择哪个页面进行淘汰？为什么？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2） 为什么说老化(Aging)算法是一种简单有效的算法，但只是 LRU 的一个近似实现？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>1)应淘汰 Page 3，因为其访问计数器为 00100，为最小值<br>2)老化算法只有有限位的存储，记录最近若干次页面使用情况，更早的使用情况会丢失。另外，老<br>化算法没有记录在一个时间周期内页面的使用频度和时间等，所以与 LRU 相比只是一个近似实现。</p>
</blockquote>
<ol start="3">
<li><p>在虚拟存储管理中，分段式内存管理⽅式解决了分页式内存管理中的什么问题，又带来了什么问题呢？</p>
<blockquote>
<p>解决了分页式机械化的分页(功能可能不同)导致颠簸现象?<br>分段式由内在逻辑来分, 不过段大 类似于动态分区会产生外碎片 导致内存利用率低<br>标答:分段式内存管理解决了分页式内存管理中划分页时仅根据大小划分，这样<br>可能将无关的 内容分到一页中，此页不便设置权限与保护，也不利于共享。<br>也有可能把密切相关的内容分 到不同页中，当页面置换算法设置不当时，内<br>存紧张时容易形成“抖动”现象。 分段式内存管理带来的问题是段往往过大，多<br>次分配释放后可能形成大量“外碎片”，利 用内存效率不高。</p>
</blockquote>
</li>
<li><p>LRU页⾯置换算法是⼀种⽐较优秀的算法但是较难实现，为什么？试给出⼀种可⾏<br>的近似算法作为LRU的取代⽅案。</p>
<blockquote>
<p>LRU需求记录所有页面长期运行中被使用的时间和次数，需要大量的快速存<br>储空间，而且比较 pthreadkill()：向线程发送一个信号 算法非常复杂，不容易<br>实现。 <code>z</code>同步函数，用于 mutex    和条件变量替代方案可以采用老化（aging）<br>算法，每个页面有一个长度有限的记数器，记录每个 tick    内pthreadmutexinit()    初始化互斥锁 面使用情况，记录信息的权重逐次递减。这种算法与 LRU    相比，不能记录每个 tick    中内存使用情况，pthreadmutex_destroy()    删除互斥锁 而且记录的位数有限，但是实现方案较易<br>实现。</p>
</blockquote>
</li>
<li><p>单纯的分段式和分页式内存管理各有什么缺点？为什么段页式可以避免这些缺点？<br>为什么段页式内存管理没有被⼴泛采⽤呢？</p>
<blockquote>
<p>分页式：逻辑地址空间划分只简单依靠页面大小，缺乏内在逻辑性，导致一方<br>面相关内容被分散 到多页上，页面置换不当时容易造成内存抖动，另一方面<br>不同性质的内容被分到同一页中，使得页面 权限保护设置困难。 分段式：段<br>体积大，在内存中无法不连续存储，易形成内存外碎片，降低内存利用率。<br>段页式：先分段再分页，以段为单位调入调出，以页为单位在内存中不连续存<br>储，既保证了相关内容 同时进出内存，便于设置权限保护，又可以充分利用<br>内存空间。 段页式结构复杂，实现起来效率低，所以没有被广泛采用。</p>
</blockquote>
</li>
<li><p>为什么内存管理⽅式中，可变分区管理中有最差适应（worst fit)分配算法，⽽固定<br>分区管理中没有这个算法？分区管理中的交换技术（swap）和段式管理中的请求式<br>分段技术有什么区别？请求式分段与覆盖技术（overlay）又有什么区别？</p>
<blockquote>
<p>最差适应分配最大空间的分区给进程使用,以期剩余外碎片空间较大,再次利用的可能性较大.固定分区无外碎片,故不应采用这种算法.<br>交换技术交换单位是进程,请求式分段技术交换的单位是段<br>请求式分段式操作系统进行段调入调出,对程序员透明,而覆盖技术需要程序员自己完成调入调出.</p>
</blockquote>
</li>
<li><p>页⾯置换（淘汰）的时机是什么？哪种算法最理想同时也不可能实现？为什么说<br>LRU算法很有效但是很难实现？什么是Belady异常？哪种算法存在Belady异常现<br>象?</p>
<blockquote>
<p>页面置换应该在内存空余空间小于一个固定的下限阈值时开始，并在达到<br>另一个上限阈值时停止。 OPT 最理想但不可能实现。 LRU 要求比较最近最少<br>使用的页面，条件多，要存储的数据量大，比较的时间长，很难实现。<br>Belady 异常指的时当增加页框时缺页中断发生的数量反而升高的现象。 FIFO<br>存在 Belady 异常</p>
</blockquote>
</li>
<li><p>请讨论⼀下页⾯置换算法中⼯作集（Working Set）置换算法的⼯作原理。</p>
<blockquote>
<p>答：进程设置一个虚拟时钟，执行一个时钟周期就加 1，不执行就不增加。<br>（1    分）每个页面被访问时，记录最后访问的虚拟时间，R    位置 1。R    位定期<br>清除。（1 分）如果 R=1,则保留，将当前时间记录下来。（1    分）如果 R=0    对<br>比当前虚拟时间与页面最后访问时间差 age    与阈值 τ，如 age&gt;τ 则淘汰（1<br>分）。如 age    &lt;=    τ，则记录其访问时间，必要时淘汰其中最旧的。（1    分）</p>
</blockquote>
</li>
<li><p>在内存管理的⽅法中，分段式管理⽐分页式管理有什么优势？段页式与其他⽅式相<br>⽐有什么好处？</p>
<blockquote>
<p>分段比分页更有逻辑性，将同类的或相关的内容放在一个段内，这样不会<br>由于页面置换算法选择不当而形成“抖动”现象。（1    分）同类内容划分在一个<br>段内，可以实现段的保护，如代码段设置为只读，数据段设置为读写。（1     分）<br>公共代码段可以通过映射共享到多个进程。（1    分）段页式既按照相关性划分<br>段，继承了分段的优势（1    分），又有分页管理可以不连续存储，能够充分利<br>用空间的好处。（1    分）</p>
</blockquote>
</li>
<li><p>为什么要使⽤倒排页表？倒排页表⾯临的最⼤的问题是什么？如何解决？</p>
<blockquote>
<p>在 64    位系统中，由于虚拟地址太大，普通页表会非常大，无法存储。另一方<br>面，实际内存 相对较小，所以建立一张从物理地址索引得到相对地址的倒排<br>页表。 最大的问题的难于从相对地址查找到绝对地址。可以采用 hash    表ò高<br>查找效率，并使用 TLB加速查找。</p>
</blockquote>
</li>
<li><p>内存分区管理中的交换技术与请求式分段技术相⽐，有什么相同点和不同点？</p>
<blockquote>
<p>答：相同点都是为了在内存不足的情况下装入更多的进程，都是会产生外碎片。<br>不同点为交换 技术交换的对象是整个进程而请求式分段交换的进程中的一个<br>段。</p>
</blockquote>
</li>
<li><p>在页⾯淘汰算法中，为什么说⽼化(Aging)算法只是 LRU 的⼀个近似实现？</p>
<blockquote>
<p>老化算法与 LRU    相比，主要有两点区别：<br>(1）老化算法记录使用情况的<br>寄存器只有有限位， 比如 8位，无法记录所有使用情况。<br>（2）同一时间间隔内只使用 0/1区分页面使用情况，无法详 细区别间隔内的具体时间</p>
</blockquote>
</li>
<li><p>单纯的分段式和分页式内存管理各有什么缺点？为什么段页式可以避免这些缺点？为什么段页式内存管理没有被广泛采用呢？</p>
<blockquote>
<p>答：分页式：逻辑地址空间划分只简单依靠页面大小，缺乏内在逻辑性，导致一方面相关内容被分散到多页上，页面置换不当时容易造成内存抖动，另一方面不同性质的内容被分到同一页中，使得页面权限保护设置困难。<br>分段式：段体积较大，在内存中无法不连续存储，易形成内存外碎片，降低内存利用率。<br>段页式：先分段再分页，以段为单位调入调出，以页为单位在内存中不连续存储，既保证了相关内容同时进出内存，便于设置权限保护，又可以充分利用内存空间。<br>段页式结构复杂，实现起来效率低，所以没有被广泛采用。</p>
</blockquote>
</li>
<li><p>为什么内存管理方式中，可变分区管理中有最差适应（worst fit)分配算法，而固定分区管理中没有这个算法？分区管理中的交换技术（swap）和段式管理中的请求式分段技术有什么区别？请求式分段与覆盖技术（overlay）又有什么区别？</p>
<blockquote>
<p>答：最差适应分配最大空间的分区给进程使用，以期剩余外碎片空间较大，再次利用的可能性较大。<br>固定分区无外碎片，故不应采用这种算法。<br>交换技术交换的单位是进程，请求式分段技术交换的单位是段。<br>请求式分段是操作系统进行段调入调出，对程序员透明，而覆盖技术需要程序员自己完成调入调出。</p>
</blockquote>
</li>
<li><p>页面置换（淘汰）的时机是什么？哪种算法最理想同时也不可能实现？为什么说LRU算法很有效但是很难实现？什么是Belady异常？哪种算法存在Belady异常现象？</p>
<blockquote>
<p>答：页面置换应该在内存空余空间小于一个固定的下限阈值时开始，并在达到另一个上限阈值时停止。<br>OPT最理想但不可能实现。<br>LRU要求比较最近最少使用的页面，条件多，要存储的数据量大，比较的时间长，很难实现。<br>Belady异常指的时当增加页框时缺页中断发生的数量反而升高的现象。<br>FIFO存在Belady异常。</p>
</blockquote>
</li>
<li><p>请问缓存（Cache）有什么用，什么地方会用到它？</p>
<blockquote>
<p>答：缓存主要用于解决 CPU 和内存之间存在的速度差。一般来说，CPU 中寄存器的速<br>度要远快于内存，将 CPU 要用到的数据预先从内存中读到缓存，这样 CPU 使用时就可<br>以快速得到数据，写回内存的过程也类似。<br>TLB 就是使用缓存的一个典型例子。</p>
</blockquote>
</li>
<li><p>内存管理中，什么是内存的外碎片？哪些种内存管理方式可能出现外碎片？为什么？为了避免出现大量很小的外碎片，在空间申请时可以考虑采用哪种分配策略？</p>
<blockquote>
<p>答：外碎片指的是内存中的小的空闲区域，虽然存在理论上被分配出去的可能性，但是<br>实际上由于空间很小，很难被利用。<br>可变式分区管理、分段式管理等内存管理方式均可能出现外碎片。<br>为了避免出现大量小的外碎片，可以使用最差适应（Worst Fit）分配策略。</p>
</blockquote>
</li>
<li><p>已知某系统页面长 4KB，页表项 4B，虚拟地址空间为 64 位，物理地址空间 4GB。 （1）如采用多层分页策略，限定各分层页表最多占 1 页大小，请问可以采用几层分页策<br>略？<br>（2）如采用倒排页表方式，请问倒排页表的大小？是每个进程一张倒排页表还是系统维<br>护一张倒排页表？如何解决倒排页表不便于逻辑地址向物理地址转换的问题？</p>
<blockquote>
<p>答：（1）页面长 4KB，说明页内偏移地址占 12 位，虚拟地址空间 64 位，说明页号总长为 64-12=52 位。页面长 4KB，页表项 4B，故每张页表不超过 4K/4=1K=210 项，即每级页表地址长度不应该超过 10 位。页号总长 52 位/每页表最长 10 位=5.2，向上取整为 6。即采用六层分页策略。<br>（2）如采用倒排页表，因为物理地址空间 4GB，故倒排页表应该有 4GB/4KB=1M 个页<br>表项，每页表项大小为 4B，倒排页表大小为 1M*4B=4MB。<br>系统维护一张倒排页表。<br>可以使用 Hash 散列，解决倒排页表不便于逻辑地址向物理地址转换的问题。</p>
</blockquote>
</li>
<li><p>缺页中断产生后，被中断的进程应该转入什么运行状态？讨论一下缺页中断<br>的执行过程，并说明中断处理完毕后返回被中断的进程时应该执行哪条语句。</p>
<blockquote>
<p>答：转入阻塞态（1 分）保护现场、陷入内核态、如果内存空间不足则选择淘汰、调需要的页面进内存（1 分）、更新页表和快表（1 分）、返回用户态，恢复现场、（1 分）重新执行被中断的语句。(1分)</p>
</blockquote>
</li>
<li><p>请讨论一下页面置换算法中工作集（Working Set）置换算法的工作原理。</p>
<blockquote>
<p>答：进程设置一个虚拟时钟，执行一个时钟周期就加 1，不执行就不增加。<br>（1 分）<br>每个页面被访问时，记录最后访问的虚拟时间，R 位置 1。R 位定期清除。（1<br>分）<br>如果 R=1,则保留，将当前时间记录下来。（1 分）<br>如果 R=0 对比当前虚拟时间与页面最后访问时间差 age 与阈值τ，如 age&gt;<br>τ则淘汰（1 分）。如 age &lt;= τ，则记录其访问时间，必要时淘汰其中最旧的。 （1 分）</p>
</blockquote>
<h4 id="设备管理和其他"><a href="#设备管理和其他" class="headerlink" title="设备管理和其他"></a>设备管理和其他</h4></li>
<li><p>用户程序发出磁盘I/O请求后，计算数据所在磁盘的柱面号、磁头号、扇区号的程序是 C<br>A.用户程序 B.系统调用处理程序 C.设备驱动程序 D.中断处理程序</p>
</li>
<li><p>在系统内存中设置磁盘缓冲区的主要目的是(A)<br>A．减少磁盘 I/O 次数 B．减少平均寻道时间 C．ᨀ高磁盘数据可靠性 D．实现设备无关性</p>
</li>
<li><p>在一个文件被用户进程首次打开的过程中，操作系统需做的是：B<br>A. 将文件内容读到内存中    B. 将文件控制块读到内存中<br>C. 修改文件控制块中的读写权限    D. 将文件的数据缓冲区首指针返回给用户进程</p>
</li>
<li><p>下列选项中，不可能在用户态发生的事件是 C<br>A. 系统调用    B. 外部中断    C. 进程切换    D. 缺页</p>
</li>
<li><p>操作系统的I/O子系统通常由四个层次组成，每一层明确定义了与邻近层次的接口，其合理层次组织排列顺序是 A<br>A.用户级 I/O 软件、设备无关软件、设备驱动程序、中断处理程序<br>B.用户级 I/O 软件、设备无关软件、中断处理程序、设备驱动程序<br>C.用户级 I/O 软件、设备驱动程序、设备无关软件、中断处理程序<br>D.用户级 I/O 软件、中断处理程序、设备无关软件、设备驱动程序</p>
</li>
<li><p>下列关于虚拟存储器的叙述中，正确的是 B<br>A. 虚拟存储器只能基于连续分配技术    B. 虚拟存储器只能基于非连续分配技术<br>C. 虚拟存储器只受外存容量的限制    D. 虚拟存储器只受内存容量的限制</p>
</li>
<li><p>计算机开机后，操作系统最终被加载到 D<br>A. BIOS    B. ROM(只读存储器)    C. EPROM    D. RAM(内存)</p>
</li>
<li><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/os9.png" alt="os9.png"><br>B</p>
</li>
<li><p>若一个用户过程通过read系统调用读取一个磁盘文件中的数据，则下列关于此过程的叙述中，正确的是A<br>Ⅰ. 若该文件的数据不在内存，则该进程进入睡眠等待状态<br>Ⅱ. 请求 read 系统调用会导致 CPU 从用户态切换到核心态<br>Ⅲ. read 系统调用的参数应包含文件的名称<br>A. 仅Ⅰ、Ⅱ B. 仅Ⅰ、Ⅲ C. 仅Ⅱ、Ⅲ D. Ⅰ、Ⅱ和Ⅲ</p>
</li>
<li><p>在采用 SPOOLing 技术的系统中，用户的打印数据首先被送到<strong>A_</strong>。<br>A. 磁盘固定区域 B. 内存固定区域 C. 终端 D. 打印机</p>
</li>
<li><p>操作系统的I/O子系统通常由四个层次组成，每一层明确定义了与邻近层次的接口，其合理的层次组织排列顺序是: A<br>A. 用户级 I/O 软件、设备无关软件、设备驱动程序、中断处理程序<br>B. 用户级 I/O 软件、设备无关软件、中断处理程序、设备驱动程序<br>C. 用户级 I/O 软件、设备驱动程序、设备无关软件、中断处理程序<br>D. 用户级 I/O 软件、中断处理程序、设备无关软件、设备驱动程序</p>
</li>
<li><p>下列选项中，不可能在用户态发生的事件是 C<br>A. 系统调用 B. 外部中断 C. 进程切换 D. 缺页</p>
</li>
<li><p>中断处理和子程序调用都需要压栈以保护现场，中断处理一定会保存而子程序调用不需要保存的是 A<br>A. 程序计数器 B. 程序状态字寄存器<br>C. 通用数据寄存器 D. 通用地址寄存器</p>
</li>
<li><p>在分时系统中，进程调度的时间片的大小宜选择为（C）<br>A、几十纳秒 B、几十微秒 C、几十毫秒 D、几十秒</p>
</li>
<li><p>若当前进程因时间片用完而让出处理机时，该进程应转变为（A）状态。<br>A、就绪 B、等待 C、运行 D、完成</p>
</li>
<li><p>能否使用管程，主要取决于（ B）：<br>A、程序员的编程技巧 B、编程语言的编译器支持<br>C、操作系统是否支持线程 D、是否有相应硬件的支持</p>
</li>
<li><p>下列选项中,导致创建新进程的操作是<strong><em>C</em></strong>。<br>I 用户登录成功 II 设备分配 III 启动程序执行<br>A.仅 I 和 II B.仅 II 和 III C.仅 I 和 III D.I 、II 和 III</p>
</li>
<li><p>下列文件物理结构中,适合随机访问且易于文件扩展的是<strong>B_</strong>。<br>A.连续结构 B.索引结构<br>C.链式结构且磁盘块定长 D.链式结构且磁盘块变长</p>
</li>
<li><p>19、设文件 F1 的当前引用计数值为 1,先建立 F1 的符号链接(软链接)文件 F2,再建立F1 的硬链接文件 F3,然后删除 F1。此时,F2 和 F3 的引用计数值分别是<strong>B</strong>。<br>A. 0、1 B.1、1 C.1、2 D.2、1</p>
</li>
<li><p>中断扫描机构是（B）扫描一次中断寄存器。<br>A、每隔一个时间片 B、每条指令执行周期内最后时刻<br>C、每当进程释放 CPU D、每产生一次中断</p>
</li>
<li><p>弹出式线程的优点在于：A<br>A、没有历史，创建迅速 B、安全性高<br>C、执行效率高 D、不需要操作系统内核支持线程</p>
</li>
<li><p>在 Web Server 中使用线程，可以ᨀ高对客户请求的响应效率。请简述图中<br>web page cache 的作用。<br><img src="os1.png" alt=""></p>
<blockquote>
<p>答：线程共享进程资源，所有的线程都可以访问进程的 web page cache（1<br>分），cache 在内存中（1 分），被访问过的页面存放在 cache 中，当任何线程再<br>次需要这个页面时就可以从 cache 中得到，而不需要再次读取硬盘。（3 分）</p>
</blockquote>
</li>
</ol>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><a href="https://blog.csdn.net/qq_28602957/article/details/53744956" target="_blank" rel="noopener">请求分页存储管理方式</a></p>
<p><a href="https://www.cnblogs.com/edisonchou/p/5090315.html" target="_blank" rel="noopener">内存管理上:基本内存管理</a><br><a href="https://www.cnblogs.com/edisonchou/p/5094066.html" target="_blank" rel="noopener">内存管理中:分页内存管理</a><br><a href="https://www.cnblogs.com/edisonchou/p/5115242.html" target="_blank" rel="noopener">内存管理下:段式内存管理</a></p>
]]></content>
      <categories>
        <category>期末</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络の摘要</title>
    <url>/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%81%AE%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<p>计网马上要考试了,之前从头看了遍网课,整理了点知识点和习题. 挑挑拣拣选一些考纲上的内容也来一个<br><strong>一天一遍,预防失眠</strong>(yjn_语录)</p>
<a id="more"></a>
<h3 id="摘要部分"><a href="#摘要部分" class="headerlink" title="摘要部分"></a>摘要部分</h3><ol>
<li><p>在TCP协议中，某数据包的确认包丢失也不一定导致发送方重传该数据包 √</p>
</li>
<li><p>传输层用进程编号（PID）来标示主机间通信的应用进程        × port</p>
</li>
<li><p>客户使用SMTP协议既能发送邮件又能接收邮件                × POP3接收邮件</p>
</li>
<li><p>某种网络安全威胁是通过非法手段取得对数据的使用权，并对数据进行恶意地添加和修改，这种安全威胁属于<strong>B__</strong><br>A、窃听数据 B、破坏数据完整性<br>C、拒绝服务 D、物理安全威胁</p>
</li>
<li><p>如要将138.10.0.0 网络分为6个子网，则子网掩码应设为（D）<br>A、255.0.0.0 B、255.255.0.0<br>C、255.255.128.0 D、255.255.224.0</p>
<blockquote>
<p>6个子网需要3个子网位,因为2^3=8 所以子网掩码是255.255.1110.0000,即255.255.224.0</p>
</blockquote>
</li>
<li><ol>
<li>下面有关网络互连设备说法正确的有（ABCD）<br>A、在物理层实现网络互连的主要设备有中继器和HUB。<br>B、在数据链路层实现网络互联的主要设备有二层交换机和网桥。<br>C、在网络层实现网络互连的主要设备有三层交换机和路由器。<br>D、在传输层（包括传输层）以上实现网络互连的设备有网关。</li>
</ol>
</li>
<li><p>试简述TCP协议在数据传输过程中收发双方是如何保证数据包的可靠性的。</p>
<blockquote>
<p>（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区； （1分）<br>（2）并为每个已发送的数据包启动一个超时定时器；（1分）<br>（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;（1分）<br>（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。（1分）<br>（5）接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。（1分）</p>
</blockquote>
</li>
<li><p>假设有五个IP地址A：131.107.256.80，B：231.222.0.11，C：126.1.0.0，D：198.121.254.255，E：202.117.34.32，找出不能分配给主机的IP地址，并说明原因。</p>
<blockquote>
<p>(1）A的第三个数256大于255是非法值，不能用于主机地址；（1分）<br>（2）B的第一个数231是保留给组播的地址，不能用于主机地址；（1分）<br>（3）C以全0结尾的IP地址是网络地址，不能用于主机地址；（1分）<br>（4）D以全1结尾的IP地址是广播地址，不能用于主机地址。（2分）</p>
</blockquote>
</li>
<li><p>为什么说TCP协议中针对某数据包的应答包丢失也不一定导致该数据包重传？<br>（1）由于TCP协议采用的是面向字符流的累计确认机制；（2分）<br>（2）当某数据包的应答丢失时，只要接收方还有数据发给发送方，在其应答字段中将包含对前面收到的数据包的应答信息，所以发送方不需要重发该数据包。（3分）<br><a href="https://zhidao.baidu.com/question/241652922.html?qbl=relate_question_0&word=TCP%D0%AD%D2%E9%D6%D0%D5%EB%B6%D4%C4%B3%CA%FD%BE%DD%B0%FC%B5%C4%D3%A6%B4%F0%B0%FC%B6%AA%CA%A7%D2%B2%B2%BB%D2%BB%B6%A8%B5%BC%D6%C2%B8%C3%CA%FD%BE%DD%B0%FC%D6%D8%B4%AB" target="_blank" rel="noopener">click</a></p>
</li>
<li><p>占据两个山顶的红军1与红军2与驻扎在这两个山之间的白军作战。其力量对比是:红军1或红军2打不赢白军，但红军1和红军2协同作战可战胜白军。红军1拟于次日凌晨6点向白军发起攻击，于是给红军2发送电文，但通信线路很不好，电文出错或丢失的可能性较大，因此要求收到电文的红军2必须送回一个确认电文，但确认电文也可能出错或丢失。试问能否设计出一种协议使得红军能够实现协同作战，因而100%的取得胜利？<br>答：</p>
<blockquote>
<p>（1）采用三次握手的方式；（2分）<br>（2）红军1给红军2发送电文，决定次日凌晨6点向白军发起攻击，请求红军2协同作战，并等待红军2的应答，如果在规定时间内没有收到应答，则重发请求；（3分）<br>（3）红军2如果收到红军1的作战报文后，则回送一个响应报文，表明已知道次日凌晨6点向白军发起攻击且愿意协同作战，并等待红军1的确认，如果在规定时间内没有收到确认报文，则重发响应报文；（3分）<br>（4）红军1收到红军2的响应报文，再向红军2发送一个确认报文，并表明已知道红军2将协同作战。（2分）</p>
</blockquote>
</li>
<li><p>学生A希望访问网站<code>www.sina.com</code>，A在其浏览器中输入<a href="http://www.sina.com并按回车，直到新浪的网站首页显示在其浏览器中，请问：在此过程中，按照TCP/IP参考模型，从应用层到网络层都用到了哪些协议？" target="_blank" rel="noopener">http://www.sina.com并按回车，直到新浪的网站首页显示在其浏览器中，请问：在此过程中，按照TCP/IP参考模型，从应用层到网络层都用到了哪些协议？</a><br>答：</p>
<blockquote>
<p>（1）应用层：HTTP：WWW访问协议，DNS：域名解析；（3分）<br>（2）传输层：TCP：在客户和服务器之间建立连接，提供可靠的数据传输；（4分）<br>（3）网络层：IP：IP包传输和路由选择，ICMP：提供网络传输中的差错检测，ARP：将本机的缺省网关IP地址映射成物理MAC地址。（4分）</p>
</blockquote>
</li>
<li><p>目前实际存在与使用的广域网基本都采用（D）。<br>A)总线拓扑 B)环状拓扑   C)星状拓扑 D)网状拓扑 </p>
</li>
<li><p>下列IP地址中属于B类IP地址的是（B）。<br>A) 200.126.32.50 B) 191.23.56.89 C) 192.168.0.1 D) 126.45.33.9</p>
<blockquote>
<p>A类IP地址 地址范围从1.0.0.1到127.255.255.254  子网掩码为255.0.0.0<br>B类IP地址地址范围从128.0.0.1-191.255.255.254   子网掩码为255.255.0.0<br>C类IP地址范围从192.0.0.1-223.255.255.254      子网掩码为255.255.255.0<br>私有地址范围:<br>A类地址：10.0.0.0～10.255.255.255<br>B类地址：172.16.0.0～172.31.255.255<br>C类地址：192.168.0.0～192.168.255.255<br>回送地址：127.0.0.1。 也是本机地址，等效于localhost或本机IP。</p>
</blockquote>
</li>
<li><p>在总线型局域网的介质访问控制方法中，采用“先听后发，边听边发，冲突停止，随机延迟后重发”的是（A）<br>A)CSMA/CD B)TokenBus C)TokenRing D)FDDI</p>
<blockquote>
<p>[解析] CSMA/CD的发送流程可以简单地概括为先听后发、边听边发、冲突停止、随机延迟后重发。<br>采用CSMA/CD介质访问控制方法的总线型局域网在发送数据前，先监听总线是否空闲。<br>若总线忙，则不发送：若总线空闲，则把准备好的数据发送到总线上。<br>在发送数据的过程中，工作站边发送边检测总线，是否自己发送的数据有冲突。<br>若无冲突则继续发送直到发完全部数据；若有冲突，则立即停止发送数据，但是要发送一个加强冲突的信号，以便使网络上所有工作站都知道网上发生了冲突，<br>然后，等待一个预定的随机时间，且在总线为空闲时，再重新发送未发完的数据。</p>
</blockquote>
</li>
<li><p>(ARP)是将IP地址映射成物理地址，而(TCP/IP)的主要目的是把资源名称解析成IP地址。 </p>
</li>
<li><p>网络安全的威胁因素有很多，其中人为的威胁因素类型有中断、窃取、更改和伪造。（√） </p>
</li>
</ol>
<ol start="17">
<li>网络安全的特性。 </li>
</ol>
<ul>
<li>保密性：信息不泄露给非授权用户、实体或过程，或供其利用的特性。</li>
<li>(数据)完整性：数据未经授权不能进行改变的特性。即信息在存储或传输过程中保持不被修改、不被破坏和丢失的特性。</li>
<li>可用性：可被授权实体访问并按需求使用的特性。即当需要时能否存取所需的信息。例如网络环境下拒绝服务、破坏网络和有关系统的正常运行等都属于对可用性的攻击；</li>
<li>可控性：对信息的传播及内容具有控制能力。</li>
</ul>
<ol start="17">
<li><p>计算机网络需要哪几方面的安全性？</p>
<blockquote>
<p>答案：<br>(1)保密性：计算机中的信息只能由授予访问权限的用户读取(包括显示、打印等，也包含暴露信息存在的事实)。<br>(2)数据完整性：计算机系统中的信息资源只能被授予权限的用户修改。<br>(3)可利用性：具有访问权限的用户在需要时可以利用计算机系统中的信息资源，得到密文。</p>
</blockquote>
</li>
<li><p>网络上两个进程之间进行通信需要用一个五元组来标识：(本机主机地址,本机端口号,协议,远程主机地址,远程端口号)</p>
</li>
<li><p>下列媒体访问协议中没有冲突的协议是(D)<br>A、1-支持CSMA B、ALOHA C、CSMA/CD D、TOKEN RING (令牌环网)</p>
</li>
<li><p>试简述主机1（IP地址为192.168.25.1，MAC地址为 E1）向主机2（IP地址为192.168.25.2，MAC地址为E2）发送数据时ARP 协议的工作过程（主机1、主机2在同一个子网内）。</p>
<blockquote>
<p>答：<br>（1）当主机1要向主机2发送数据时，必须知道主机2的MAC地址，为此，先根据主机2的IP地址在本机的ARP缓冲表内查找，如找到E2，则把E2填到MAC帧中，并把数据发送给主机2；<br>（2）如果在本机的ARP缓冲表内找不到主机2的MAC地址，则主机1产生一个ARP询问包，其中包含主机1的IP地址，MAC地址E1，主机2的IP地址，并广播到网络上询问有谁知道主机2的MAC地址？<br>（3）主机2收到ARP询问包后，根据询问者的IP和MAC地址E1立即向主机1回送一个ARP响应包，其中包含主机1的IP地址，MAC地址E1，主机2的IP地址和MAC地址E2，从而主机1获得了主机2的MAC地址E2，进而可向主机2发送数据。<br>3、设某网络在某一时刻的结构如下图所示，试用L-S路由算法为节点C计算到各节点的路由表（包括目的地、下一站、最小代价）。</p>
</blockquote>
</li>
<li><p>在某网络应用系统中，计算机A( IP地址为 192.168.25.168 , MAC地址为00：11：22：33：44：55)需要知道目前本网络内有多少台计算机在联网，其IP地址分别为多少，试运用所学的网络原理，说明解决此问题的方案（要求说明所采用的网络原理以及解决该问题的工作过程）。（本题10分）</p>
<blockquote>
<p>答：<br>（1）采用ICMP 请求应答报文（echo）；（1分）<br>（2）计算机A从IP地址192.168.25.1 到 192.168.25.254 做以下工作；（2分）<br>（3）构造一个ICMP请求应答报文，分别发给上述IP地址；（3分）<br>（4）如果能收到某IP有响应包，说明该IP对应的计算机已联网。（4分）</p>
</blockquote>
</li>
<li><p>将某C 网 192.168.118.0 划分成4个子网，请计算出每个子网的有效的主机IP地址范围和对应的网络掩码（掩码用2进制表示） 。（10分）（答案只要符合题目需求就可给满分，下面只是参考答案之一。）</p>
<blockquote>
<p>解：<br>（1）子网1的有效IP地址范围为： 192.168.118.1 — 192.168.118.63     (2分)</p>
<pre><code>（00 00 0001-00 11 1110）</code></pre><p>子网1的网络掩码为：11111111.11111111.11111111.11000000          (2分)<br>（2）子网2的有效IP地址范围为： 192.168.118.65 — 192.168.118.126   (2分)</p>
<pre><code>（01 00 0001-01 11 1110）</code></pre><p>子网2的网络掩码为：11111111.11111111.11111111.11000000<br>（3）子网3的有效IP地址范围为： 192.168.118.129 — 192.168.118.190  (2分)</p>
<pre><code>（10 00 0001-10 11 1110）</code></pre><p>子网3的网络掩码为：11111111.11111111.11111111.11000000<br>（4）子网4的有效IP地址范围为： 192.168.118.193 — 192.168.118.254  (2分)</p>
<pre><code>（11 00 0001-11 11 1110）</code></pre><p>子网4的网络掩码为：11111111.11111111.11111111.11000000</p>
</blockquote>
</li>
<li><p>假设要设计一个网络应用程序，用来测试从本机到互联网上任意一台主机是否连通，如果不通，还 要知道在哪个路由器不通，并了解中间需要经过哪些路由器（或网关）及从本机到这些路由器的时延有多长，请你根据所学的网络原理（要求先简述该网络原理）， 简要说明如何实现该应用程序。（15分）</p>
<blockquote>
<p>答：<br>（1）根据IP协议的规定，在每一个IP包中有一个TTL字段，标示该IP包剩余的生命周期（如开始时为128），IP包经过某一个路由器时，将IP包中的TTL值减1，当变为0时，该路由器将丢弃该IP包，并通过ICMP协议向发该IP包的源主机报告丢弃的原因（其中包括原因即TTL=0，丢弃的路由器IP，丢弃的时间等信息）；<br>（2）第一次让应用程序向目的主机发送一个TTL=1的ICMP 包，达到第一个路由器后，由于TTL将会变为0，该ICMP包被丢弃，故第一个路由器将源主机报告丢弃的原因，从而得知该路由器的IP地址和时延；<br>（3）同理，第N次让应用程序向目的主机发送一个TTL=N的ICMP 包，达到第N个路由器后，由于TTL将会变为0，该ICMP包被丢弃，故第N个路由器将源主机报告丢弃的原因，从而得知该路由器的IP地址和时延；<br>（4）直到到达目的主机（假如到达目的主机需要经过M个路由器）或无法到达目的主机（通过M个路由器)。</p>
</blockquote>
</li>
<li><p>设有两台主机的IP地址分别：195.248.8.145，195.248.9.220子网掩码都是255.255.255.0。判断这两个主机能否直接通信。如果不能直接通信，可以采用何种方法？并进行详细说明。</p>
<blockquote>
<p>（1）根据两主机的IP地址和子网掩码可以判断两主机不在同一个网络，所以不能直接通信。<br>（2）采用的方法：<br>1、用路由连接两个网络。由路由器来实现数据包从一个网络到另一个网络的转发，使这两台主机可以通信。<br>2.、将子网掩码改为255.255.240.0这样两主机就处于同一个网络中，即网络号相同，这样就能直接通信。</p>
</blockquote>
</li>
<li><p>简答分组交换的特点和不足。</p>
<blockquote>
<p>答案：（1）节点暂时存储的是一个个分组，而不是整个数据文件（2）分组暂时保存在节点的内存中，保证了较高的交换速率（3）动态分配信道，极大的提高了通信线路的利用率缺点：（4）分组在节点转发时因排队而造成一定的延时（5）分组必须携带一些控制信息而产生额外开销，管理控制比较困难</p>
</blockquote>
</li>
<li><p>简述在数据传输中，防止阻塞产生的办法</p>
<blockquote>
<p>答案：（1）通过对点对点的同步控制，使计算机之间的收发数据速率同步（2）控制网络的输入，避免突然大量数据报文提交（3）接收工作站在接收数据报文之前，保留足够的缓冲空间</p>
</blockquote>
</li>
<li><p>什么是路由？简述路由器的主要功能。<br>答：路由指的是从本地到网络的各个地方应该走的路径，由路由器根据目的地址将数据帧转发到不同的路径。选择最佳的转发数据的路径，建立非常灵活的联接，均衡网络负载；利用通信协议本身的流量控制功能来控制数据传输，有效解决拥挤问题；具有判断需要转发的数据分组的功能；把一个大的网络划分成若干个子网。</p>
</li>
<li><p>试说明IP地址与物理地址的区别。为什么要使用这两种不同的地址</p>
<blockquote>
<p>答：IP地址（Internet Protocol Address） 用于确定因特网上的每台主机，它是每台主机唯一性的标识。联网设备用物理地址标识自己，例如网卡地址。<br>TCP／IP用IP地址来标识源地址和目标地址，但源和目标主机却位于某个网络中，故源地址和目标地址都由网络号和主机号组成，但这种标号只是一种逻辑编号，而不是路由器和计算机网卡的物理地址。对于一台计算机而言，IP地址是可变的，而物理地址是固定的。</p>
</blockquote>
</li>
<li><p>（1）子网掩码为255.255.255.0代表什么意思？<br>（2）某网络的现在掩码为255.255.255.248，问该网络能够连接多少个主机？<br>（3）某A类网络和某B类网络的子网号subnet-id分别为16个1和8个1，问这两个网络的子网掩码有何不同？<br>（4）某A类网络的子网掩码为255.255.0.255，它是否是一个有效的子网掩码？</p>
<blockquote>
<p>答：（1）255.255.255.0可代表C类地址对应的子网掩码默认值；也可代表A类或B类地址的掩码，即主机号由最后8bit决定，而路由器寻找网络由前24bit决定。<br>（2）248=（11111000）2，即IP地址中前29位代表网络，后3位代表主机。所以共有主机数=23=8，但由于其中主机号全0代表该网络的网络地址，主机号全1代表该网络的广播地址，均不能分配给连网主机使用，所以网络能够连接的主机数=23-2=6台。<br>（3）这两个网络的子网掩码是一样的，均为255.255.255.0，但子网数不同，子网号为16bit的A类网络的子网数有216-2个，而子网号为8bit的B类网络的子网数有28-2个。<br>（4）有效，因RFC文档中没有规定子网掩码中的一串1必须是连续的，但不建议这样使用。</p>
</blockquote>
</li>
<li><p>与静态路由协议相比，动态路由有哪些优点？ ．（ AB ）<br>A、带宽占用少<br>B、简单<br>C、路由器能自动发现网络拓扑变化<br>D、路由器能自动计算新的路由</p>
</li>
<li><p>为什么要把IP地址解析成MAC地址才能实现数据传输？怎样进行地址解析？</p>
</li>
</ol>
<blockquote>
<p>（1）发送数据时，数据从高层到低层封装，然后才到通信链路上传输，使用IP地址的IP数据报一旦交给了数据链路层，就被封装成MAC帧。MAC帧在传送时使用的源地址和目的地址都是硬件地址（MAC地址），这两个硬件地址都写在MAC帧的首部中。<br>（2）连接在通信链路上的设备（主机或路由器）在接收MAC帧时，根据MAC帧首部中的MAC地址来决定接收或放弃。因此要把IP地址解析成MAC地址才能实现数据在链路层的封装，进而实现数据传输。<br>（3）每个主机或路由器接口都有一个ARP缓存用来完成IP地址到MAC地址的解析，在进行链路层封装时接口会查询该缓存，来实现解析。如果在缓存表中找不到所查询的IP地址对应的MAC地址，接口会向该局域网发送    ARP查询广播包，对应IP地址的接口收到该ARP查询，会向源地址发送ARP应答单播包，从而完成ARP解析。</p>
</blockquote>
<ol start="32">
<li><p>考虑某路由器具有下列路由表项：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">网络前缀	               下一跳</span><br><span class="line"><span class="number">142.150</span><span class="number">.64</span><span class="number">.0</span>/<span class="number">24</span> 	 A</span><br><span class="line"><span class="number">142.150</span><span class="number">.71</span><span class="number">.128</span>/<span class="number">28</span>        B</span><br><span class="line"><span class="number">142.150</span><span class="number">.71</span><span class="number">.128</span>/<span class="number">30</span>	 C</span><br><span class="line"><span class="number">142.150</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span>	         D</span><br></pre></td></tr></table></figure>
<p>（1）假设路由器接收到一个目的地址为142.150.71.132的IP分组，请确定该路由器为该IP分组选择的下一跳，并解释说明。<br>（2）在上面的路由表中增加一条路由表项，该路由表项使以142.150.71.132为目的地址的IP分组选择“A”作为下一跳，而不影响其他目的地址的IP分组转发。<br>（3）在上面的路由表中增加一条路由表项，使所有目的地址与该路由表中的任何路由表项都不匹配的IP分组被转发到下一跳“E”。<br>(4) 将142.150.64.0/24划分为4个规模尽可能大的等长子网，给出子网掩码及每个子网的可分配地址范围。</p>
<blockquote>
<p>(1)下一跳为B，因为该IP地址只和路由 142.150.71.128/28|B匹配。<br>（2）即增加一条主机路由 142.150.71.132/32|A<br>（3）即增加一条默认路由0.0.0.0/0|E<br>（4）255.255.255.192<br>范围:<br><code>142.150.64.1——142.150.64.62</code><br><code>142.150.64.65——142.150.64.126</code><br><code>142.150.64.129——142.150.64.190</code><br><code>142.150.64.193——142.150.64.254</code></p>
</blockquote>
</li>
<li><p>三种计算机分组交换方式比较</p>
<blockquote>
<p>a)    电路交换（Circuit Switching）－整个报文的比特流连续地从源点直达终点，好像在一个管道中传输；在通话的全部时间内，通话的两个用户始终占用端到端的通信资源，所以资源利用率低<br>b)    报文交换（Message Switching）－整个报文传送到相邻节点，全部存储下来后查找转发表，转发到下一个节点；通信线路利用率高、出错后纠错效率高等优点，被计算机与通信界广泛采用。存储转发是该技术的核心。<br>c)    分组（包）交换（Packet Switching）－单个分组（只是整个报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一个节点；<br>的优点<br>高效    动态分配传输带宽，对通信链路是逐段占用。<br>灵活    以分组为传送单位和查找路由。<br>迅速    不必先建立连接就能向其他主机发送分组。<br>可靠    保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。 </p>
</blockquote>
</li>
<li><p>arp的四种使用情况：</p>
<blockquote>
<p>1)发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。<br>2)发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。<br>3)发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。<br>4)发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</p>
</blockquote>
</li>
<li><p>RIP OSPF工作原理的理解与比较区别?</p>
</li>
</ol>
<ul>
<li>RIP工作原理：路由信息协议 RIP 是内部网关协议 IGP中最先得到广泛使用的协议。<ul>
<li>RIP 是一种分布式的基于距离向量的路由选择协议。</li>
<li>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。</li>
</ul>
</li>
<li>OSPF的特征：最主要的特征是分布式的链路状态协议，而不是距离向量协议。<ul>
<li>所有的路由器都维护一个链路状态数据库（路由器到子网的链路状态和可以到达的邻居路由器）。 </li>
<li>当网络中链路状态改变时，通过洪泛法（flooding）方法把更新的本地链路状态信息广播到区域或自治系统中的每个路由器。</li>
<li>每一个路由器用链路状态数据库中的数据，计算出到每个目的地最短路径。</li>
</ul>
</li>
<li>比较区别：<ul>
<li>SPF：只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。RIP：不管网络拓扑有无发生变化，路由器之间都要定期交换路由表信息</li>
</ul>
</li>
<li>与RIP相比<ul>
<li>1.OSPF 规定每隔一段时间，如 30分钟，要刷新一次数据库中的链路状态。 </li>
<li>2.由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。 </li>
<li>3.OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于 100 ms。</li>
<li>4.指定的路由器:多点接入的局域网采用了指定的路由器的方法，使广播的信息量大大减少。指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。</li>
</ul>
</li>
</ul>
<ol start="36">
<li>假定在地球和一个新月亮之间建立一条100M 位/秒的链路。从该月亮到地球的距离大约是385000 公里，数据在链路上以光速3×10^8米/秒传输。</li>
</ol>
<ul>
<li>（a） 计算该链路的最小RTT。<br>解：最小RTT 等于2×385000000 米÷（3×10^8米/秒）=2.57 秒</li>
<li>（b） 使用RTT 作为延迟，计算该链路的“延迟×带宽”值。<br>解：“延迟×带宽”值等于2.57 秒×100M 位/秒=257M 位≈32M 字节</li>
<li>（c） 在（b）中计算的“延迟×带宽”值的含义是什么？<br>解：它表示发送方在收到一个响应之前能够发送的数据量。</li>
<li>（d） 在月亮上用一个照相机拍取地球的相片，并把它们以数字形式保存到磁盘上。<br>假定在地球上的任务控制要下载25M 字节的最新图象，那么，从发出数据请求<br>到传送结束最少要化多少时间？<br>解：在图象可以开始到达地面之前，至少需要一个RTT。假定仅有带宽延迟，那么发送需要<br>的时间等于25M 字节÷100M 位/秒=200M 位÷100M 位/秒=2 秒。所以，直到最后一个图象位到达地球，总共化的时间等于2.0+2.57=4.57 秒。</li>
</ul>
<ol start="37">
<li><p>在因特网上的一个B 类网络具有子网掩码255.255.240.0。问每个子网中的最大主<br>机数目是多少？</p>
<blockquote>
<p>解答：对于一个B 类网络，高端16 位形成网络号，低端16 位是子网或主机域。在子网掩码的低端16 位<br>中，最高有效4 位是1111，因此剩下12 位（第3 字节低4 位和第4 字节）用于主机号。因此，存在4096<br>个主机地址，但由于全零和全1 是特别地址，因此最大主机数目应该是4094。</p>
</blockquote>
</li>
<li><p>假定TCP 使用两次握手替代三次握手来建立连接。也就是说，不需要第三个报文。那么<br>现在是否可能产生死锁？请给出例子来说明你的答案。<br>解答：我们知道，3 次握手完成两个重要功能，既要双方做好发送数据的准备工作（双方都<br>知道彼此已准备好），也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发<br>送与确认。<br>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机A<br>和B 之间的通信。假定B 给A 发送一个连接请求分组，A 收到了这个分组，并发送了确认<br>应答分组。按照两次握手的协定，A 认为连接已经成功地建立了，可以开始发送数据分组。<br>可是，B 在A 的应答分组在传输中被丢失的情况下，将不知道A 是否已准备好，不知道A<br>建议什么样的序列号用于A 到B 的交通，也不知道A 是否同意B 所建议的用于B 到A 交<br>通的初始序列号，B 甚至怀疑A 是否收到自己的连接请求分组。在这种情况下，B 认为连<br>接还未建立成功，将忽略A 发来的任何数据分组，只等待接收连接确认应答分组。而A 在<br>发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
</li>
<li><p><strong>试简述CSMA/CD协议的工作原理</strong>(重点)</p>
<blockquote>
<p>答： CSMA/CD协议即载波监听，多点接入，碰撞检测。（2分）<br>首先，每个站点发送数据之前必须侦听信道的忙、闲状态。如果信道空闲，立即发送数据，同时进行冲突检测；如果信道忙，站点继续侦听总线，直到信道变成空闲。（2分）<br>如果在数据发送过程中检测到冲突，将立即停止发送数据并等待一段随机长的时间，然后重复上述过程。（1分）<br>即：先听后发，边听边发；冲突检测，延时重发。（1分）</p>
</blockquote>
</li>
<li><p>一个Web页面请求全过程？<br>从键入<a href="http://www.google.com到浏览器显示网页经历了一系列的事件" target="_blank" rel="noopener">www.google.com到浏览器显示网页经历了一系列的事件</a></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.首先需要利用DNS域名服务知道google服务器的<span class="built_in">IP</span>地址：主机的操作系统生成一个DNS域名查询  报文，采用UDP传输层协议，端口号<span class="number">53</span>，网络层将此报文封装上<span class="built_in">IP</span>头部信息，加上源<span class="built_in">IP</span>地址与目的<span class="built_in">IP</span>地址（即DNS服务器的<span class="built_in">IP</span>地址），数据链路层将数据报封装成链路层数据帧，并将其转发到网关路由器</span><br><span class="line">（通过ARP协议，链路层转发），网关路由器抽取DNS数据报的<span class="built_in">IP</span>地址，查询转发表，将其从某接口转发，最终到达DNS服务器，DNS服务器查询这个域名DNS源记录，并将包含google服务器的地址的DNS应答报文发送给主机，主机接收到后，提取出google服务器的<span class="built_in">IP</span>地址</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.主机得先与google服务器建立TCP连接：传输层得先创建TCP套接字，目的端口<span class="number">80</span>，目的<span class="built_in">IP</span>地址google服务器的地址，建立连接需要三次握手，主机发送SYN连接请求报文，google服务器收到后，分配缓存与变量，回复SYNACK报文，主机收到后，分配缓存与变量资源，回复ACK报文，并可以携带HTTP <span class="meta">GET</span>报文</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.主机发送HTTP <span class="meta">GET</span>报文：主机应用层生成HTTP <span class="meta">GET</span>报文，传递给TCP传输层，TCP协议给HTTP <span class="meta">GET</span>报文封装TCP头部信息，并交给<span class="built_in">IP</span>层，<span class="built_in">IP</span>层封装<span class="built_in">IP</span>头部信息称为数据报，再交给数据链路层封装成数据帧，通过ARP协议，进行链路层转发到网关路由器，网关路由器提取<span class="built_in">IP</span>地址，查询转发表，再转发到某借口，最终到达google服务器，服务器提取出HTTP <span class="meta">GET</span>报文，生成一个HTTP响应报文，将所请求的WEB页面放入HTTP响应体中，并通过TCP连接将此报文发送回主机，主机收到后，提取出HTTP 响应报文，从HTTP响应体中提取出HTML文件，最终显示出了WEB页面</span><br></pre></td></tr></table></figure></li>
<li><p>概述MAC地址与ARP协议？</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">每一个网络设备的适配器都有自己的链路层地址，<span class="keyword">MAC</span>地址，这个地址是自生产出来就是唯一的。数据链路层需要通过<span class="keyword">MAC</span>地址来转发数据帧来通过交换机网络</span><br><span class="line"></span><br><span class="line">ARP协议称为地址解析协议，提供了IP地址转换为链路层<span class="keyword">MAC</span>地址的机制</span><br><span class="line">IP地址相当于邮政地址，<span class="keyword">MAC</span>地址相当于身份证号</span><br><span class="line"></span><br><span class="line">ARP工作原理：</span><br><span class="line">每台主机或路由器都保存有一张ARP表，表中包含IP地址与<span class="keyword">MAC</span>地址的映射关系当表中有目的IP地址的信息时，就直接交给链路层进行发送</span><br><span class="line">如果表中还没有相关信息，则在本子网内发送ARP广播查询，若此IP目的节点收到后应回复一个ARP应答报文</span><br><span class="line">所以ARP是自适应的，自动建立的，即插即用的</span><br></pre></td></tr></table></figure></li>
<li><p>概述MAC协议？</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MAC</span>协议称为多路访问控制协议</span><br><span class="line">主要能分为三类：信道划分协议，随机接入协议，轮流协议</span><br><span class="line"></span><br><span class="line">信道划分协议</span><br><span class="line">主要分为时分多路复用（TDM），频分多路复用（FDM），码分多址（CDMA）</span><br><span class="line">相当于是为每一个可能使用的人预留了一段资源，每个人在自己分配的那段资源里传输数据，所以一定不会发生碰撞</span><br><span class="line">当某时刻用的人很多时，利用率高当某时刻用的人很少时，利用率低</span><br><span class="line">随机接入协议基本思想是：当用户有数据需要发送时，就直接发送，如果与其他人发生碰撞了，就等一个随机时延，再重新发送，直到没有碰撞发生，发送成功为止</span><br><span class="line">主要有时隙ALOHA，ALOHA，CSMA，CSMA/<span class="keyword">CD</span>协议</span><br><span class="line">时隙ALOHA将时间划分若干时隙，规定所有人只能在某一个时隙的起始点发送数据</span><br><span class="line">ALOHA则没有这个规定，所有人可以在任何时间发送数据时隙ALOHA的效率比ALOHA协议的效率要高一倍左右</span><br><span class="line">CSMA协议称为载波侦听多路访问，即发送数据之前先侦听信道，当没有人发送数据时，才发送数据</span><br><span class="line">CSMA/<span class="keyword">CD</span>协议称为带碰撞检测的载波侦听多路访问协议，在CSMA基础上加了碰撞检测，若检测到碰撞，则都立即停止发送，等一个随机时间后再次发送</span><br><span class="line"></span><br><span class="line">那么既然所有人都侦听了，为什么还会发生碰撞呢？原因是存在传播延迟。随机接入协议，当某时刻用的人少时，效率很高</span><br><span class="line">用的人多时，发生碰撞概率高，效率较低</span><br><span class="line">轮流协议</span><br><span class="line">按照一定的轮流规则，所有需要发送数据的人轮流发送数据，轮到谁就谁发。主要有</span><br><span class="line">轮询协议：主节点轮流通知每个节点，你可以发送数据了，如果你有数据，就发，没数据，就过缺点：带来额外的轮询消耗；如果主节点发生故障，则后果严重</span><br><span class="line">令牌传递：某种称为令牌的特殊帧在节点之间按特定次序传递，令牌传递到的节点才可以发送数据。</span><br><span class="line">缺点：同样带来消耗，某一节点发生故障也可能给整个信道带来奔溃。</span><br></pre></td></tr></table></figure></li>
<li><p>概述数据链路层的服务？</p>
<blockquote>
<p>基本服务：将网络层的数据报封装成数据帧，通过单一通信链路从一个节点传输到另一个节点<br>链路层的主体是在网络适配器上实现的<br>链路层信道主要分为两类，点对点链路（PPP），和广播链路</p>
</blockquote>
</li>
<li><p>概述路由算法？</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">链路状态路由算法（LS）</span><br><span class="line">全局式的路由选择算法</span><br><span class="line">每个节点有本网络所有的网络拓扑以及链路费用的全局信息运用迪杰斯特拉（Dijkstra）算法计算最短路由选择</span><br><span class="line">特点</span><br><span class="line">向网络上所有其他节点广播消息消息仅包括到邻居节点的费用 收敛速度较快</span><br><span class="line">存在震荡现象（当费用与通信量相关时）</span><br><span class="line">距离向量路由算法（DV）</span><br><span class="line">分布式的路由算则算法</span><br><span class="line">每个节点仅保存通往目的地的最短路径的下一跳，通过迭代的方式计算出路径选择</span><br><span class="line">每个节点从直接相连的邻居处获取信息，然后计算，若有变化，则将计算结果分发给直接相连的邻居</span><br><span class="line">每个节点直接检测到链路费用，更新路由信息，若变化，发送给所有直接的邻居</span><br><span class="line">特点</span><br><span class="line">分布式，迭代，异步的路由算法仅向直接相连的邻居交换信息</span><br><span class="line">每个节点仅保存通往目的地最短路径的下一跳收敛速度慢</span><br><span class="line">好消息传播快，坏消息传播慢</span><br><span class="line">存在无穷计数的问题，解决办法为毒性逆转，（如果A通往目的地的最短路径的下一跳是B，则当B 询问B通过A去目的地的最短路径时，A回复无穷大）</span><br><span class="line">层次路由选择</span><br><span class="line">将一个大规模网络分为多个自治系统（AS），每个自治系统内运行相同的路由算法，称为自治系统</span><br><span class="line"></span><br><span class="line">内部路由选择协议（如RIP，OSPF）</span><br><span class="line">两个自治系统AS之间的通信运行自治系统间路由选择协议（如BGP）</span><br><span class="line">RIP</span><br><span class="line">路由选择信息协议（Routing Information Protocol）</span><br><span class="line">基于距离向量路由算法（DV），定义跳数为其链路费用RIP被当做一个应用进程来实现，交换信息使用UDP RIP通常被用于小规模网络，下层ISP及公司网络 OSPF</span><br><span class="line">开放最短路优先协议（Open Shortest Path First） 基于链路状态路由算法（LS）</span><br><span class="line">当一条链路费用变化时，节点向网络中所有节点广播路由选择信息每个节点使用Dijkstra算法计算最低费用路径选择</span><br><span class="line">OSPF更复杂，也有很多优点： 安全</span><br><span class="line">可以有多条相同费用路径，当需要传递大量分组时，有多个选择，充分利用支持单播和多播路由</span><br><span class="line">OSPF支持在AS内部进一步分层</span><br><span class="line">BGP</span><br><span class="line">边界网关协议（Border Gateway Protocol）,自治系统间的路由选择协议eBGP，从邻居子网获取可达信息                           iBGP，向本子网内节点传递子网可达信息</span><br><span class="line">基于可达信息的路径，确定到达外部子网的好的路径</span><br></pre></td></tr></table></figure></li>
<li><p>概述NAT协议？</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">NAT</span>又称为网络地址转换，为本地私有网络提供合法<span class="built_in">IP</span>地址，连接到外部网络</span><br><span class="line"><span class="symbol">NAT</span>不仅能解决<span class="built_in">IP</span>地址不足的问题，而且能有效避免被攻击，隐藏和保护内部计算机NAT的转换方式主要有三种：</span><br><span class="line">静态转换：将私有网络的某<span class="built_in">IP</span>地址转换成特定的合法<span class="built_in">IP</span>地址，一对一静态转换</span><br><span class="line">动态转换：将私有网络的<span class="built_in">IP</span>地址转换成合法<span class="built_in">IP</span>地址时，是不确定的，可以随机转换成任意指定的合法<span class="built_in">IP</span>地址</span><br><span class="line">端口多路复用：将私有网络的<span class="built_in">IP</span>地址转换成合法<span class="built_in">IP</span>地址时，所有私有网络主机共享一个合法<span class="built_in">IP</span>地址，每个主机转换为端口号，进行外部网络的访问。</span><br></pre></td></tr></table></figure></li>
<li><p>概述DHCP协议？<br>DHCP协议又称为动态主机配置协议，DHCP允许主机自动获取IP地址<br>DHCP是一种客户端-服务器协议，在应用层实现，采用UDP<br>主机获取IP地址步骤：</p>
</li>
</ol>
<ul>
<li><ol>
<li>主机广播DHCP发现报文</li>
</ol>
</li>
<li><ol start="2">
<li>DHCP服务器回应ACK，并携带分配给它的IP地址，表示提供服务</li>
</ol>
</li>
<li><ol start="3">
<li>主机广播DHCP请求，表示我打算连接到你分配的IP地址，同时也相当于告诉其他DHCP服务器， 我已经打算连接到这个DHCP服务器的IP地址了，你们分配的IP地址可收回了</li>
</ol>
</li>
<li><ol start="4">
<li>DHCP服务器最后回复ACK报文</li>
</ol>
</li>
</ul>
<ol start="47">
<li>概述TCP协议？<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP协议是一种点对点的，面向连接的，全双工的服务的，面向字节流的，可靠的，具有拥塞控制的传输层协议</span><br><span class="line">点对点：TCP连接只能是一对一建立的</span><br><span class="line">面向连接：TCP协议在传输数据之前需要建立连接</span><br><span class="line">全双工服务：TCP连接建立之后，连接双方都可以同时向对方发送数据</span><br><span class="line">面向字节流的：TCP把数据看成无结构的，有序的字节流，TCP的序号是建立在字节流上而不是建立在报文段上</span><br><span class="line">可靠的：TCP采用确认重传机制，序号机制，定时器机制，快速重传，滑动窗口机制，流量控制等 来保证数据传输的可靠性</span><br><span class="line">拥塞控制：TCP采用慢启动，拥塞避免，快速恢复的机制来进行拥塞控制，共避免网络空间陷入拥塞</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>TCP报文头部<ul>
<li>源端口号：发送方进程端口号目的端口号：接收方进程端口号</li>
<li>序号：32比特，建立在字节流上的序号机制</li>
</ul>
<ul>
<li>确认号：32比特，确认号表示期望收到的下一字节的序号，与序号共同保证TCP的可靠传输首部长度：TCP首部长度，因为选项字段的存在，一般无选项头部长为20字节       URG：表示报文段中存在被发送方指示为紧急的数据。紧急数据由紧急数据指针指出ACK：确认标志位，表示首部的确认号有效</li>
<li>PSH：表示接收方应立即将接收的数据交付给上层。因为TCP接收方可能存在接收缓存，接收方可能在忙其他事情，可能等接收缓存满的时候，才会将数据交付给上层，PSH标志位表示接收方应立即将数据交付上层</li>
<li>RST：表示复位，用来异常的关闭连接，引发RST的原因主要有：提前关闭，请求超时，端口未打开，在一个已关闭的SOCKET接收到数据</li>
<li>SYN：建立TCP连接时的标志位FIN：关闭TCP连接时的标志位</li>
<li>接收窗口：表示接收方还有多少缓存供接收，用于控制发送方的发送速率，以免溢出。用于流量控制</li>
<li>检验和：首部+数据全部的检验和</li>
<li>紧急数据指针：与URG标志位共同使用，指出数据中的紧急数据字段</li>
</ul>
</li>
</ul>
<ul>
<li>TCP的可靠数据传输<br>  TCP的可靠数据传输服务保证应用进程从接收缓存中读取的数据是不错，不乱，不丢的数据<ul>
<li>确认：只发送ACK确认被正确接收的分组，不发NAK，确认号是期望收到的下一字节序号：序号基于无结构，有序的字节流。序号表示该报文段的首字节的字节流编号</li>
<li>定时器：TCP设置单一定时器</li>
<li>累计确认：TCP采用累计确认，即接收方发送确认号为x的ACK，表示x之前的报文段都已被正确的接收；但是采用全部重传还是选择重传，TCP没有明确规定</li>
<li>超时重传：如果报文段的传输时间超时，则重传</li>
<li>快速重传：当发送方收到三个重复ACK（即共4个ACK），则快速重传该报文段</li>
</ul>
</li>
</ul>
<ul>
<li>TCP流量控制<br>  因为接收方设置有限的接收缓存，如果发送方发送速率过大的话，接收方缓存可能溢出，导致不必要的分组丢失<br>  所以流量控制是为了限制发送方的发送速率，来保证接收方可以来得及接收到来的报文段<br>  接收方在头部的接收窗口告诉发送方，接收缓存还剩多少，即还能接收多少数据，发送方保证发送的数据量不超过这个量<br>  若接收方告知接收窗口为0了，为避免阻塞，发送方仍发送数据量为1的报文段，接收方接收并回复ACK，并同时告知此时的接收窗口大小<br>  发送方的发送速率由流量控制的接收窗口大小与拥塞控制的拥塞窗口大小共同控制</li>
<li>TCP的拥塞控制<ul>
<li>发送方控制自己的发送速率，避免公共网络陷入拥塞，所有TCP发送方共同维护公共网络</li>
<li>拥塞控制与流量控制的区别：流量控制是考虑端到端之间的问题，是避免发送方发送速率过快导 致接收方来不及接收，考虑的是私人利益；拥塞控制考虑的是公共网络，避免发送方发送速率过快而导致网络陷入拥塞，考虑的是公共网络的问题</li>
<li>TCP在发送方维护一个CWND的拥塞窗口变量，与接收窗口RWND共同控制发送速率（滑动窗口的大小）</li>
<li>TCP根据丢包事件来感知网络的拥塞状态，如果发生超时丢包事件，则说明网络已经比较拥塞  了，数据已经传输不到接收方；如果重复ACK丢包事件，则表示网络可能即将陷入拥塞，但是没有那么严重，因为数据还能传输到接收方</li>
</ul>
</li>
</ul>
<ul>
<li>拥塞控制方法<ul>
<li>慢启动：TCP启动速度很慢，一般从MSS从1开始，但是希望快速找到可用带宽的数量，发送速率指数增长，知道遇到丢包时间，则设置一个阀值等于丢包时的速率的一般，即ssthresh = CWND/2 拥塞避免：如果是超时事件引起的丢包，则进入拥塞避免状态，拥塞避免状态将阀值设为拥塞窗口值的一半之后，将速率设为MSS = 1，然后开始指数增长，直到达到阀值ssthresh，此时可能即将进入拥塞状态了，所以之后再线性增长，直到遇到丢包事件</li>
<li>快速恢复：如果是3个重复ACK引起的丢包事件，此时TCP执行快速重传，并进入快速恢复状态， 将阀值设为拥塞窗口值的一般，即ssthresh = CWND/2，然后将发送速率降为阀值ssthresh，之后线性增长，直到遇到丢包事件</li>
</ul>
</li>
</ul>
<p>能够理解计算机网络协议栈分层设计的方法，每层的名称、主要功能、Internet 对应层的主要协议。<br>48. OSI七层架构</p>
<table>
<thead>
<tr>
<th align="center">r</th>
<th align="center">l</th>
<th align="center">j</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第一层</td>
<td align="center">物理层（physical）</td>
<td align="center">（单位类型：比特）    实现比特流的透明传输，物理接口，具有电气特性</td>
</tr>
<tr>
<td align="center">第二层</td>
<td align="center">数据链路层（date link）（单位类型：帧）</td>
<td align="center">访问介质；数据在该层封装成帧；用MAC地址作为访问媒介；具有错误检测与修正功能。MAC描述在共享介质环境中如何进行站的调度、发生和接收数据。MAC确保信息跨链路的可靠传输，对数据传输进行同步，识别错误和控制数据的流向。一般地讲，MAC只在共享介质环境中才是重要的，只有在共享介质环境中多个节点才能连接到同一传输介质上</td>
</tr>
<tr>
<td align="center">第三层</td>
<td align="center">网络层（network）（单位类型：报文）</td>
<td align="center">数据传输；提供逻辑地址，选择路由数据包，负责在源和终点之间建立连接</td>
</tr>
<tr>
<td align="center">第四层</td>
<td align="center">传输层（transport）</td>
<td align="center">实现端到端传输；分可靠与不可靠传输；在传输前实现错误检测与流量控制，定义端口号（标记相应的服务）</td>
</tr>
<tr>
<td align="center">第五层</td>
<td align="center">会话层（session）</td>
<td align="center">主机间通信；对应用会话管理，同步</td>
</tr>
<tr>
<td align="center">第六层</td>
<td align="center">表示层（presention）</td>
<td align="center">数据表现形式；特定功能的实现-比如加密模式确保原始设备上加密的数据可以在目标设备上正确地解密</td>
</tr>
<tr>
<td align="center">第七层</td>
<td align="center">应用层（application）</td>
<td align="center">最接近终端用户的OSI层，这就意味着OSI应用层与用户之间是通过应用软件直接相互作用的。网络进程访问应用层；提供接口服务</td>
</tr>
<tr>
<td align="center">- 2.TCP/IP四层架构</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">r</th>
<th align="center">l</th>
<th align="center">j</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第四层</td>
<td align="center">应用层</td>
<td align="center">TCP/IP协议的应用层相当于OSI模型的会话层、表示层和应用层，FTP(文件传输协议)，DNS（域名系统），HTTP协议，Telnet（网络远程访问协议）</td>
</tr>
<tr>
<td align="center">第三层</td>
<td align="center">传输层</td>
<td align="center">提供TCP(传输控制协议)，UDP（用户数据报协议）两个协议，主要功能是数据格式化、数据确认和丢失重传等。</td>
</tr>
<tr>
<td align="center">第二层</td>
<td align="center">网络层</td>
<td align="center">该层负责相同或不同网络中计算机之间的通信主要处理数据包和路由。数据包是网络传输的最小数据单位。通过某条传输路线将数据包传给对方。IP协议,ICMP协议，IGMP协议。在IP层中，ARP协议用于将IP地址转换成物理地址，ICMP协议用于报告差错和传送控制信息。IP协议在TCP/IP协议组中处于核心地位。</td>
</tr>
<tr>
<td align="center">第一层</td>
<td align="center">网络接口层</td>
<td align="center">TCP/IP协议的最低一层，对实际的网络媒体的管理，包括操作系统中的设备驱动程序和计算机对应的网络接口卡</td>
</tr>
</tbody></table>
<ul>
<li>3.TCP/IP五层架构</li>
</ul>
<table>
<thead>
<tr>
<th align="center">r</th>
<th align="center">l</th>
<th align="center">j</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第五层</td>
<td align="center">应用层 单位:报文(message)</td>
<td align="center">应用层是网络应用程序及它们的应用层协议存留的地方    面向用户提供端到端的网络服务</td>
</tr>
<tr>
<td align="center">第四层</td>
<td align="center">运输层 单位:报文段(segment)</td>
<td align="center">因特网的运输层在应用程序端点之间传送应用层报文.有两种运输层协议TCP和UDP.为应用层提供端到端的数据传输服务。</td>
</tr>
<tr>
<td align="center">第三层</td>
<td align="center">网络层 单位:数据报(datagram)</td>
<td align="center">负责将名为数据报的网络层分组从一台主机移动到另一台主机.转发和路由.为数据包找到一条从源地址到目的地址的路径</td>
</tr>
<tr>
<td align="center">第二层</td>
<td align="center">链路层 单位:帧(frame)</td>
<td align="center">将整个帧从一个网络元素移动到邻近的网络元素  为共享同一条链路的多个用户分配链路资源,以便把数据包传输到网络层指定的相邻节点上</td>
</tr>
<tr>
<td align="center">第一层</td>
<td align="center">物理层 单位:比特(bit)</td>
<td align="center">将帧中的一个个比特从一个节点移动到下一个节点    负责把数字信号转换成模拟信号（光/电等）在物理介质上传输。</td>
</tr>
</tbody></table>
<ol start="49">
<li><p>C/S模式和P2P模式的区别和优点缺点?</p>
<blockquote>
<p>1、C/S工作模式中信息资源的共享是以服务器为中心<br>2、P2P工作模式淡化服务提供者与服务使用者的界限，P2P网络中的每台计算机即可以是网络服务使用者也可以是提供者<br>3、C/S与P2P模式的差别主要在应用层<br>C/S：DNS，SMTP，FTP，Web<br>P2P：支持文件共享类Napster与BitTorrent服务协议、支持多媒体传输类Skype服务的协议<br>P2P网络是在IP网络上构建的一种逻辑的覆盖网，P2P是一种网络的覆盖模式</p>
</blockquote>
</li>
<li><p>DNS<br>(name,value,type,ttl)</p>
</li>
</ol>
<ul>
<li>type = A<br>  name 是主机名,value是主机名对应的ip<br>  例如(tju.rlj.com,123.124.0.1,A)</li>
<li>type = NS<br>  name 是个域 如(rlj.com) value是个知道如何获得该域中主机ip地址的权威dns服务器的主机名<br>  例如:(rlj.com,dns.rlj.com,NS)</li>
<li>type = CNAME<br>  value是别名为name的主机对应的规范主机名<br>  例如:(rlj.com,tju.rlj.com,CNAME)</li>
<li>type = MX<br>  value 是个别名为name的邮件服务器的规范主机名<br>  (rlj.com,mail.rlj.com,NX)</li>
</ul>
<ol start="51">
<li>NAT在P2P应用又事码问题? 怎么能解决?具体名字是什么?<blockquote>
<p>：P2P 需要实现两台主机间端到端的对等连接与通信,即参与通信的两台主机都可以是服务器,等待对 方的连接.而使用 NAT 技术后,NAT 设备后面的主机使用的是内部 IP 地址,不能直接被外部的设备访问, 因此部署在 NAT 设备之后的主机不能作为服务器,因而无法实现 P2P 通信.可以通过事先配置 NAT 转换 表来解决这一问题,即在表中增加内部主机的内部 IP,内部端口号和外部 IP,外部端口号的对应表项.这 一技术有 NAT 穿越 技术,UPnP协议</p>
</blockquote>
</li>
</ol>
<ul>
<li>第七,八,九章 <ul>
<li>A通过计算机网络给B发送消息，说其同意签订合同。随后A反悔，不承认发过该消息。为防止这种情况发生，在计算机网络中应采用 D 技术。<br>A、消息认证 B、数据加密 C、防火墙 D、数字签名 </li>
<li>在公钥密码体制中，不公开的是 B 。<br>A、公钥 B、私钥 C、公钥和加密算法 D、私钥和加密算法</li>
</ul>
</li>
</ul>
<p><a href="https://blog.csdn.net/u012557765/article/details/81638446" target="_blank" rel="noopener">相关文章:数据交换</a><br><a href="https://blog.csdn.net/qq894040717/article/details/82426965" target="_blank" rel="noopener">CSMA/CA</a></p>
]]></content>
      <categories>
        <category>期末</category>
      </categories>
      <tags>
        <tag>Computer Networking</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵链相乘</title>
    <url>/2019/11/02/%E7%9F%A9%E9%98%B5%E9%93%BE%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<h3 id="矩阵链相乘"><a href="#矩阵链相乘" class="headerlink" title="矩阵链相乘"></a>矩阵链相乘</h3><p>矩阵链乘法<br>   求解矩阵链相乘问题时动态规划算法的另一个例子。给定一个n个矩阵的序列（矩阵链）&lt;A1,A2,…,An&gt;，我们希望计算它们的乘积  A1A2…An</p>
<a id="more"></a> 
<p> 两个矩阵A和B只有相容(compatible)，即A的列数等于B的行数时，才能相乘。如果A是p×q的矩阵，B是q×r的矩阵，那么乘积C是p×r的矩阵。计算C所需要时间由第8行的标量乘法的次数决定的，即pqr。<br>   以矩阵链&lt;A1,A2,A3&gt;为例，来说明不同的加括号方式会导致不同的计算代价。假设三个矩阵的规模分别为10×100、100×5和5×50。<br>   如果按照((A1A2)A3)的顺序计算，为计算A1A2(规模10×5)，需要做10×100×5=5000次标量乘法，再与A3相乘又需要做10×5×50=2500次标量乘法，共需7500次标量乘法。<br>   如果按照(A1(A2A3))的顺序计算，为计算A2A3(规模100×50)，需100×5×50=25000次标量乘法，再与A1相乘又需10×100×50=50000次标量乘法，共需75000次标量乘法。因此第一种顺序计算要比第二种顺序计算快10倍。</p>
<p> 矩阵链乘法问题(matrix-chain multiplication problem)可描述如下：给定n个矩阵的链&lt;A1,A2,…,An&gt;，矩阵Ai的规模为p(i-1)×p(i) (1&lt;=i&lt;=n)，求完全括号化方案，使得计算乘积A1A2…An所需标量乘法次数最少。</p>
<h3 id="递推关系式"><a href="#递推关系式" class="headerlink" title="递推关系式"></a>递推关系式</h3><p><a href="https://blog.csdn.net/Neo_kh/article/details/81282025" target="_blank" rel="noopener">https://blog.csdn.net/Neo_kh/article/details/81282025</a><br>    ①如果i=j，m[i,j]=0</p>
<pre><code>②如果i&lt;j，m[i,j]=min{m[i,k]+m[k+1,j]+p(i-1)p(k)p(j)}  i&lt;=k&lt;j</code></pre><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_size 400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 100000000</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[max_size][max_size];<span class="comment">//保存构造最优解信息</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> p[max_size];<span class="comment">//矩阵规模的记录</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m[max_size][max_size];<span class="comment">//记录最优值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">matrix_chain_order</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m[i][i]=<span class="number">0</span>;<span class="comment">//初始化最优值(起始于1,结束于n)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">2</span>;l&lt;=n;l++)<span class="comment">//l表示矩阵链的长度</span></span><br><span class="line">    &#123;<span class="comment">//计算每一条对角线的最优值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-l+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+l<span class="number">-1</span>;</span><br><span class="line">            m[i][j]=INF;</span><br><span class="line">            s[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j<span class="number">-1</span>;k&gt;=i;k--)<span class="comment">//解决方案优先选取先左边的矩阵</span></span><br><span class="line">            &#123;<span class="comment">//②如果i&lt;j，m[i,j]=min&#123;m[i,k]+m[k+1,j]+p(i-1)p(k)p(j)&#125;  i&lt;=k&lt;j</span></span><br><span class="line">                <span class="keyword">int</span> q=m[i][k]+m[k+<span class="number">1</span>][j]+p[i<span class="number">-1</span>]*p[k]*p[j];</span><br><span class="line">                <span class="keyword">if</span>(q&lt;m[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j]=q;</span><br><span class="line">                    s[i][j]=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_optimal_parents</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span><span class="comment">//打印最优解的结果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==j)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"A%d"</span>,i);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">//中序二叉树?</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">            print_optimal_parents(i,s[i][j]);</span><br><span class="line">            print_optimal_parents(s[i][j]+<span class="number">1</span>,j);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        matrix_chain_order(n);</span><br><span class="line">        print_optimal_parents(<span class="number">1</span>,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结:<br>动态规划算法设计要素<br>1.多阶段决策过程,每步处理一个子问题,界定子问题的边界<br>2.列出优化函数的递推方程及初值<br>3.问题要满足优化原则或最优子结构性质,即:一个最优决策序列的任何子序列本身一定是相对于子序列的<br>初始和结束状态的最优决策序列<br>拓展: 递归实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==j)               <span class="comment">/*如果只有一个矩阵就直接返回*/</span></span><br><span class="line">        <span class="keyword">return</span> m[i][j];</span><br><span class="line">    m[i][j]=<span class="number">999999999</span>;     <span class="comment">/*将m[i][j]设为无穷大*/</span></span><br><span class="line">    s[i][j]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)&#123;  <span class="comment">/*将i到j个矩阵分为i到k和k+1到j个矩阵*/</span></span><br><span class="line">        <span class="keyword">int</span> q=dp(i,k)+dp(k+<span class="number">1</span>,j)+p[i<span class="number">-1</span>]*p[k]*p[j]; </span><br><span class="line">        <span class="keyword">if</span>(q&lt;m[i][j])&#123;      <span class="comment">/*如果有更小的方案更新*/</span></span><br><span class="line">            m[i][j]=q;</span><br><span class="line">            s[i][j]=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m[i][j];         </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;  <span class="comment">/*输入矩阵链*/</span></span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));    <span class="comment">/*初始化*/</span></span><br><span class="line">        dp(<span class="number">1</span>,n);                    <span class="comment">/*查找目标1到n个矩阵链乘*/</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;m[<span class="number">1</span>][n]&lt;&lt;<span class="string">" "</span>&lt;&lt;s[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>矩阵链</tag>
      </tags>
  </entry>
</search>
