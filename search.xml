<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式之Interpreter模式</title>
    <url>/2020/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BInterpreter%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/int.png" alt><br>语法规则也是类</p>
<a id="more"></a>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>解释器模式与编译原理中学的编译器很像.不过这个解释器就是完成了对语法的解析,将一个个的词组解释称一个个语法范畴,之后再拿来使用.</p>
<p>在Interpreter模式中,程序要解决的问题会被用非常简单的<strong>迷你语言</strong>表述出来,即用<strong>迷你语言</strong>编写的<strong>迷你程序</strong>把具体的问题表述出来.迷你程序是无法单独工作的.我们还需要用Java语言编写一个负责”翻译”的程序.翻译程序会理解迷你语言,并解释和运行迷你程序.这段翻译程序也被称为<strong>解释器</strong>.这样,当需要解决的问题发生变化时,不需要修改Java语言程序,只需要修改迷你语言程序即可应对.</p>
<p>如下图,我们在使用Interpreter模式后,我们就无需修改Java程序,只需修改迷你语言编写的迷你程序.</p>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/int3.png" alt></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>本程序使用自顶向下文法来解析源程序：<br>迷你语言语法(控制玩具车的迷你语言)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">program</span>&gt;</span> ::= program <span class="tag">&lt;<span class="name">Command</span> <span class="attr">List</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Command</span> <span class="attr">List</span>&gt;</span> ::= <span class="tag">&lt;<span class="name">Command</span>&gt;</span>*   end</span><br><span class="line"><span class="tag">&lt;<span class="name">Command</span>&gt;</span> ::= <span class="tag">&lt;<span class="name">Repeat</span> <span class="attr">Command</span>&gt;</span> | <span class="tag">&lt;<span class="name">Primitive</span> <span class="attr">Command</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Repeat</span> <span class="attr">Command</span>&gt;</span> ::= repeat <span class="tag">&lt;<span class="name">number</span>&gt;</span> <span class="tag">&lt;<span class="name">Command</span> <span class="attr">List</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Primitive</span> <span class="attr">Command</span>&gt;</span> ::= go | right | left</span><br></pre></td></tr></table></figure>
<ul>
<li><p>迷你程序 program repeat 4 go right end end 的语法树<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/int1.png" alt></p>
</li>
<li><p>类的一览</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">名字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Node</td>
<td align="left">表示语法树”节点”的类</td>
</tr>
<tr>
<td align="left">ProgramNode</td>
<td align="left">对应<code>&lt;program&gt;</code>的类</td>
</tr>
<tr>
<td align="left">CommandListNode</td>
<td align="left"><code>&lt;command list&gt;</code>的类</td>
</tr>
<tr>
<td align="left">CommandNode</td>
<td align="left">对应<code>&lt;command&gt;</code>的类</td>
</tr>
<tr>
<td align="left">RepeatCommandNode</td>
<td align="left">对应<code>&lt;repeat command&gt;</code>的类</td>
</tr>
<tr>
<td align="left">PrimitiveCommandNode</td>
<td align="left">对应<code>&lt;primitive command&gt;</code>的类</td>
</tr>
<tr>
<td align="left">Context</td>
<td align="left">表示语法解析上下文的类</td>
</tr>
<tr>
<td align="left">ParseException</td>
<td align="left">表示语法解析可能发生的异常的类</td>
</tr>
<tr>
<td align="left">Main</td>
<td align="left">测试程序行为的类</td>
</tr>
<tr>
<td align="left">- 示例程序类图</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/int2.png" alt></td>
<td align="left"></td>
</tr>
</tbody></table>
<ol>
<li><p>Node类</p>
</li>
<li><p>ProgramNode类:起始节点  <code>&lt;program&gt; -&gt; program &lt;Command List&gt;</code></p>
</li>
<li><p>CommandListNode类： <code>&lt;Command List&gt; -&gt; &lt;Command&gt;* end</code></p>
</li>
<li><p>CommandNode类： <code>&lt;Command&gt; -&gt; &lt;Repeat Command&gt; | &lt;Primitive Command&gt;</code></p>
</li>
<li><p>RepeatCommandNode 类：<code>&lt;Repeat Command&gt; -&gt; repeat &lt;number&gt; &lt;Command List&gt;</code></p>
</li>
<li><p>PrimitiveCommandNode类：<code>&lt;Primitive Command&gt; -&gt; go | right | left</code></p>
</li>
<li><p>Context 类，承载了词法分析的职责，为上面的语法树提供单词，遍历程序，当然没考虑到程序的注释</p>
</li>
<li><p>ParseException类：</p>
</li>
<li><p>Main类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4></li>
</ol>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/interpreter.png" alt></p>
<p>角色：AbstractExpression(抽象表达式)、TerminalExpression（终结表达式、具体实现）、NonterminalExpression(非终结表达式、具体实现)、Context（上下文，被解析对象）、Clinet(调用者)</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>解释器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Command模式</title>
    <url>/2020/04/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BCommand%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>命令也是类</p>
<a id="more"></a>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>命令也是类，将命令作为一个类来保存，当要使用的时候可以直接拿来使用，比如脚本语言写出的脚本，只需要一个命令就能执行得到我们想要的需要操作很长时间才能得到的结果。这是一个非常有意思的模式，将操作的步骤保存下来，本例之中我们使用java自带的GUI来画图，然后将画图的过程（在哪个地方画了什么东西）保存下来，可以把每一次我们的操作作为一个命令，其实就是&lt;使用什么画布，画点的坐标&gt;，将这个命令对应的对象保存到所有命令对象的集合之中去，这样命令集合就记录下来了每一个命令，如果要显示画的内容的时候，直接将这些命令组合读取出来在进行一次重画即可。通过这种模式保存下来已经执行的步骤，通过重画再复述出来，是一种非常重要的开发理念，在需要保存历史纪录并恢复的场合是非常有用的。<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/cm.png" alt></p>
<h4 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h4><ol>
<li>Command接口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>DrawCommand类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Point;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绘制对象</span></span><br><span class="line">    <span class="keyword">protected</span> Drawable drawable;</span><br><span class="line">    <span class="comment">// 绘制位置</span></span><br><span class="line">    <span class="keyword">private</span> Point position;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawCommand</span><span class="params">(Drawable drawable, Point position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawable = drawable;</span><br><span class="line">        <span class="keyword">this</span>.position = position;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        drawable.draw(position.x, position.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>MacroCommand类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Command;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacroCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 命令的集合</span></span><br><span class="line">    <span class="keyword">private</span> Stack commands = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator it = commands.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            ((Command)it.next()).execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(Command cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cmd != <span class="keyword">this</span>) &#123;</span><br><span class="line">            commands.push(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除最后一条命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!commands.empty()) &#123;</span><br><span class="line">            commands.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除所有命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        commands.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Drawable接口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>DrawCanvas 类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Command;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawCanvas</span> <span class="keyword">extends</span> <span class="title">Canvas</span> <span class="keyword">implements</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 颜色</span></span><br><span class="line">    <span class="keyword">private</span> Color color = Color.red;</span><br><span class="line">    <span class="comment">// 要绘制的圆点的半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 命令的历史记录</span></span><br><span class="line">    <span class="keyword">private</span> MacroCommand history;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawCanvas</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, MacroCommand history)</span> </span>&#123;</span><br><span class="line">        setSize(width, height);</span><br><span class="line">        setBackground(Color.white);</span><br><span class="line">        <span class="keyword">this</span>.history = history;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新全部绘制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"执行一次刷新!"</span>+System.currentTimeMillis());</span><br><span class="line">        history.execute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    	Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        Graphics g = getGraphics();</span><br><span class="line">        g.setColor((random.nextBoolean())? Color.yellow : Color.MAGENTA);</span><br><span class="line">        g.fillOval(x - radius, y - radius, radius * <span class="number">2</span>, radius * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Main类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span>, <span class="title">MouseMotionListener</span>, <span class="title">WindowListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绘制的历史记录</span></span><br><span class="line">    <span class="keyword">private</span> MacroCommand history = <span class="keyword">new</span> MacroCommand();</span><br><span class="line">    <span class="comment">// 绘制区域</span></span><br><span class="line">    <span class="keyword">private</span> DrawCanvas canvas = <span class="keyword">new</span> DrawCanvas(<span class="number">400</span>, <span class="number">400</span>, history);</span><br><span class="line">    <span class="comment">// 删除按钮</span></span><br><span class="line">    <span class="keyword">private</span> JButton clearButton  = <span class="keyword">new</span> JButton(<span class="string">"清除"</span>);</span><br><span class="line">    <span class="keyword">private</span> JButton btnRePaint=<span class="keyword">new</span> JButton(<span class="string">"重现"</span>);</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(title);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.addWindowListener(<span class="keyword">this</span>);</span><br><span class="line">        canvas.addMouseMotionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnRePaint.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        clearButton.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        Box buttonBox = <span class="keyword">new</span> Box(BoxLayout.X_AXIS);</span><br><span class="line">        buttonBox.add(clearButton);</span><br><span class="line">        buttonBox.add(btnRePaint);</span><br><span class="line">        Box mainBox = <span class="keyword">new</span> Box(BoxLayout.Y_AXIS);</span><br><span class="line">        mainBox.add(buttonBox);</span><br><span class="line">        mainBox.add(canvas);</span><br><span class="line">        getContentPane().add(mainBox);</span><br><span class="line"></span><br><span class="line">        pack();</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ActionListener接口中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.getSource() == clearButton) &#123;</span><br><span class="line">            history.clear();</span><br><span class="line">            canvas.repaint();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.getSource()==btnRePaint) &#123;</span><br><span class="line">        	canvas.repaint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MouseMotionListener接口中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseMoved</span><span class="params">(MouseEvent e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseDragged</span><span class="params">(MouseEvent e)</span> </span>&#123;</span><br><span class="line">        Command cmd = <span class="keyword">new</span> DrawCommand(canvas, e.getPoint());</span><br><span class="line">        history.append(cmd);</span><br><span class="line">        cmd.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WindowListener接口中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowActivated</span><span class="params">(WindowEvent e)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosed</span><span class="params">(WindowEvent e)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowDeactivated</span><span class="params">(WindowEvent e)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowDeiconified</span><span class="params">(WindowEvent e)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowIconified</span><span class="params">(WindowEvent e)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowOpened</span><span class="params">(WindowEvent e)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Main(<span class="string">"Command Pattern Sample"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
实现结果自行运行吧;</li>
</ol>
<h4 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h4><p>运行后,我们可以看到保存了的命令九一个个的再次执行了一遍,我们分析一下程序运行的过程</p>
<ol>
<li>开始执行初始化界面,然后显示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">(String title)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(title);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.addWindowListener(<span class="keyword">this</span>);</span><br><span class="line">        canvas.addMouseMotionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnClear.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnRePaint.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        Box btnBox=<span class="keyword">new</span> Box(BoxLayout.X_AXIS);</span><br><span class="line">        btnBox.add(btnClear);</span><br><span class="line">        btnBox.add(btnRePaint);</span><br><span class="line">        </span><br><span class="line">        Box mainBox=<span class="keyword">new</span> Box(BoxLayout.Y_AXIS);</span><br><span class="line">        mainBox.add(btnBox);</span><br><span class="line">        mainBox.add(canvas);</span><br><span class="line">        </span><br><span class="line">        getContentPane().add(mainBox);</span><br><span class="line">        </span><br><span class="line">        pack();</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>然后等待用户的操作，当监听到用户在界面上拖动鼠标的时候，执行：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseDragged</span><span class="params">(MouseEvent e)</span> </span>&#123;</span><br><span class="line">        Command cmd=<span class="keyword">new</span> DrawCommand(canvas,e.getPoint());</span><br><span class="line">        history.append(cmd);</span><br><span class="line">        cmd.execute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>创建一个命令对象,然后记录进命令堆栈之中之后我们跟踪cmd.execute();<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这里就看到我们的面向抽象编程的好处了，根本不需要知道是谁执行了我们的命令，在命令的时候自然知道了，那就是new DrawCommand(canvas,e.getPoint());<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         。。。</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        drawable.draw(position.x, position.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>我们继续跟踪：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>同理，谁实现了Drawable ，并被传递进去了，Command cmd=new DrawCommand(canvas,e.getPoint());<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        </span><br><span class="line">        Graphics g = getGraphics();</span><br><span class="line">        g.setColor((random.nextBoolean())? Color.yellow : Color.MAGENTA);</span><br><span class="line">        g.fillOval(x-radius, y-radius, radius*<span class="number">2</span>, radius*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
因此执行我们的程序，画了一个点。之后我们的鼠标不断拖动着，这个流程就一直执行着，直到我们停止为止。</li>
</ol>
<p><strong>之后我们分析重画方法:</strong><br>当用户点击按钮：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(e.getSource()==btnClear)&#123;</span><br><span class="line">            history.clear();</span><br><span class="line">            canvas.repaint();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e.getSource()==btnRePaint)&#123;</span><br><span class="line">            canvas.repaint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用 canvas.repaint();方法，这是Canvas自动实现的，我们不必深究，只需要知道这个函数之中会调用，我们的继承了Canvas并且重写的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"执行一次刷新！"</span>+System.currentTimeMillis());</span><br><span class="line">    history.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟踪： history.execute();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator it = commands.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Command command=(Command)it.next();</span><br><span class="line">            command.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到将保存的命令一个个都拿出来，重新走了一遍我们上面的command.execute();所走的流程，这就是命令模式，现在很清晰了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对于命令模式，在本例之中使用了Composite模式，迭代器等模式作为辅助，另外在生成对象的时候还可能使用原型模式，在保存命令的时候还可能使用备忘录模式。本例是一个很好的例子，从本质上说明了命令模式就是将命令抽象成一个类，通过保存接收者的引用，在后期还可以让接收者去执行，同样的使用了组合模式将这些对象一个个的保存了下来，然后一步步的调用单个命令的执行方法，该执行方法通知命令的接收者去再次执行命令，这种方式特别的方便，因为我们保存的是用户的操作，能够一直记录下来，甚至可以保存到文件之中以后可以恢复，由此可以看到命令模式的强大。</p>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/command.png" alt></p>
<ol>
<li><p>发送者 （Sender）——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。</p>
</li>
<li><p>命令 （Command） 接口通常仅声明一个执行命令的方法。</p>
</li>
<li><p>具体命令 （Concrete Commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。<br> 接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。</p>
</li>
<li><p>接收者 （Receiver） 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。</p>
</li>
<li><p>客户端 （Client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。</p>
</li>
</ol>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ol>
<li><p>声明仅有一个执行方法的命令接口。</p>
</li>
<li><p>抽取请求并使之成为实现命令接口的具体命令类。 每个类都必须有一组成员变量来保存请求参数和对于实际接收者对象的引用。 所有这些变量的数值都必须通过命令构造函数进行初始化。</p>
</li>
<li><p>找到担任发送者职责的类。 在这些类中添加保存命令的成员变量。 发送者只能通过命令接口与其命令进行交互。 发送者自身通常并不创建命令对象， 而是通过客户端代码获取。</p>
</li>
<li><p>修改发送者使其执行命令， 而非直接将请求发送给接收者。</p>
</li>
<li><p>客户端必须按照以下顺序来初始化对象：</p>
<ul>
<li>创建接收者。</li>
<li>创建命令， 如有需要可将其关联至接收者。</li>
<li>创建发送者并将其与特定命令关联。</li>
</ul>
</li>
</ol>
<p><a href="https://www.cnblogs.com/zyrblog/p/9252664.html" target="_blank" rel="noopener">精心出精品</a><br><a href="https://geek-docs.com/design-pattern/command-pattern/command-pattern-index.html" target="_blank" rel="noopener">参考文献</a><br><a href="https://www.cnblogs.com/wolf-sun/p/3618911.html?utm_source=tuicool" target="_blank" rel="noopener">Command Pattern</a><br><a href>&lt;&lt;图解设计模式&gt;&gt;</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>命令模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Proxy模式</title>
    <url>/2020/04/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BProxy%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>只在必要时生成实例</p>
<a id="more"></a>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Proxy是”代理人”的意思,它指的是代替别人进行工作的人,党不一定需要本人亲自进行工作时,就可以寻找代理人去完成工作.但代理人毕竟是代理人,能代替本人做的事请终究是有限的,因此,当代理人遇到无法自己解决的事请时就会去找本人解决该问题.</p>
<ul>
<li>例子<ul>
<li>提到代理,大家应该都会想到WEB代理,web代理位于web服务器和web客户端之间,为web页面提供高速缓存等功能.我们大致可以把他理解成代理模式.</li>
<li>猪八戒去找高翠兰结果是孙悟空变的,可以这样理解：把高翠兰的外貌抽象出来,高翠兰本人和孙悟空都实现了这个接口,猪八戒访问高翠兰的时候看不出来这个是孙悟空,所以说孙悟空是高翠兰代理类.<h4 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h4>本人去处理所有事情是非常麻烦的,特别是初始化的时候都非常的耗时,因此使用代理,不到必须自己出马的时候一直按兵不动,让代理去完成这些工作,这就是代理模式.</li>
</ul>
</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/proxy1.png" alt></p>
<ol>
<li>Printable接口:代理的同源性：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setPrinterName</span><span class="params">(String name)</span></span>;   <span class="comment">// 设置名字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getPrinterName</span><span class="params">()</span></span>;            <span class="comment">// 获取名字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span></span>;          <span class="comment">// 显示文字（打印输出）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Printer类：本人（相当于真正的服务器）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        heavyJob(<span class="string">"正在生成Printer的实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(String name)</span> </span>&#123;                   <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        heavyJob(<span class="string">"正在生成Printer的实例("</span> + name + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrinterName</span><span class="params">(String name)</span> </span>&#123;       <span class="comment">// 设置名字</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrinterName</span><span class="params">()</span> </span>&#123;                <span class="comment">// 获取名字</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span> </span>&#123;              <span class="comment">// 显示带打印机名字的文字</span></span><br><span class="line">        System.out.println(<span class="string">"=== "</span> + name + <span class="string">" ==="</span>);</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heavyJob</span><span class="params">(String msg)</span> </span>&#123;             <span class="comment">// 重活</span></span><br><span class="line">        System.out.print(msg);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"结束."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ProxyPrinter代理类：(代理服务器)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Proxy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterProxy</span> <span class="keyword">implements</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;            <span class="comment">// 名字</span></span><br><span class="line">    <span class="keyword">private</span> Printer real;           <span class="comment">// “本人”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrinterProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrinterProxy</span><span class="params">(String name)</span> </span>&#123;      <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setPrinterName</span><span class="params">(String name)</span> </span>&#123;  <span class="comment">// 设置名字</span></span><br><span class="line">        <span class="keyword">if</span> (real != <span class="keyword">null</span>) &#123;</span><br><span class="line">            real.setPrinterName(name);  <span class="comment">// 同时设置“本人”的名字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrinterName</span><span class="params">()</span> </span>&#123;    <span class="comment">// 获取名字</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span> </span>&#123;  <span class="comment">// 显示</span></span><br><span class="line">        realize();</span><br><span class="line">        real.print(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">realize</span><span class="params">()</span> </span>&#123;   <span class="comment">// 生成“本人”</span></span><br><span class="line">        <span class="keyword">if</span> (real == <span class="keyword">null</span>) &#123;</span><br><span class="line">            real = <span class="keyword">new</span> Printer(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Main(客户端)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Proxy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterProxy</span> <span class="keyword">implements</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;            <span class="comment">// 名字</span></span><br><span class="line">    <span class="keyword">private</span> Printer real;           <span class="comment">// “本人”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrinterProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrinterProxy</span><span class="params">(String name)</span> </span>&#123;      <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setPrinterName</span><span class="params">(String name)</span> </span>&#123;  <span class="comment">// 设置名字</span></span><br><span class="line">        <span class="keyword">if</span> (real != <span class="keyword">null</span>) &#123;</span><br><span class="line">            real.setPrinterName(name);  <span class="comment">// 同时设置“本人”的名字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrinterName</span><span class="params">()</span> </span>&#123;    <span class="comment">// 获取名字</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span> </span>&#123;  <span class="comment">// 显示</span></span><br><span class="line">        realize();</span><br><span class="line">        real.print(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">realize</span><span class="params">()</span> </span>&#123;   <span class="comment">// 生成“本人”</span></span><br><span class="line">        <span class="keyword">if</span> (real == <span class="keyword">null</span>) &#123;</span><br><span class="line">            real = <span class="keyword">new</span> Printer(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>时序图<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/proxy2.png" alt></li>
</ul>
<p>可以看到服务器的启动实在是太耗时了（睡眠5秒钟来表示）,那么使用代理服务器可以轻松地处理一些事务（设置名字,获得名字）,直到代理服务器无能为力的时候（print打印内容）,代理服务器就会通知服务器（本人）让服务器去处理</p>
<h4 id="谁知道谁"><a href="#谁知道谁" class="headerlink" title="谁知道谁?"></a>谁知道谁?</h4><p>从本例可以看到,代理是清楚的知道被代理的对象的,因为使用了委托机制,将Printer对象组合进来）,但是Printer是不知道代理的,它只是被启动了而已,这说明了什么？！本人（Printer）可以不做任何改动,就可以增加很多的代理去启动本人,这样非常利于可扩展性,其实这里也使用了懒加载模式,可以看到只有到不得不使用的时候才生成被代理的实例,那么可不可以直接在代理模式之中使用懒加载机制呢,答案是不利于可扩展性,没有这种分而治之的思想好,另外就是启动Printer类本身就是一种开销.同时我们看到了代理和被代理人都实现了同样的接口,这样的好处是很大的,在Main中可以随意切换,同时能够定义相同的必须的接口.这种透明性是非常有益的,在很多模式之中都有着体现.</p>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><ul>
<li>subject(主体,抽象类)</li>
<li>proxy（代理人,只有在自己不能处理的时候,才交给RealSubject去处理）</li>
<li>RealSubject(实际的主体、在代理人无法处理时出场)</li>
<li>client(调用者,可以随意调用proxy或realSubject)</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/proxy.png" alt></p>
<p>中心思想：通过设置统一的接口（subject）,使client可以不直接调用realSuject,而是通过调用proxy来实现业务功能.而在proxy里,相当于做了一层缓存,只有才必要时才调用realsubject</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>Proxy模式有很多种变化形式</p>
<ul>
<li><p>延迟初始化 （虚拟代理）.如果你有一个偶尔使用的重量级服务对象 ,一直保持该对象运行会消耗系统资源时,可使用代理模式.<br>你无需在程序启动时就创建该对象,可将对象的初始化延迟到真正有需要的时候.本例子就是个虚拟代理</p>
</li>
<li><p>访问控制 （保护代理）. 如果你只希望特定客户端使用服务对象 ,这里的对象可以是操作系统中非常重要的部分 ,而客户端则是各种已启动的程序 （包括恶意程序） ,此时可使用代理模式.<br>代理可仅在客户端凭据满足要求时将请求传递给服务对象.</p>
</li>
<li><p>本地执行远程服务 （远程代理）. 适用于服务对象位于远程服务器上的情形.</p>
<ul>
<li>在这种情形中 ,代理通过网络传递客户端请求 ,负责处理所有与网络相关的复杂细节.</li>
<li>记录日志请求 （日志记录代理）. 适用于当你需要保存对于服务对象的请求历史记录时. 代理可以在向服务传递请求前进行记录.</li>
</ul>
</li>
<li><p>缓存请求结果 （缓存代理）. 适用于需要缓存客户请求结果并对缓存生命周期进行管理时 ,特别是当返回结果的体积非常大时.  </p>
<ul>
<li>代理可对重复请求所需的相同结果进行缓存 ,还可使用请求参数作为索引缓存的键值.</li>
<li>智能引用. 可在没有客户端使用某个重量级对象时立即销毁该对象.</li>
<li>代理会将所有获取了指向服务对象或其结果的客户端记录在案. 代理会时不时地遍历各个客户端 ,检查它们是否仍在运行. 如果相应的客户端列表为空 ,代理就会销毁该服务对象 ,释放底层系统资源.</li>
<li>代理还可以记录客户端是否修改了服务对象. 其他客户端还可以复用未修改的对象.  <h4 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h4></li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>划分了proxy和realSubject两个角色,使得他们互相不影响,client可以选择单独使用realSubject或者使用代理来做,而不需要改变业务逻辑</li>
<li>因为proxy和realSubject都实现了subject接口所以client可以不必在意,使用的是哪个具体类去实现逻辑.因此proxy可以说具有透明性,透过它就像可以直接看到realSubject一样</li>
<li>远程代理使得客户端可以访问在远程机器上的对象,远程机器 可能具有更好的计算性能与处理速度,可以快速响应并处理客户端请求.</li>
<li>虚拟代理通过使用一个小对象来代表一个大对象,可以减少系 统资源的消耗,对系统进行优化并提高运行速度.</li>
<li>保护代理可以控制对真实对象的使用权限.</li>
<li>你可以在客户端毫无察觉的情况下控制服务对象.</li>
<li>开闭原则. 你可以在不对服务或客户端做出修改的情况下创建新代理.</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>由于在客户端和真实主题之间增加了代理对象,因此 有些类型的代理模式可能会造成请求的处理速度变慢.</li>
<li>实现代理模式需要额外的工作,有些代理模式的实现 非常复杂.</li>
</ul>
</li>
</ul>
<p><strong>当然,我们可以看出,还是瑕不掩瑜的</strong></p>
<h4 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h4><ul>
<li>装饰和代理有着相似的结构 ,但是其意图却非常不同. 这两个模式的构建都基于组合原则 ,也就是说一个对象应该将部分工作委派给另一个对象. 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期 ,而装饰的生成则总是由客户端进行控制.</li>
<li>适配器模式能为被封装对象提供不同的接口 ,代理模式能为对象提供相同的接口 ,装饰者模式则能为对象提供加强的接口.</li>
</ul>
<h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><ol>
<li>在示例程序中,PrinterProxy类知道Printer类.即在PrinterProxy类中显式地声明了Printer类的类名.怎样才能让其不知道Printer类呢?</li>
</ol>
<p>我们可以利用反射 将生成实例的代码改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">real = (Printable)Class.forName(className).newInstance();</span><br></pre></td></tr></table></figure>
<p>我们将修改PrinterProxy类和Main类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterProxy</span> <span class="keyword">implements</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;            <span class="comment">// 名字</span></span><br><span class="line">    <span class="keyword">private</span> Printable real;         <span class="comment">// “本人”                 </span></span><br><span class="line">    <span class="keyword">private</span> String className;       <span class="comment">// “本人”的类名       </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrinterProxy</span><span class="params">(String name, String className)</span> </span>&#123;      <span class="comment">// 构造函数     </span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.className = className;                                                 </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setPrinterName</span><span class="params">(String name)</span> </span>&#123;  <span class="comment">// 设置名字</span></span><br><span class="line">        <span class="keyword">if</span> (real != <span class="keyword">null</span>) &#123;</span><br><span class="line">            real.setPrinterName(name);  <span class="comment">// 同时设置“本人”的名字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrinterName</span><span class="params">()</span> </span>&#123;    <span class="comment">// 获取名字</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span> </span>&#123;  <span class="comment">// 显示</span></span><br><span class="line">        realize();</span><br><span class="line">        real.print(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">realize</span><span class="params">()</span> </span>&#123;   <span class="comment">// 生成“本人”</span></span><br><span class="line">        <span class="keyword">if</span> (real == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;                                                                       </span><br><span class="line">                real = (Printable)Class.forName(className).newInstance();               </span><br><span class="line">                real.setPrinterName(name);                                              </span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;                                        </span><br><span class="line">                System.err.println(<span class="string">"没有找到 "</span> + className + <span class="string">" 类."</span>);      </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;                                                     </span><br><span class="line">                e.printStackTrace();                                                    </span><br><span class="line">            &#125;                                                                           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Printable p = <span class="keyword">new</span> PrinterProxy(<span class="string">"Alice"</span>, <span class="string">"Printer"</span>);                 </span><br><span class="line">        System.out.println(<span class="string">"现在的名字是"</span> + p.getPrinterName() + <span class="string">"."</span>);</span><br><span class="line">        p.setPrinterName(<span class="string">"Bob"</span>);</span><br><span class="line">        System.out.println(<span class="string">"现在的名字是"</span> + p.getPrinterName() + <span class="string">"."</span>);</span><br><span class="line">        p.print(<span class="string">"Hello, world."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在示例程序中,PrinterProxy类的setPrinterName方法和realize方法都是synchronized方法.如果不适用synchronized方法会有什么问题呢?</li>
</ol>
<p>现成A在执行setPrinterName(“Bob”)的同时,现成B(通过print方法)调用了realize方法.这时,如果发生了线程切换,会出现PrinterProxy类的name字段的值为”Bob”,但Printer类的name确实Alice的问题<br>定义为synchronized方法,可以避免发生这样的线程切换,防止分别进行判断real字段值的处理和设置real字段值的处理.可以说synchronized方法”守护着”字段.</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Flyweight模式</title>
    <url>/2020/04/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BFlyweight%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>享元模式(Flyweight Pattern)是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/fly.png" alt><br>ps:动态规划是嘛?</p>
<a id="more"></a>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>意图:运用共享技术有效地支持大量细粒度的对象。</li>
<li>主要解决:在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</li>
<li>何时使用:<ul>
<li>系统中有大量对象。 </li>
<li>这些对象消耗大量内存。 </li>
<li>这些对象的状态大部分可以外部化。 </li>
<li>这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 </li>
<li>系统不依赖于这些对象身份，这些对象是不可分辨的。</li>
</ul>
</li>
<li>应用实例： <ul>
<li>JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 </li>
<li>数据库的数据池。<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/fly1.png" alt></li>
</ul>
</li>
</ul>
<ol>
<li>Bigchar(单个字符所表达的类)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Flyweight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigChar</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 字符名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> charname;</span><br><span class="line">    <span class="comment">// 大型字符对应的字符串(由'#' '.' '\n'组成)</span></span><br><span class="line">    <span class="keyword">private</span> String fontdata;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigChar</span><span class="params">(<span class="keyword">char</span> charname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.charname = charname;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> FileReader(<span class="string">"big"</span> + charname + <span class="string">".txt"</span>)</span><br><span class="line">            );</span><br><span class="line">            String line;</span><br><span class="line">            StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                buf.append(line);</span><br><span class="line">                buf.append(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            reader.close();</span><br><span class="line">            <span class="keyword">this</span>.fontdata = buf.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">            <span class="keyword">this</span>.fontdata = charname + <span class="string">"?"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 显示大型字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(fontdata);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>BigCharFactory类<br>我们用到了单例模式来实现BigCharFactory类,因为我们只需要一个BigCharFactory类的实例就可以了.同时我们使用synchroized关键字修饰getBigChar方法,防止多线程对 生成BigChar实例的影响.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Flyweight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigCharFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 管理已经生成的BigChar的实例</span></span><br><span class="line">    <span class="keyword">private</span> HashMap pool = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="comment">// Singleton模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BigCharFactory singleton = <span class="keyword">new</span> BigCharFactory();</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BigCharFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取唯一的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigCharFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成（共享）BigChar类的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> BigChar <span class="title">getBigChar</span><span class="params">(<span class="keyword">char</span> charname)</span> </span>&#123;</span><br><span class="line">        BigChar bc = (BigChar)pool.get(<span class="string">""</span> + charname);</span><br><span class="line">        <span class="keyword">if</span> (bc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bc = <span class="keyword">new</span> BigChar(charname); <span class="comment">// 生成BigChar的实例</span></span><br><span class="line">            pool.put(<span class="string">""</span> + charname, bc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  BigChar <span class="title">getBigCharNotUsed</span><span class="params">(<span class="keyword">char</span> name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigChar(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>BigString类<br>我们将构造函数中 设置isUsed来观察使用与不使用Flyweight的区别<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Flyweight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigString</span> </span>&#123;</span><br><span class="line">	<span class="comment">// “大型字符”的数组</span></span><br><span class="line">    <span class="keyword">private</span> BigChar [] bigchars;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigString</span><span class="params">(String word,<span class="keyword">boolean</span> isUsed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isUsed == <span class="keyword">true</span>)&#123;</span><br><span class="line">            bigchars=<span class="keyword">new</span> BigChar[word.length()];</span><br><span class="line">            BigCharFactory bf=BigCharFactory.getInstance();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.length();i++)&#123;</span><br><span class="line">                bigchars[i]=bf.getBigChar(word.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            bigchars=<span class="keyword">new</span> BigChar[word.length()];</span><br><span class="line">            BigCharFactory bf=BigCharFactory.getInstance();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.length();i++)&#123;</span><br><span class="line">                bigchars[i]=bf.getBigCharNotUsed(word.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bigchars.length;i++)&#123;</span><br><span class="line">            bigchars[i].print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Main<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Flyweight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name=<span class="string">"2222222222222222222222222222222222222222222222"</span>;</span><br><span class="line">        testMemory( name, <span class="keyword">false</span>);</span><br><span class="line">        testMemory( name, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMemory</span><span class="params">(String name,<span class="keyword">boolean</span> isUsed)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"是否使用轻量级："</span>+isUsed);</span><br><span class="line">        BigString bs=<span class="keyword">new</span> BigString(name,isUsed);</span><br><span class="line">        bs.print();</span><br><span class="line">        countMemory();</span><br><span class="line">        System.out.println(<span class="string">"================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countMemory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Runtime.getRuntime().gc();</span><br><span class="line">        System.out.println(<span class="string">"已使用内存:"</span>+(Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/fly2.png" alt><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/fly3.png" alt><br>我们对比了没有使用享元的例子，可以发现所占用的内存空间，明显使用了享元的占用的内存小，而没有使用享元的占用的内存多.并且这里我们要注意垃圾回收机制，在工厂类中，使用了HashMap来将BigChar对象保存起来，这样就形成了一个DAC（有向无环图），只要pool变量不被释放，我们使用的共享单元是不会被释放的。这样就保证了BigChar对象数组不被释放，在使用享元模式的时候一定要特别注意这种情况，因为垃圾回收器（GC）在内存占用过多的时候被唤醒，然后清理那些被再被使用的内存，采用的方式就是DAC。<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4></li>
</ol>
<ul>
<li>Flyweight(共享类，轻量级)</li>
<li>FlyweightFactory(共享类工程)</li>
<li>Client（调用者）</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/flyweight.png" alt></p>
<p><strong>中心思想：</strong>FlywightFactory通过pool(共享池)来保存共享Flyweight（单例模式），使得Flyweight可以被复用</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>享元模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之State模式</title>
    <url>/2020/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BState%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>状态模式(State Pattern)是一种行为设计模式, 让你能在一个对象的内部状态变化时改变其行为, 使其看上去就像改变了自身所属的类一样。状态模式允许一个对象在其内部状态改变时改变它的行为,对象看起来似乎修改了它的类。其别名为状态对象(Objects for States),状态模式是一种对象行为型模式。</p>
<a id="more"></a>

<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>状态模式与有限状态机的概念紧密相关.</p>
<ul>
<li>其主要思想是:<br>  在任意时刻仅可处于几种有限的状态中.在任何一个特定状态中,程序的行为都不相同,且可瞬间从一个状态切换到另一个状态.不过,根据当前状态,程序可能会切换到另外一种状态,也可能会保持当前状态不变.这些数量有限且预先定义的状态切换规则被称为转移。</li>
<li>应用实例<ul>
<li>打篮球的时候运动员可以有正常状态、不正常状态和超常状态。</li>
<li>操作系统, ready,runing,block状态.</li>
<li>编译原理的DFA M,NFA M, </li>
</ul>
</li>
<li>优点:<ul>
<li>封装了转换规则。 </li>
<li>枚举可能的状态,在枚举状态之前需要确定状态种类。 </li>
<li>将所有与某个状态有关的行为放到一个类中,并且可以方便地增加新的状态,只需要改变对象状态即可改变对象的行为。 </li>
<li>允许状态转换逻辑与状态对象合成一体,而不是某一个巨大的条件语句块。 </li>
<li>可以让多个环境对象共享一个状态对象,从而减少系统中对象的个数。</li>
</ul>
</li>
<li>缺点:<ul>
<li>状态模式的使用必然会增加系统类和对象的个数。 </li>
<li>状态模式的结构与实现都较为复杂,如果使用不当将导致程序结构和代码的混乱。 </li>
<li>状态模式对”开闭原则”的支持并不太好,对于可以切换状态的状态模式,增加新的状态类需要修改那些负责状态转换的源代码,否则无法切换到新增状态,而且修改某个状态类的行为也需修改对应类的源代码。<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4></li>
</ul>
</li>
<li>一定要用状态模式嘛?<br>其实不用也是可以的,但是考虑到代码的可维护性,可扩展性,可复用性这些层面的话,状态模式就很有用了.<br>比如,考虑一个银行系统,可以用来取款,打电话,报警,记录着四种功能,但是考虑如下需求:在白天如果我们去取款是正常的,晚上取款就要发出警报；在白天打电话有人接,晚上打电话启动留言功能；白天和晚上按警铃都会报警。那么我们应该如何设计这个程序呢,当然我们可以对每一个动作(作为一个函数),在这个函数内部,我们进行判断是白天还是黑夜,然后根据具体的情况做出反应。这样当然是可以的,但是假如我们的状态(白天和黑夜)非常的多呢,比如将24小时分成24个时间段(24个状态),那么我们对于每一个函数就要判断24遍,这无疑是非常糟糕的代码,可读性非常的差,并且如果需求发生了改变,我们很难去修改代码(很容易出现错误),但是如果我们考虑将这些状态都作为一个类,在每一个类内部进行处理、判断和相应的切换,这样思路就非常的清晰,如果再增加一种状态,代码需要修改的地方会非常的少,对于状态非常多的情景来说非常的方便。</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/state2.png" alt></p>
<ol>
<li>Context接口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.State;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setClock</span><span class="params">(<span class="keyword">int</span> hour)</span></span>;                <span class="comment">// 设置时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">(State state)</span></span>;          <span class="comment">// 改变状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">callSecurityCenter</span><span class="params">(String msg)</span></span>;    <span class="comment">// 联系警报中心</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">recordLog</span><span class="params">(String msg)</span></span>;             <span class="comment">// 在警报中心留下记录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>SafeFrame实现类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.State;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Frame;</span><br><span class="line"><span class="keyword">import</span> java.awt.Label;</span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Button;</span><br><span class="line"><span class="keyword">import</span> java.awt.TextField;</span><br><span class="line"><span class="keyword">import</span> java.awt.TextArea;</span><br><span class="line"><span class="keyword">import</span> java.awt.Panel;</span><br><span class="line"><span class="keyword">import</span> java.awt.BorderLayout;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeFrame</span> <span class="keyword">extends</span> <span class="title">Frame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span>, <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TextField textClock = <span class="keyword">new</span> TextField(<span class="number">60</span>);        <span class="comment">// 显示当前时间</span></span><br><span class="line">    <span class="keyword">private</span> TextArea textScreen = <span class="keyword">new</span> TextArea(<span class="number">10</span>, <span class="number">60</span>);     <span class="comment">// 显示警报中心的记录</span></span><br><span class="line">    <span class="keyword">private</span> Button buttonUse = <span class="keyword">new</span> Button(<span class="string">"使用金库"</span>);      <span class="comment">// 金库使用按钮</span></span><br><span class="line">    <span class="keyword">private</span> Button buttonAlarm = <span class="keyword">new</span> Button(<span class="string">"按下警铃"</span>);    <span class="comment">// 按下警铃按钮</span></span><br><span class="line">    <span class="keyword">private</span> Button buttonPhone = <span class="keyword">new</span> Button(<span class="string">"正常通话"</span>);    <span class="comment">// 正常通话按钮</span></span><br><span class="line">    <span class="keyword">private</span> Button buttonExit = <span class="keyword">new</span> Button(<span class="string">"结束"</span>);         <span class="comment">// 结束按钮</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> State state = DayState.getInstance();           <span class="comment">// 当前的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafeFrame</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(title);</span><br><span class="line">        setBackground(Color.lightGray);</span><br><span class="line">        setLayout(<span class="keyword">new</span> BorderLayout());</span><br><span class="line">        <span class="comment">//  配置textClock</span></span><br><span class="line">        add(textClock, BorderLayout.NORTH);</span><br><span class="line">        textClock.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 配置textScreen</span></span><br><span class="line">        add(textScreen, BorderLayout.CENTER);</span><br><span class="line">        textScreen.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 为界面添加按钮</span></span><br><span class="line">        Panel panel = <span class="keyword">new</span> Panel();</span><br><span class="line">        panel.add(buttonUse);</span><br><span class="line">        panel.add(buttonAlarm);</span><br><span class="line">        panel.add(buttonPhone);</span><br><span class="line">        panel.add(buttonExit);</span><br><span class="line">        <span class="comment">// 配置界面</span></span><br><span class="line">        add(panel, BorderLayout.SOUTH);</span><br><span class="line">        <span class="comment">// 显示</span></span><br><span class="line">        pack();</span><br><span class="line">        show();</span><br><span class="line">        <span class="comment">// 设置监听器</span></span><br><span class="line">        buttonUse.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        buttonAlarm.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        buttonPhone.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        buttonExit.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按钮被按下后该方法会被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e.toString());</span><br><span class="line">        <span class="keyword">if</span> (e.getSource() == buttonUse) &#123;           <span class="comment">// 金库使用按钮</span></span><br><span class="line">            state.doUse(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getSource() == buttonAlarm) &#123;  <span class="comment">// 按下警铃按钮</span></span><br><span class="line">            state.doAlarm(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getSource() == buttonPhone) &#123;  <span class="comment">// 正常通话按钮</span></span><br><span class="line">            state.doPhone(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getSource() == buttonExit) &#123;   <span class="comment">// 结束按钮</span></span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"未预料错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClock</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;</span><br><span class="line">        String clockstring = <span class="string">"现在时间是"</span>;</span><br><span class="line">        <span class="keyword">if</span> (hour &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            clockstring += <span class="string">"0"</span> + hour + <span class="string">":00"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clockstring += hour + <span class="string">":00"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(clockstring);</span><br><span class="line">        textClock.setText(clockstring);</span><br><span class="line">        state.doClock(<span class="keyword">this</span>, hour);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改变状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"从"</span> + <span class="keyword">this</span>.state + <span class="string">"状态变为了"</span> + state + <span class="string">"状态。"</span>);</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 联系警报中心</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callSecurityCenter</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        textScreen.append(<span class="string">"call! "</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在警报中心留下记录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordLog</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        textScreen.append(<span class="string">"record ... "</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>State接口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.State;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doClock</span><span class="params">(Context context, <span class="keyword">int</span> hour)</span></span>;    <span class="comment">// 设置时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doUse</span><span class="params">(Context context)</span></span>;                <span class="comment">// 使用金库</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doAlarm</span><span class="params">(Context context)</span></span>;              <span class="comment">// 按下警铃</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doPhone</span><span class="params">(Context context)</span></span>;              <span class="comment">// 正常通话</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>NightState实现类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.State;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NightState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NightState singleton = <span class="keyword">new</span> NightState();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NightState</span><span class="params">()</span> </span>&#123;                              <span class="comment">// 构造函数的可见性是private</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> State <span class="title">getInstance</span><span class="params">()</span> </span>&#123;                 <span class="comment">// 获取唯一实例</span></span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClock</span><span class="params">(Context context, <span class="keyword">int</span> hour)</span> </span>&#123;    <span class="comment">// 设置时间</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">9</span> &lt;= hour &amp;&amp; hour &lt; <span class="number">17</span>) &#123;</span><br><span class="line">            context.changeState(DayState.getInstance());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUse</span><span class="params">(Context context)</span> </span>&#123;                <span class="comment">// 使用金库</span></span><br><span class="line">        context.callSecurityCenter(<span class="string">"紧急：晚上使用金库！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAlarm</span><span class="params">(Context context)</span> </span>&#123;              <span class="comment">// 按下警铃</span></span><br><span class="line">        context.callSecurityCenter(<span class="string">"按下警铃(晚上)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPhone</span><span class="params">(Context context)</span> </span>&#123;              <span class="comment">// 正常通话</span></span><br><span class="line">        context.recordLog(<span class="string">"晚上的通话录音"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;                          <span class="comment">// 显示表示类的文字</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[晚上]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>DayState实现类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.State;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DayState singleton = <span class="keyword">new</span> DayState();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DayState</span><span class="params">()</span> </span>&#123;                                <span class="comment">// 构造函数的可见性是private</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> State <span class="title">getInstance</span><span class="params">()</span> </span>&#123;                 <span class="comment">// 获取唯一实例</span></span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClock</span><span class="params">(Context context, <span class="keyword">int</span> hour)</span> </span>&#123;    <span class="comment">// 设置时间</span></span><br><span class="line">        <span class="keyword">if</span> (hour &lt; <span class="number">9</span> || <span class="number">17</span> &lt;= hour) &#123;</span><br><span class="line">            context.changeState(NightState.getInstance());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUse</span><span class="params">(Context context)</span> </span>&#123;                <span class="comment">// 使用金库</span></span><br><span class="line">        context.recordLog(<span class="string">"使用金库(白天)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAlarm</span><span class="params">(Context context)</span> </span>&#123;              <span class="comment">// 按下警铃</span></span><br><span class="line">        context.callSecurityCenter(<span class="string">"按下警铃(白天)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPhone</span><span class="params">(Context context)</span> </span>&#123;              <span class="comment">// 正常通话</span></span><br><span class="line">        context.callSecurityCenter(<span class="string">"正常通话(白天)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;                          <span class="comment">// 显示表示类的文字</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[白天]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Main类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.State;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SafeFrame frame = <span class="keyword">new</span> SafeFrame(<span class="string">"State Sample"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> hour = <span class="number">0</span>; hour &lt; <span class="number">24</span>; hour++) &#123;</span><br><span class="line">                frame.setClock(hour);   <span class="comment">// 设置时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>可以看到状态模式的强大威力，是用最简洁的代码通过接口、抽象类、普通类、继承、委托、代理模式等方式，将状态抽象为类，然后通过控制状态的逻辑委托不同的状态去做不同的事情，对于每一个状态来说又再次委托控制状态的逻辑做出相应的动作和修改，这样看起来比较复杂，其实仔细阅读就会发现因为接口（抽象类）的原因，使得程序非常的简洁，各个状态分工明确，密切配合。</li>
<li>但是状态模式也有一些缺点，正是因为各个状态密切配合，在一个状态之中要知道其他状态的对象，这就造成了一定的关联，状态与状态之间是一种紧耦合的关系，这是状态模式的一点缺点，针对于这一点，我们可以将状态迁移的代码统一交给SafeFrame来做，这样就要使用到了Mediator仲裁者模式了。</li>
<li>使用单例的原因是如果一直创造新的对象会对内存产生浪费，因此单例即可。同样的使用状态模式通过接口使用state变量来表示相应的状态，不会产生混淆和矛盾，相比于使用多个变量来分区间表示状态来说是非常清晰简练的。State模式便于增加新的状态（也需要修改其他状态的状态迁移代码），不便于增加新的“依赖于状态的处理”，比如doAlarm等，因为一旦增加了，实现了State接口的所有状态都要增加该部分代码。</li>
<li>同时我们也看到了实例的多面性，比如SafeFrame实例实现了ActionListener接口和Context接口，那么就可以将new SafeFrame()对象传入fun1(ActionListener a)和fun2(Context context)这两个方法之中，之后这两个方法对该对象的使用是不同的，权限也不一样，因此多接口就会产生多面性。状态模式其实是用了分而治之的思想，将不同的状态分开来讨论，抽取共同性，从而使问题变得简单。</li>
</ul>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><ol>
<li><p>下文 (Context) 保存了对于一个具体状态对象的引用, 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互, 且会提供一个设置器用于传递新的状态对象。</p>
</li>
<li><p>状态 (State) 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解, 因为你不希望某些状态所拥有的方法永远不会被调用。</p>
</li>
<li><p>具体状态 (Concrete States) 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码, 你可以提供一个封装有部分通用行为的中间抽象类。<br> 状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息, 并且能触发状态转移。</p>
</li>
<li><p>上下文和具体状态都可以设置上下文的下个状态, 并可通过替换连接到上下文的状态对象来完成实际的状态转换。</p>
</li>
</ol>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/state1.png" alt></p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ol>
<li>确定哪些类是上下文。 它可能是包含依赖于状态的代码的已有类； 如果特定于状态的代码分散在多个类中, 那么它可能是一个新的类。</li>
<li>声明状态接口。 虽然你可能会需要完全复制上下文中声明的所有方法, 但最好是仅把关注点放在那些可能包含特定于状态的行为的方法上。</li>
<li>为每个实际状态创建一个继承于状态接口的类。 然后检查上下文中的方法并将与特定状态相关的所有代码抽取到新建的类中。<br> 在将代码移动到状态类的过程中, 你可能会发现它依赖于上下文中的一些私有成员。 你可以采用以下几种变通方式：<ul>
<li>将这些成员变量或方法设为公有。</li>
<li>将需要抽取的上下文行为更改为上下文中的公有方法, 然后在状态类中调用。 这种方式简陋却便捷, 你可以稍后再对其进行修补。</li>
<li>将状态类嵌套在上下文类中。 这种方式需要你所使用的编程语言支持嵌套类。</li>
</ul>
</li>
<li>在上下文类中添加一个状态接口类型的引用成员变量, 以及一个用于修改该成员变量值的公有设置器。</li>
<li>再次检查上下文中的方法, 将空的条件语句替换为相应的状态对象方法。</li>
<li>为切换上下文状态, 你需要创建某个状态类实例并将其传递给上下文。 你可以在上下文、 各种状态或客户端中完成这项工作。 无论在何处完成这项工作, 该类都将依赖于其所实例化的具体类。<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4>状态模式将根据当前回放状态, 让媒体播放器中的相同控件完成不同的行为。<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/state.png" alt><br>使用状态对象更改对象行为的示例<br>播放器的主要对象总是会连接到一个负责播放器绝大部分工作的状态对象中。 部分操作会更换播放器当前的状态对象, 以此改变播放器对于用户互动所作出的反应。<br>根据伪代码及类图实现状态模式.</li>
</ol>
<ul>
<li>伪代码<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">// 音频播放器(Audio­Player)类即为上下文。它还会维护指向状态类实例的引用,</span><br><span class="line">// 该状态类则用于表示音频播放器当前的状态。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudioPlayer</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">field</span> <span class="title">state</span>:</span> State</span><br><span class="line">    field UI, volume, playlist, currentSong</span><br><span class="line"></span><br><span class="line">    constructor AudioPlayer() <span class="keyword">is</span></span><br><span class="line">        this.state = new ReadyState(this)</span><br><span class="line"></span><br><span class="line">        // 上下文会将处理用户输入的工作委派给状态对象。由于每个状态都以不</span><br><span class="line">        // 同的方式处理输入,其结果自然将依赖于当前所处的状态。</span><br><span class="line">        UI = new UserInterface()</span><br><span class="line">        UI.lockButton.onClick(this.clickLock)</span><br><span class="line">        UI.playButton.onClick(this.clickPlay)</span><br><span class="line">        UI.nextButton.onClick(this.clickNext)</span><br><span class="line">        UI.prevButton.onClick(this.clickPrevious)</span><br><span class="line"></span><br><span class="line">    // 其他对象必须能切换音频播放器当前所处的状态。</span><br><span class="line">    method changeState(state: State) <span class="keyword">is</span></span><br><span class="line">        this.state = state</span><br><span class="line"></span><br><span class="line">    // UI 方法会将执行工作委派给当前状态。</span><br><span class="line">    method clickLock() <span class="keyword">is</span></span><br><span class="line">        state.clickLock()</span><br><span class="line">    method clickPlay() <span class="keyword">is</span></span><br><span class="line">        state.clickPlay()</span><br><span class="line">    method clickNext() <span class="keyword">is</span></span><br><span class="line">        state.clickNext()</span><br><span class="line">    method clickPrevious() <span class="keyword">is</span></span><br><span class="line">        state.clickPrevious()</span><br><span class="line"></span><br><span class="line">    // 状态可调用上下文的一些服务方法。</span><br><span class="line">    method startPlayback() <span class="keyword">is</span></span><br><span class="line">        // ...</span><br><span class="line">    method stopPlayback() <span class="keyword">is</span></span><br><span class="line">        // ...</span><br><span class="line">    method nextSong() <span class="keyword">is</span></span><br><span class="line">        // ...</span><br><span class="line">    method previousSong() <span class="keyword">is</span></span><br><span class="line">        // ...</span><br><span class="line">    method fastForward(time) <span class="keyword">is</span></span><br><span class="line">        // ...</span><br><span class="line">    method rewind(time) <span class="keyword">is</span></span><br><span class="line">        // ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 所有具体状态类都必须实现状态基类声明的方法,并提供反向引用指向与状态相</span><br><span class="line">// 关的上下文对象。状态可使用反向引用将上下文转换为另一个状态。</span><br><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">State</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">protected</span> <span class="title">field</span> <span class="title">player</span>:</span> AudioPlayer</span><br><span class="line"></span><br><span class="line">    // 上下文将自身传递给状态构造函数。这可帮助状态在需要时获取一些有用的</span><br><span class="line">    // 上下文数据。</span><br><span class="line">    constructor State(player) <span class="keyword">is</span></span><br><span class="line">        this.player = player</span><br><span class="line"></span><br><span class="line">    abstract method clickLock()</span><br><span class="line">    abstract method clickPlay()</span><br><span class="line">    abstract method clickNext()</span><br><span class="line">    abstract method clickPrevious()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 具体状态会实现与上下文状态相关的多种行为。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockedState</span> <span class="title">extends</span> <span class="title">State</span> <span class="title">is</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">    // 当你解锁一个锁定的播放器时,它可能处于两种状态之一。</span><br><span class="line">    method clickLock() <span class="keyword">is</span></span><br><span class="line">        <span class="keyword">if</span> (player.playing)</span><br><span class="line">            player.changeState(new PlayingState(player))</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            player.changeState(new ReadyState(player))</span><br><span class="line"></span><br><span class="line">    method clickPlay() <span class="keyword">is</span></span><br><span class="line">        // 已锁定,什么也不做。</span><br><span class="line"></span><br><span class="line">    method clickNext() <span class="keyword">is</span></span><br><span class="line">        // 已锁定,什么也不做。</span><br><span class="line"></span><br><span class="line">    method clickPrevious() <span class="keyword">is</span></span><br><span class="line">        // 已锁定,什么也不做。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 它们还可在上下文中触发状态转换。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadyState</span> <span class="title">extends</span> <span class="title">State</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">clickLock</span><span class="params">()</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">player</span>.<span class="title">changeState</span><span class="params">(new LockedState<span class="params">(player)</span>)</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">clickPlay</span><span class="params">()</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">player</span>.<span class="title">startPlayback</span><span class="params">()</span></span></span><br><span class="line"><span class="class">        <span class="title">player</span>.<span class="title">changeState</span><span class="params">(new PlayingState<span class="params">(player)</span>)</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">clickNext</span><span class="params">()</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">player</span>.<span class="title">nextSong</span><span class="params">()</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">clickPrevious</span><span class="params">()</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">player</span>.<span class="title">previousSong</span><span class="params">()</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">PlayingState</span> <span class="title">extends</span> <span class="title">State</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">clickLock</span><span class="params">()</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">player</span>.<span class="title">changeState</span><span class="params">(new LockedState<span class="params">(player)</span>)</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">clickPlay</span><span class="params">()</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">player</span>.<span class="title">stopPlayback</span><span class="params">()</span></span></span><br><span class="line"><span class="class">        <span class="title">player</span>.<span class="title">changeState</span><span class="params">(new ReadyState<span class="params">(player)</span>)</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">clickNext</span><span class="params">()</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">if</span> <span class="params">(event.doubleclick)</span></span></span><br><span class="line"><span class="class">            <span class="title">player</span>.<span class="title">nextSong</span><span class="params">()</span></span></span><br><span class="line"><span class="class">        <span class="title">else</span></span></span><br><span class="line"><span class="class">            <span class="title">player</span>.<span class="title">fastForward</span><span class="params">(<span class="number">5</span>)</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">clickPrevious</span><span class="params">()</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">if</span> <span class="params">(event.doubleclick)</span></span></span><br><span class="line"><span class="class">            <span class="title">player</span>.<span class="title">previous</span><span class="params">()</span></span></span><br><span class="line"><span class="class">        <span class="title">else</span></span></span><br><span class="line"><span class="class">            <span class="title">player</span>.<span class="title">rewind</span><span class="params">(<span class="number">5</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>状态模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Memento模式</title>
    <url>/2020/04/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BMemento%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>备忘录模式用于保存和会复发对象的状态.比如在玩游戏的时候有一个保存当前闯关的状态的功能,会对当前用户所处的状态进行保存,当用户闯关失败或者需要从快照的地方开始的时候,就能读取当时保存的状态完整的恢复到当前的环境,这一点和VMware上面的快照功能很类似.</p>
<a id="more"></a>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h4 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h4><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/men.png" alt></p>
<ol>
<li>Memento.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Memento.game;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> money; <span class="comment">// 所持金钱</span></span><br><span class="line">	ArrayList fruits; <span class="comment">// 当前获得的水果</span></span><br><span class="line">	<span class="comment">// 窄接口,访问部分信息</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取当前所持金钱（narrow interface）</span></span><br><span class="line">		<span class="keyword">return</span> money;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//宽接口,本包内皆可访问    </span></span><br><span class="line">	Memento(<span class="keyword">int</span> money) &#123; <span class="comment">// 构造函数(wide interface)</span></span><br><span class="line">		<span class="keyword">this</span>.money = money;</span><br><span class="line">		<span class="keyword">this</span>.fruits = <span class="keyword">new</span> ArrayList();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 宽接口,本包内皆可访问</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFruit</span><span class="params">(String fruit)</span> </span>&#123; <span class="comment">// 添加水果(wide interface)</span></span><br><span class="line">		fruits.add(fruit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 宽接口,本包内皆可访问</span></span><br><span class="line">	<span class="function">List <span class="title">getFruits</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取当前所持所有水果（wide interface）</span></span><br><span class="line">		<span class="keyword">return</span> (List) fruits.clone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Gamer<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Memento.game;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gamer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;                          <span class="comment">// 所持金钱</span></span><br><span class="line">    <span class="keyword">private</span> List fruits = <span class="keyword">new</span> ArrayList();      <span class="comment">// 获得的水果</span></span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();       <span class="comment">// 随机数生成器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] fruitsname = &#123;      <span class="comment">// 表示水果种类的数组</span></span><br><span class="line">        <span class="string">"苹果"</span>, <span class="string">"葡萄"</span>, <span class="string">"香蕉"</span>, <span class="string">"橘子"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Gamer</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;                   <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;                     <span class="comment">// 获取当前所持金钱</span></span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bet</span><span class="params">()</span> </span>&#123;                         <span class="comment">// 投掷骰子进行游戏</span></span><br><span class="line">        <span class="keyword">int</span> dice = random.nextInt(<span class="number">6</span>) + <span class="number">1</span>;           <span class="comment">// 掷骰子</span></span><br><span class="line">        <span class="keyword">if</span> (dice == <span class="number">1</span>) &#123;                            <span class="comment">// 骰子结果为1…增加所持金钱</span></span><br><span class="line">            money += <span class="number">100</span>;</span><br><span class="line">            System.out.println(<span class="string">"所持金钱增加了。"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dice == <span class="number">2</span>) &#123;                     <span class="comment">// 骰子结果为2…所持金钱减半</span></span><br><span class="line">            money /= <span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">"所持金钱减半了。"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dice == <span class="number">6</span>) &#123;                     <span class="comment">// 骰子结果为6…获得水果</span></span><br><span class="line">            String f = getFruit();</span><br><span class="line">            System.out.println(<span class="string">"获得了水果("</span> + f + <span class="string">")。"</span>);</span><br><span class="line">            fruits.add(f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                    <span class="comment">// 骰子结果为3、4、5则什么都不会发生</span></span><br><span class="line">            System.out.println(<span class="string">"什么都没有发生。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span> </span>&#123;                <span class="comment">// 拍摄快照</span></span><br><span class="line">        Memento m = <span class="keyword">new</span> Memento(money);</span><br><span class="line">        Iterator it = fruits.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            String f = (String)it.next();</span><br><span class="line">            <span class="keyword">if</span> (f.startsWith(<span class="string">"好吃的"</span>)) &#123;         <span class="comment">// 只保存好吃的水果</span></span><br><span class="line">                m.addFruit(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento memento)</span> </span>&#123;   <span class="comment">// 撤销</span></span><br><span class="line">        <span class="keyword">this</span>.money = memento.money;</span><br><span class="line">        <span class="keyword">this</span>.fruits = memento.getFruits();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;                      <span class="comment">// 用字符串表示主人公状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[money = "</span> + money + <span class="string">", fruits = "</span> + fruits + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getFruit</span><span class="params">()</span> </span>&#123;                     <span class="comment">// 获得一个水果</span></span><br><span class="line">        String prefix = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (random.nextBoolean()) &#123;</span><br><span class="line">            prefix = <span class="string">"好吃的"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix + fruitsname[random.nextInt(fruitsname.length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Main<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Memento;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Memento.game.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Gamer gamer = <span class="keyword">new</span> Gamer(<span class="number">100</span>);               <span class="comment">// 最初的所持金钱数为100</span></span><br><span class="line">        Memento memento = gamer.createMemento();    <span class="comment">// 保存最初的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"==== "</span> + i);        <span class="comment">// 显示掷骰子的次数</span></span><br><span class="line">            System.out.println(<span class="string">"当前状态:"</span> + gamer);    <span class="comment">// 显示主人公现在的状态</span></span><br><span class="line"></span><br><span class="line">            gamer.bet();    <span class="comment">// 进行游戏 </span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"所持金钱为"</span> + gamer.getMoney() + <span class="string">"元。"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 决定如何处理Memento</span></span><br><span class="line">            <span class="keyword">if</span> (gamer.getMoney() &gt; memento.getMoney()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"    （所持金钱增加了许多，因此保存游戏当前的状态）"</span>);</span><br><span class="line">                memento = gamer.createMemento();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gamer.getMoney() &lt; memento.getMoney() / <span class="number">2</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"    （所持金钱减少了许多，因此将游戏恢复至以前的状态）"</span>);</span><br><span class="line">                gamer.restoreMemento(memento);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待一段时间</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
游戏的功能是根据循环次数随机生成1~6六个数,如果数字是1,则金钱加一百,如果是2,则金钱减半,如果是6,则随机生成水果,水果分为好吃和不好吃的,在保存的时候只保存好吃的水果,恢复的时候就只有好吃的水果了.当金钱少于当前备忘录中的金钱的一半时的时候就要恢复到备忘录的状态,当金钱大于备忘录状态的时候就要备份当前的状态,备份的时候只备份好吃的水果以及当前金额.</li>
</ol>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><ul>
<li><p>Originator(生成者，被保存的对象)</p>
</li>
<li><p>Memento(纪念品，存档)<br>  Memento角色会将Originator角色的内部信息整合在一起,在Memento角色中虽然保存了Originator角色的信息,但它不会向外部公开这些信息.<br>  Memento 角色有一下两种接口(API)</p>
<ul>
<li><p>宽接口<br>Memento角色提供的宽接口时指所有用于获取恢复对象状态信息的方法的集合.由于宽接口会暴露所有Memento角色的内部信息,因此能够使用宽接口的只有Originator角色</p>
</li>
<li><p>窄接口<br>为外部的Caretaker角色提供了窄接口.可以通过窄接口获取Memento角色的内部信息非常有限,因此可以有效地方志信息泄露.</p>
<p>通过对外提供两种接口,可以有效地防止对象的封装性被破坏.</p>
</li>
</ul>
</li>
<li><p>Caretaker（责任人，调用者）</p>
</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/memento.png" alt></p>
<h4 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h4><ol>
<li>原型模式也能保存一个对象在某一个时刻的状态，但是原型模式保存的是当前对象的所有状态信息，恢复的时候会生成与保存的对象完全相同的另外一个实例；而备忘录模式保存的是我们关心的在恢复时需要的对象的部分状态信息，相当于快照。</li>
</ol>
<p><a href="https://www.jianshu.com/p/714dc05feb12" target="_blank" rel="noopener">备忘录模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>备忘录模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Observer模式</title>
    <url>/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BObserver%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。<br>观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p>
<a id="more"></a>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li><p>意图:定义对象的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动更新.</p>
</li>
<li><p>应用实例:</p>
<ul>
<li>当一个对象状态的改变需要改变其他对象,或实际对象是事先未知的或动态变化的时,可使用观察者模式。<br>Android开发的过程,监听</li>
<li>当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。<br>订阅列表是动态的， 因此订阅者可随时加入或离开该列表。</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>开闭原则。 你无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）.</li>
<li>你可以在运行时建立对象之间的联系。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4></li>
</ul>
</li>
</ul>
<ol>
<li><p>仔细检查你的业务逻辑， 试着将其拆分为两个部分： 独立于其他代码的核心功能将作为发布者； 其他代码则将转化为一组订阅类。</p>
</li>
<li><p>声明订阅者接口。 该接口至少应声明一个 update方法。</p>
</li>
<li><p>声明发布者接口并定义一些接口来在列表中添加和删除订阅对象。 记住发布者必须仅通过订阅者接口与它们进行交互。</p>
</li>
<li><p>确定存放实际订阅列表的位置并实现订阅方法。 通常所有类型的发布者代码看上去都一样， 因此将列表放置在直接扩展自发布者接口的抽象类中是显而易见的。 具体发布者会扩展该类从而继承所有的订阅行为。</p>
</li>
<li><p>创建具体发布者类。 每次发布者发生了重要事件时都必须通知所有的订阅者。</p>
</li>
<li><p>在具体订阅者类中实现通知更新的方法。 绝大部分订阅者需要一些与事件相关的上下文数据。 这些数据可作为通知方法的参数来传递。<br> 但还有另一种选择。 订阅者接收到通知后直接从通知中获取所有数据。 在这种情况下， 发布者必须通过更新方法将自身传递出去。 另一种不太灵活的方式是通过构造函数将发布者与订阅者永久性地连接起来。</p>
</li>
<li><p>客户端必须生成所需的全部订阅者， 并在相应的发布者处完成注册工作。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/obse.png" alt></p>
</li>
<li><p>Observer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(NumberGenerator generator)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>NumberGenerator.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();        <span class="comment">// 保存Observer们</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span> </span>&#123;    <span class="comment">// 注册Observer</span></span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer observer)</span> </span>&#123; <span class="comment">// 删除Observer</span></span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;               <span class="comment">// 向Observer发送通知</span></span><br><span class="line">        Iterator it = observers.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Observer o = (Observer)it.next();</span><br><span class="line">            o.update(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;                <span class="comment">// 获取数值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;                 <span class="comment">// 生成数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>RandomNumberGenerator.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomNumberGenerator</span> <span class="keyword">extends</span> <span class="title">NumberGenerator</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Random random = <span class="keyword">new</span> Random(); <span class="comment">// 随机数生成器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> number; <span class="comment">// 当前数值</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取当前数值</span></span><br><span class="line">		<span class="keyword">return</span> number;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">			number = random.nextInt(<span class="number">50</span>);</span><br><span class="line">			notifyObservers();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>DigitObserver.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DigitObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(NumberGenerator generator)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DigitObserver:"</span> + generator.getNumber());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>GraphObserver.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(NumberGenerator generator)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"GraphObserver:"</span>);</span><br><span class="line">        <span class="keyword">int</span> count = generator.getNumber();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">"*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NumberGenerator generator = <span class="keyword">new</span> RandomNumberGenerator();</span><br><span class="line">        Observer observer1 = <span class="keyword">new</span> DigitObserver();</span><br><span class="line">        Observer observer2 = <span class="keyword">new</span> GraphObserver();</span><br><span class="line">        generator.addObserver(observer1);</span><br><span class="line">        generator.addObserver(observer2);</span><br><span class="line">        generator.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><ul>
<li><p>Subject(观察对象，抽象类)<br>Subject角色表示观察对象,Subject角色定义了注册观察者和删除观察者的方法.此外,它还声明了”获取现在的状态”的方法.</p>
</li>
<li><p>ConcreteSuject(具体的观察对象)<br>具体的被观察对象,当自身状态发生变化后,它会通知所有已经注册的Observer角色.</p>
</li>
<li><p>Observer(观察者)<br>Observer角色负责接受来自Subject角色的状态变化的通知.为此,它声明了update方法.在示例程序中,由Observer接口扮演此角色.</p>
</li>
<li><p>ConcreteObserver(具体的观察者)<br>表示具体的Observer.当它的update方法被调用后,会去获取要观察的对象的最新状态.</p>
</li>
<li><p>Observer模式的类图<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/observer.png" alt></p>
</li>
</ul>
<h4 id="可替换性"><a href="#可替换性" class="headerlink" title="可替换性"></a>可替换性</h4><ul>
<li>利用抽象类和接口从具体类中抽象方法</li>
<li>在将实例作为参数传递至类中,或者在类的字段中保存实例时,不使用具体类型,而是使用抽象类型和接口</li>
</ul>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>这个例子中就将发布者与订阅者永久性地连接起来。<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/obser.jpg" alt></p>
<ol>
<li><p>Subject.java<br>这里为了简单,没有使用ConcreteSuject.如果需要课自行修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Observer2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">		observers.add(observer);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">		observers.remove(observer);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//		Iterator&lt;Observer&gt; it = observers.iterator();</span></span><br><span class="line"><span class="comment">//		while(it.hasNext()) &#123;</span></span><br><span class="line"><span class="comment">//			Observer ob = it.next();</span></span><br><span class="line"><span class="comment">//			ob.update();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="keyword">for</span>(Observer observer: observers) &#123;</span><br><span class="line">			observer.update();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state =state;</span><br><span class="line">		notifyObservers();</span><br><span class="line">	&#125;</span><br><span class="line">			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Observer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Observer2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> Subject subject;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HexObserver.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Observer2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.subject = subject;</span><br><span class="line">		<span class="keyword">this</span>.subject.addObserver(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Binary String: "</span> + Integer.toBinaryString(subject.getState()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>OctObserver.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Observer2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OctObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OctObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">		      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">		      <span class="keyword">this</span>.subject.addObserver(<span class="keyword">this</span>);</span><br><span class="line">		   &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Octal String: "</span> + Integer.toOctalString(subject.getState()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>HexObserver.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Observer2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HexObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HexObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">		      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">		      <span class="keyword">this</span>.subject.addObserver(<span class="keyword">this</span>);</span><br><span class="line">		   &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hex String: "</span> + Integer.toHexString(subject.getState()).toUpperCase());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Observer2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> HexObserver(subject);</span><br><span class="line">		<span class="keyword">new</span> OctObserver(subject);</span><br><span class="line">		<span class="keyword">new</span> BinaryObserver(subject);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"First state change: 15"</span>);</span><br><span class="line">		subject.setState(<span class="number">15</span>);</span><br><span class="line">		System.out.println(<span class="string">"Second state change: 10"</span>);</span><br><span class="line">		subject.setState(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Mediator模式</title>
    <url>/2020/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BMediator%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>Mediator模式又称为仲裁者模式或者中介者模式，所起的作用是仲裁和中介，帮助其它类之间进行交流。在仲裁者模式之中，我们要明确两个概念，那就是仲裁者（Mediator）和组员（Colleague），不管组员有什么事情，都会向仲裁者汇报，仲裁者会根据全局的实际情况向其他Colleague作出指示，共同完成一定的逻辑功能。 </p>
<a id="more"></a>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>意图:用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br>简单说就是封装对象之间的交互.</li>
<li>主要解决了:对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</li>
<li>应用实例:MVC 框架,其中C（控制器）就是 M（模型）和 V（视图）的中介者。</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>示例1:<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mediator.jpg" alt><br>ChatRoom.java (仲裁者)<br>收到族权的汇报,后处理<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Mediator.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRoom</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(User user, String message)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="keyword">new</span> Date().toString()</span><br><span class="line">         + <span class="string">" ["</span> + user.getName() +<span class="string">"] : "</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
User.java(同事类)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Mediator.demo2;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name  = name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">      ChatRoom.showMessage(<span class="keyword">this</span>,message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
MediatorPatternDemo.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Mediator.demo2;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      User robert = <span class="keyword">new</span> User(<span class="string">"Robert"</span>);</span><br><span class="line">      User john = <span class="keyword">new</span> User(<span class="string">"John"</span>);</span><br><span class="line"> </span><br><span class="line">      robert.sendMessage(<span class="string">"Hi! John!"</span>);</span><br><span class="line">      john.sendMessage(<span class="string">"Hello! Robert!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果:<br>Thu Jan 31 16:05:46 IST 2013 [Robert] : Hi! John!<br>Thu Jan 31 16:05:46 IST 2013 [John] : Hello! Robert!</p>
</blockquote>
</li>
</ul>
<p>robert和john发送消息的请求由仲裁者处理.</p>
<ul>
<li>示例2<br>电脑里面的各个配件之间的交互,主要是通过主板来完成的.如果电脑里面没有了主板,那么各个配件之间就必须自行相互交互,以互相传送数据,理论上说，基本上各个配件相互之间都存在交互数据的可能。如图所示：<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/med.webp" alt><br>看起来是不是很复杂,其实<code>由于各个配件的接口不同，那么相互之间交互的时候，还必须把数据接口进行转换才能匹配上，那就更恐怖了</code>.<br>不过缩影有主板,各个配件的交互完全通过主板来完成,<code>每个配件都只需要和主板交互，而主板知道如何和所有的配件打交道</code>.<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/med2.webp" alt></li>
</ul>
<p>下面是一个 使用电脑来看电影的例子,主要分四步</p>
<ol>
<li>首先是光驱要读取光盘上的数据，然后告诉主板，它的状态改变了；</li>
<li>主板去得到光驱的数据，把这些数据交给CPU进行分析处理；</li>
<li>CPU处理完后，把数据分成了视频数据和音频数据，通知主板，它处理完了；</li>
<li>主板去得到CPU处理过后的数据，分别把数据交给显卡和声卡，去显示出视频和发出声音；</li>
</ol>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/med3.webp" alt></p>
<ol>
<li><p>所有同时的抽象父类的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mediator <span class="title">getMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 光驱类，一个同事类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDDriver</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CDDriver</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 光驱读取出来的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String data = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取光驱读取出来的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 光驱读取出来的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取光盘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readCD</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//逗号前是视频显示的数据，逗号后是声音</span></span><br><span class="line">       <span class="keyword">this</span>.data = <span class="string">"设计模式,值得好好研究"</span>;</span><br><span class="line">       <span class="comment">//通知主板，自己的状态发生了改变</span></span><br><span class="line">       <span class="keyword">this</span>.getMediator().changed(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CPU类，一个同事类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CPU</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CPU</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分解出来的视频数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String videoData = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分解出来的声音数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String soundData = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取分解出来的视频数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分解出来的视频数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVideoData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> videoData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取分解出来的声音数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分解出来的声音数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSoundData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> soundData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理数据，把数据分成音频和视频的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 被处理的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeData</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">       <span class="comment">//把数据分解开，前面的是视频数据，后面的是音频数据</span></span><br><span class="line">       String [] ss = data.split(<span class="string">","</span>);</span><br><span class="line">       <span class="keyword">this</span>.videoData = ss[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">this</span>.soundData = ss[<span class="number">1</span>];</span><br><span class="line">       <span class="comment">//通知主板，CPU的工作完成</span></span><br><span class="line">       <span class="keyword">this</span>.getMediator().changed(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显卡类，一个同事类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoCard</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoCard</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示视频数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 被显示的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showData</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"您正观看的是："</span>+data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声卡类，一个同事类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoundCard</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoundCard</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照声频数据发出声音</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 发出声音的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">soundData</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"画外音："</span>+data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>中介者接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中介者对象的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同事对象在自身改变的时候来通知中介者的方法，</span></span><br><span class="line"><span class="comment">     * 让中介者去负责相应的与其它同事对象的交互</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> colleague 同事对象自身，好让中介者对象通过对象实例</span></span><br><span class="line"><span class="comment">     *                  去获取同事对象的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changed</span><span class="params">(Colleague colleague)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现中介者对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主板类，实现中介者接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MotherBoard</span> <span class="keyword">implements</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要知道要交互的同事类——光驱类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CDDriver cdDriver = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要知道要交互的同事类——CPU类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CPU cpu = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要知道要交互的同事类——显卡类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> VideoCard videoCard = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要知道要交互的同事类——声卡类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SoundCard soundCard = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCdDriver</span><span class="params">(CDDriver cdDriver)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.cdDriver = cdDriver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCpu</span><span class="params">(CPU cpu)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVideoCard</span><span class="params">(VideoCard videoCard)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.videoCard = videoCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSoundCard</span><span class="params">(SoundCard soundCard)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.soundCard = soundCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changed</span><span class="params">(Colleague colleague)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(colleague == cdDriver)&#123;</span><br><span class="line">           <span class="comment">//表示光驱读取数据了</span></span><br><span class="line">           <span class="keyword">this</span>.opeCDDriverReadData((CDDriver)colleague);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(colleague == cpu)&#123;</span><br><span class="line">           <span class="comment">//表示CPU处理完了</span></span><br><span class="line">           <span class="keyword">this</span>.opeCPU((CPU)colleague);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理光驱读取数据过后与其它对象的交互</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cd 光驱同事对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">opeCDDriverReadData</span><span class="params">(CDDriver cd)</span></span>&#123;</span><br><span class="line">       <span class="comment">//1：先获取光驱读取的数据</span></span><br><span class="line">       String data = cd.getData();</span><br><span class="line">       <span class="comment">//2：把这些数据传递给CPU进行处理</span></span><br><span class="line">       <span class="keyword">this</span>.cpu.executeData(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理CPU处理完数据后与其它对象的交互</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cpu CPU同事类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">opeCPU</span><span class="params">(CPU cpu)</span></span>&#123;</span><br><span class="line">       <span class="comment">//1：先获取CPU处理过后的数据</span></span><br><span class="line">       String videoData = cpu.getVideoData();</span><br><span class="line">       String soundData = cpu.getSoundData();</span><br><span class="line">       <span class="comment">//2：把这些数据传递给显卡和声卡展示出来</span></span><br><span class="line">       <span class="keyword">this</span>.videoCard.showData(videoData);</span><br><span class="line">       <span class="keyword">this</span>.soundCard.soundData(soundData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Client</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//1：创建中介者——主板对象</span></span><br><span class="line">       MotherBoard mediator = <span class="keyword">new</span> MotherBoard();</span><br><span class="line">       <span class="comment">//2：创建同事类</span></span><br><span class="line">       CDDriver cd = <span class="keyword">new</span> CDDriver(mediator);</span><br><span class="line">       CPU cpu = <span class="keyword">new</span> CPU(mediator);</span><br><span class="line">       VideoCard vc = <span class="keyword">new</span> VideoCard(mediator);</span><br><span class="line">       SoundCard sc = <span class="keyword">new</span> SoundCard(mediator);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3：让中介者知道所有的同事</span></span><br><span class="line">       mediator.setCdDriver(cd);</span><br><span class="line">       mediator.setCpu(cpu);</span><br><span class="line">       mediator.setVideoCard(vc);</span><br><span class="line">       mediator.setSoundCard(sc);</span><br><span class="line">     </span><br><span class="line">       <span class="comment">//4：开始看电影，把光盘放入光驱，光驱开始读盘</span></span><br><span class="line">       cd.readCD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>示例3:(比较复杂不放这了)<br><a href>源码</a></li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对我们的程序而言，仲裁者模式适合于某一个部分发生改变就会导致其他部分做出相应的改变的情况，我们将这种变换的规律抽象出来，变成仲裁者，从而很好的协商各个部分，当组员有问题的时候（状态发生改变），直接告诉仲裁者，不与其他组员打交道，让仲裁者负责这些繁琐的事务，这样条理就很清晰了，因此仲裁者也成为中介者，可以想象很多人要去租房，很多人要把房子出租，如果私下里面去商量，既浪费时间，又很难找到对方，通过中介这个对象，它收集了很多的租房和出租房的信息，这样就能很快的找到最适合的房子。由此可见生活就是最好的设计模式。仲裁者模式对于代码的修改（很容易定位错误）、新的成员的加入、代码的复用（组员部分可以复用，仲裁者部分不易复用）都有着一定的简化，将该集中处理的集中起来，将该分散的分散出去，无疑是一种好的设计模式。对比于外观模式Facade，仲裁者需要和组员沟通，是双向的，而外观模式facade角色只是对其他角色进行整合，是单向的。</p>
<h4 id="Mediator-模式中的角色"><a href="#Mediator-模式中的角色" class="headerlink" title="Mediator 模式中的角色"></a>Mediator 模式中的角色</h4><ul>
<li>Mediator(仲裁者、中介者)<br>Mediator 角色负责定义与 Colleague 角色进行通信和做出决定的接口。</li>
<li>ConcreteMediator(具体的仲裁者、中介者)<br>ConcreteMediator 角色负责实现 Mediator 角色的接口，负责实际做出决定。<code>它需要了解并维护各个同事对象，并负责具体的协调各同事对象的交互关系</code></li>
<li>Colleague(同事)<br>同事类的定义，通常实现成为抽象类，主要负责约束同事对象的类型，并实现一些具体同事类之间的公共功能，比如：每个具体同事类都应该知道中介者对象，也就是具体同事类都会持有中介者对象，就可以定义到这个类里面。</li>
<li>ConcreteColleague(具体的同事)<br>具体的同事类，实现自己的业务，在需要与其它同事通讯的时候，就与持有的中介者通信，中介者会负责与其它的同事交互</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Mediator.png" alt></p>
<p>这篇文章写的非常详细<a href="https://www.jianshu.com/p/531f1957219b" target="_blank" rel="noopener">Mediator模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>仲裁者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Facade模式</title>
    <url>/2020/04/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BFacade%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/wg.png" alt></p>
<a id="more"></a>

<p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。<br>外观模式是一种非常简单的模式，简单到我们经常都会使用.</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>意图: 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li>
<li>何时使用: <ul>
<li>客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可</li>
<li>定义系统的入口。</li>
</ul>
</li>
<li>客户端不与系统耦合,外观类与系统耦合</li>
<li>主要实现: 在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。</li>
<li>应用实例:<ul>
<li>去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便</li>
<li>JAVA 的三层开发模式。</li>
</ul>
</li>
<li>优点:<ul>
<li>减少系统相互依赖</li>
<li>提高灵活性</li>
<li>提高安全性</li>
</ul>
</li>
<li>缺点:<ul>
<li>不符合开闭原则,如果要改东西很麻烦，继承重写都不合适。</li>
</ul>
</li>
<li>使用场景<ul>
<li>为复杂的模块或子系统提供外界访问的模块。</li>
<li>子系统相对独立</li>
<li>预防低水平人员带来的风险。</li>
</ul>
</li>
<li>注意事项: 在层次化结构中，可以使用外观模式定义系统中每一层的入口。</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>示例1:先举一个简单的例子<br>我们将创建一个 <code>Shape</code> 接口和实现了 <code>Shape</code> 接口的实体类。下一步是定义一个外观类 <code>ShapeMaker</code>。<br><code>ShapeMaker</code> 类使用实体类来代表用户对这些类的调用。<code>FacadePatternDemo</code>，我们的演示类使用 <code>ShapeMaker</code> 类来显示结果。</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/facade.jpg" alt></p>
<ol>
<li>先创建个接口<br>Shape.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Facade.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建实现接口的实体类<br>Circle.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Facade.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Circle::draw()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Rectangle.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Facade.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Rectangle::draw()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Square.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Facade.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Square::draw()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建外观类<br>ShapeMaker.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Facade.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeMaker</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Shape circle;</span><br><span class="line">   <span class="keyword">private</span> Shape rectangle;</span><br><span class="line">   <span class="keyword">private</span> Shape square;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ShapeMaker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      circle = <span class="keyword">new</span> Circle();</span><br><span class="line">      rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">      square = <span class="keyword">new</span> Square();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>&#123;</span><br><span class="line">      circle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">      rectangle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSquare</span><span class="params">()</span></span>&#123;</span><br><span class="line">      square.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用外观类</li>
</ol>
<p>FacadePatternDemo.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Facade.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadePatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ShapeMaker shapeMaker = <span class="keyword">new</span> ShapeMaker();</span><br><span class="line"> </span><br><span class="line">      shapeMaker.drawCircle();</span><br><span class="line">      shapeMaker.drawRectangle();</span><br><span class="line">      shapeMaker.drawSquare();      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例2:<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/fa.png" alt></li>
</ul>
<p>DataBase类:<br>Database可获取指定数据库名所对应的Properties的示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>HTMLWriter类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PageMaker类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><ul>
<li><p>facde(窗口)</p>
</li>
<li><p>classX(构成系统的其它角色)</p>
</li>
<li><p>client(业务场景，调用者)</p>
</li>
<li><p>Facade模式的类图<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/facade.png" alt></p>
</li>
</ul>
<p>对外的API（接口）变少了，client只需要关注facade的public接口，而不用关心它下面的那些复杂逻辑</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>外观模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Chain of Responsibility模式</title>
    <url>/2020/03/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BChain%20of%20Responsibility%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/zrl.png" alt></p>
<a id="more"></a>

<h4 id="责任链模式介绍"><a href="#责任链模式介绍" class="headerlink" title="责任链模式介绍"></a>责任链模式介绍</h4><p>简单说,责任链模式可以说是, 当问题不能解决的时候,将问题交给另一个对象去处理,就这样一直传递下去直至当前对象找不到下线了,处理结束.</p>
<ul>
<li><p>意图: 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
</li>
<li><p>主要解决:职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
</li>
<li><p>应用实例:  </p>
<ul>
<li>JS 中的事件冒泡。</li>
<li>JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</li>
</ul>
</li>
<li><p>优点:</p>
<ul>
<li>降低耦合度。它将请求的发送者和接收者解耦。 </li>
<li>简化了对象。使得对象不需要知道链的结构。 </li>
<li>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 </li>
<li>增加新的请求处理类很方便。</li>
</ul>
</li>
<li><p>缺点:</p>
<ul>
<li>不能保证请求一定被接收。 </li>
<li>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 </li>
<li>可能不容易观察运行时的特征，有碍于除错。</li>
</ul>
</li>
<li><p>使用场景: </p>
</li>
<li><p>有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 </p>
</li>
<li><p>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 </p>
</li>
<li><p>可动态指定一组对象处理请求。</p>
</li>
</ul>
<h4 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h4><ul>
<li>程序1:</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/chain.png" alt></p>
<p>Trouble类 (数据结构)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.ChainOfResponsibility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trouble</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> number; <span class="comment">// 问题编号</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Trouble</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123; <span class="comment">// 生成问题</span></span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取问题编号</span></span><br><span class="line">		<span class="keyword">return</span> number;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="comment">// 代表问题的字符串</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"[Trouble "</span> + number + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Support类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.ChainOfResponsibility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Support</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">resolve</span><span class="params">(Trouble trouble)</span></span>;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line">	Support next;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Support</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"["</span> + name + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Support <span class="title">setAndReturnNext</span><span class="params">(Support next)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.next = next;</span><br><span class="line">		<span class="keyword">return</span> next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">support</span><span class="params">(Trouble trouble)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (resolve(trouble)) &#123;</span><br><span class="line">			done(trouble);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">			next.support(trouble);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fail(trouble);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Trouble trouble)</span> </span>&#123;</span><br><span class="line">		System.out.println(trouble + <span class="string">"cannot be resolved."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">(Trouble trouble)</span> </span>&#123;</span><br><span class="line">		System.out.println(trouble + <span class="string">" is resolved by "</span>+<span class="keyword">this</span>+ <span class="string">"."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NoSupport类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.ChainOfResponsibility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSupport</span> <span class="keyword">extends</span> <span class="title">Support</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NoSupport</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">resolve</span><span class="params">(Trouble trouble)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LimitSupport类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.ChainOfResponsibility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitSupport</span> <span class="keyword">extends</span> <span class="title">Support</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LimitSupport</span><span class="params">(String name, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.limit = limit;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">resolve</span><span class="params">(Trouble trouble)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> trouble.getNumber() &lt;= limit ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpecialSupport类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.ChainOfResponsibility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpecialSupport</span> <span class="keyword">extends</span> <span class="title">Support</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> specialNumber;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SpecialSupport</span><span class="params">(String name, <span class="keyword">int</span> specialNumber)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.specialNumber = specialNumber;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">resolve</span><span class="params">(Trouble trouble)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> trouble.getNumber() == specialNumber ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OddSupport类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.ChainOfResponsibility;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OddSupport</span> <span class="keyword">extends</span> <span class="title">Support</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OddSupport</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">resolve</span><span class="params">(Trouble trouble)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (trouble.getNumber()%<span class="number">2</span>) == <span class="number">1</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.ChainOfResponsibility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Support alice = <span class="keyword">new</span> NoSupport(<span class="string">"Alice"</span>);</span><br><span class="line">		Support bob = <span class="keyword">new</span> LimitSupport(<span class="string">"Bob"</span>, <span class="number">100</span>);</span><br><span class="line">		Support charlie = <span class="keyword">new</span> SpecialSupport(<span class="string">"Charlie"</span>, <span class="number">429</span>);</span><br><span class="line">		Support diana = <span class="keyword">new</span> LimitSupport(<span class="string">"Diana"</span>, <span class="number">200</span>);</span><br><span class="line">		Support elmo = <span class="keyword">new</span> OddSupport(<span class="string">"Elmo"</span>);</span><br><span class="line">		Support fred = <span class="keyword">new</span> LimitSupport(<span class="string">"Fred"</span>, <span class="number">300</span>);</span><br><span class="line">		<span class="comment">// 形成职责链</span></span><br><span class="line">		alice.setAndReturnNext(bob).setAndReturnNext(charlie).setAndReturnNext(diana).setAndReturnNext(elmo)</span><br><span class="line">				.setAndReturnNext(fred);</span><br><span class="line">		<span class="comment">// 制造各种问题</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">			alice.support(<span class="keyword">new</span> Trouble((<span class="keyword">int</span>)(Math.random()*<span class="number">500</span>)));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p>核心是Handle类，里面使用模板方法定义好了调用链的逻辑，然后通过递归调用下一个处理人。其它ConcreteHandler只负责定义各自的业务处理逻辑，然后等待被调用就行</p>
<ul>
<li>Handle(处理者，抽象类)</li>
<li>ConcreteHandler(具体的处理者)</li>
<li>Client（请求者）</li>
</ul>
<ul>
<li>Chain of Responsibility模式的类图</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/cr.png" alt></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>责任链模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Visitor模式</title>
    <url>/2020/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BVisitor%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/fw.png" alt></p>
<a id="more"></a>

<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>访问者模式能将算法与其所作用的对象隔离开来。在访问者模式（Visitor Pattern）中，使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作</p>
<ul>
<li>为什么还要有一个访问者模式呢?<br>  这就要放到OOP之中了，在面向对象编程的思想中，我们使用类来组织属性，以及对属性的操作，那么我们理所当然的将访问操作放到了类的内部，这样看起来没问题，但是当我们想要使用另一种遍历方式要怎么办呢，我们必须将这个类进行修改，这在设计模式中是大忌，在设计模式中就要保证，对扩展开放，对修改关闭的开闭原则。</li>
</ul>
<p>所以我们考虑 可不可以将访问操作独立出来变成一个新的le我们需要增加访问操作的时候，直接增加新的类，原来的代码不需要任何的改变，如果可以这样做，那么我们的程序就是好的程序，因为可以扩展，符合开闭原则。而访问者模式就是实现这个的，使得使用不同的访问方式都可以对某些元素进行访问。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/vis.png" alt></p>
<p>Visitor类是表示访问者的抽象类<br>Visitor.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(File file)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Directory directory)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Element接口是接受访问者的访问男的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor v)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Entry类再本质上 与 之前的Composite中的Entry类是一样的,不过这次实现了Element接口为了让Entry类适用于Visitor模式.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>; <span class="comment">// 获取名字</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>; <span class="comment">// 获取大小</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Entry <span class="title">add</span><span class="params">(Entry entry)</span> <span class="keyword">throws</span> FileTreatmentException </span>&#123; <span class="comment">// 增加目录条目</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> FileTreatmentException();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> <span class="keyword">throws</span> FileTreatmentException </span>&#123; <span class="comment">// 生成Iterator</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> FileTreatmentException();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="comment">// 显示字符串</span></span><br><span class="line">		<span class="keyword">return</span> getName() + <span class="string">" ("</span> + getSize() + <span class="string">")"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>File.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Visitor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.size = size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor v)</span> </span>&#123;</span><br><span class="line">		v.visit(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Directory.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">// 文件夹名字</span></span><br><span class="line">	<span class="keyword">private</span> ArrayList dir = <span class="keyword">new</span> ArrayList(); <span class="comment">// 目录条目集合</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Directory</span><span class="params">(String name)</span> </span>&#123; <span class="comment">// 构造函数</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取名字</span></span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取大小</span></span><br><span class="line">		<span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">		Iterator it = dir.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Entry entry = (Entry) it.next();</span><br><span class="line">			size += entry.getSize();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Entry <span class="title">add</span><span class="params">(Entry entry)</span> </span>&#123; <span class="comment">// 增加目录条目</span></span><br><span class="line">		dir.add(entry);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123; <span class="comment">// 生成Iterator</span></span><br><span class="line">		<span class="keyword">return</span> dir.iterator();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor v)</span> </span>&#123; <span class="comment">// 接受访问者的访问</span></span><br><span class="line">		v.visit(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ListVistor.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListVisitor</span> <span class="keyword">extends</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String currentdir = <span class="string">""</span>; <span class="comment">// 当前访问的文件夹的名字</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(File file)</span> </span>&#123; <span class="comment">// 在访问文件时被调用</span></span><br><span class="line">		System.out.println(currentdir + <span class="string">"/"</span> + file);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Directory directory)</span> </span>&#123; <span class="comment">// 在访问文件夹时被调用</span></span><br><span class="line">		System.out.println(currentdir + <span class="string">"/"</span> + directory);</span><br><span class="line">		String savedir = currentdir;</span><br><span class="line">		currentdir = currentdir + <span class="string">"/"</span> + directory.getName();</span><br><span class="line">		Iterator it = directory.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Entry entry = (Entry) it.next();</span><br><span class="line">			entry.accept(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		currentdir = savedir;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileVisitor.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileVisitor</span> <span class="keyword">extends</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String currentDir = <span class="string">""</span>;</span><br><span class="line">	String suffix;</span><br><span class="line"><span class="comment">//	ArrayList files = new ArrayList();</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileVisitor</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.suffix = suffix;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (file.getName().endsWith(suffix)) &#123;</span><br><span class="line">			<span class="comment">// System.out.println(currentDir+"/"+file);</span></span><br><span class="line">			System.out.println(currentDir + <span class="string">"/"</span> + file);</span><br><span class="line"><span class="comment">//			files.add(currentDir + "/" + file);</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Directory directory)</span> </span>&#123;</span><br><span class="line">		String saveDir = currentDir;</span><br><span class="line">		currentDir += (<span class="string">"/"</span> + directory.getName());</span><br><span class="line">		Iterator it = directory.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Entry entry = (Entry) it.next();</span><br><span class="line">			entry.accept(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		currentDir = saveDir;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	Iterator getFiles() &#123;</span></span><br><span class="line"><span class="comment">//		return files.iterator();</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Directory root = <span class="keyword">new</span> Directory(<span class="string">"根目录"</span>);</span><br><span class="line"></span><br><span class="line">		Directory life = <span class="keyword">new</span> Directory(<span class="string">"我的生活"</span>);</span><br><span class="line">		File eat = <span class="keyword">new</span> File(<span class="string">"吃火锅.txt"</span>, <span class="number">100</span>);</span><br><span class="line">		File sleep = <span class="keyword">new</span> File(<span class="string">"睡觉.html"</span>, <span class="number">100</span>);</span><br><span class="line">		File study = <span class="keyword">new</span> File(<span class="string">"学习.txt"</span>, <span class="number">100</span>);</span><br><span class="line">		life.add(eat);</span><br><span class="line">		life.add(sleep);</span><br><span class="line">		life.add(study);</span><br><span class="line"></span><br><span class="line">		Directory work = <span class="keyword">new</span> Directory(<span class="string">"我的工作"</span>);</span><br><span class="line">		File write = <span class="keyword">new</span> File(<span class="string">"写博客.doc"</span>, <span class="number">200</span>);</span><br><span class="line">		File paper = <span class="keyword">new</span> File(<span class="string">"写论文.html"</span>, <span class="number">200</span>);</span><br><span class="line">		File homework = <span class="keyword">new</span> File(<span class="string">"写家庭作业.docx"</span>, <span class="number">200</span>);</span><br><span class="line">		work.add(write);</span><br><span class="line">		work.add(paper);</span><br><span class="line">		work.add(homework);</span><br><span class="line"></span><br><span class="line">		Directory relax = <span class="keyword">new</span> Directory(<span class="string">"我的休闲"</span>);</span><br><span class="line">		File music = <span class="keyword">new</span> File(<span class="string">"听听音乐.js"</span>, <span class="number">200</span>);</span><br><span class="line">		File walk = <span class="keyword">new</span> File(<span class="string">"出去转转.psd"</span>, <span class="number">200</span>);</span><br><span class="line">		relax.add(music);</span><br><span class="line">		relax.add(walk);</span><br><span class="line"></span><br><span class="line">		Directory read = <span class="keyword">new</span> Directory(<span class="string">"我的阅读"</span>);</span><br><span class="line">		File book = <span class="keyword">new</span> File(<span class="string">"学习书籍.psd"</span>, <span class="number">200</span>);</span><br><span class="line">		File novel = <span class="keyword">new</span> File(<span class="string">"娱乐小说.txt"</span>, <span class="number">200</span>);</span><br><span class="line">		read.add(book);</span><br><span class="line">		read.add(novel);</span><br><span class="line"></span><br><span class="line">		root.add(life);</span><br><span class="line">		root.add(work);</span><br><span class="line">		root.add(relax);</span><br><span class="line">		root.add(read);</span><br><span class="line"></span><br><span class="line">		root.accept(<span class="keyword">new</span> ListVisitor());</span><br><span class="line">		System.out.println(<span class="string">"========================"</span>);</span><br><span class="line">		FileVisitor visitor = <span class="keyword">new</span> FileVisitor(<span class="string">".psd"</span>);</span><br><span class="line">		root.accept(visitor);</span><br><span class="line"><span class="comment">//		Iterator it = visitor.getFiles();</span></span><br><span class="line"><span class="comment">//		while (it.hasNext()) &#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>访问者模式是一个非常有意思的模式，因为自己需要得到数据就需要向被访者索取，如果能够一次索取成功，访问就结束了，如果还需要其他信息，则再次向被访问者索取，就这样知道拿到自己需要的所有数据。在本例中借用了组合模式中的数据结构，那是因为这种树形的结构很适合我们进行递归访问。访问者模式和迭代器模式都是在某种数据结构上进行处理，一种是对数据结构中的元素进行某种特定的处理，另一种是用某种方式遍历所有元素。在实际应用中，我们根据实际需要来考虑是不是需要双重分发机制。在本例中的访问者模式中用到了组合模式、委托（组合）、双重分发等原理，便于新增访问方式，不便于对数据结构的修改。</p>
<h4 id="Visitor模式-登场的橘色"><a href="#Visitor模式-登场的橘色" class="headerlink" title="Visitor模式 登场的橘色"></a>Visitor模式 登场的橘色</h4><ul>
<li>Visitor(访问者，抽象类)</li>
<li>ConcreteVisitor(具体的访问者，实现visit接口)</li>
<li>Element(访问对象、抽象类)</li>
<li>ConcreteElement(具体的访问对象)</li>
<li>ObjectStructure(对象结构，遍历Element，处理Element角色的集合)</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/vs.png" alt></p>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ul>
<li>双重分发机制<br>在Visitor模式中方法的调用关系<br>accept(接受)发给发的调用方式如下<blockquote>
<p>element.accept(visitor);</p>
</blockquote>
</li>
</ul>
<p>在visit(访问)方法的调用方式如下:</p>
<blockquote>
<p>visitor.visit(element);</p>
</blockquote>
<p>对比这两个方法,他们是相反的关系,element接受visitor,而visitor又访问element.</p>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><ol>
<li>在示例程序中,Directory类的gitSize方法的作用是获取文件夹大小,请编写一个获取大小的SizeVisitor类,用它替换掉Directory类的getSize方法.</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>访问者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Decorator模式</title>
    <url>/2020/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BDecorator%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/zs.png" alt></p>
<a id="more"></a>

<p><a href="https://www.cnblogs.com/zyrblog/p/9238304.html" target="_blank" rel="noopener">转自</a><br>感觉这位博主讲的很清楚了</p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>装饰者模式动态地给一个对象增加一些额外的职责(Responsibility),就增加对象功能来说,装饰模式比生成子类实现更为灵活.其别名也可以称为包装器(Wrapper),与适配器模式的别名相同,但它们适用于不同的场合.</p>
<p>第一次听说装饰器还是在学python的时候, 装饰器模式在java以及程序设计中也是占据着重要的地位.比如Java的数据流处理,我们可能看到数据流经过不同的类的包装和包裹,最终形成了我们需要的流,比如说从二进制到字节流再到字符流,这中间其实就是经过了装饰器的处理,在不改变原来的数据的基础上,加入属于自己的特征,就像是在一块蛋糕上加上一些水果等装饰品,这样输出的结果就不同了,我们将这种能产生类似于洋葱一样层层包裹的数据格式的设计模式成为装饰器模式.</p>
<p>那么为什么装饰器这样神奇呢,几乎可以让我们无穷尽的包裹自身,在计算机中凡是能够无穷尽的重复某一件事物,必然不能设定固定的数据,只能按照用户的随意设置来计算,那么递归的魅力就在此彰显出来了,通过递归可以实现这一点,那么如何递归呢,我们想到一层套一层的数据结构（链表、二叉树等）,就必须在“自身”中包含“自身”；前一个“自身”可以是我们的子类,因为子类有着父类的所有特点,后一个“自身”就是具有最抽象资格的“自身”,正是因为足够抽象使得任何继承与这个抽象类的类都能通过里氏代换原则转换到这个抽象类.实现了递归,我们只需要停止条件就可以了,停止条件就是用户在Main中对原数据包裹的层数,肯定是有限的,因此停止是必然的.这样我们仿似看到一个原始数据,被一层层的进行包裹,加入新的内容,最终使用最顶层的输出方法将这个结果呈现给我们.同样的我们还可以反着看,当递归开始的时候,在最顶层等待下一层的数据,然后使用顶层的方式来封装,而下一层被启动执行到关键步骤时会等待下下一层的数据返回给自身,然后是用自己的方式来封装,就这样一直等待下去,直到最底层的数据（本来就有）得到之后,然后一步步的返回过来,在相应的层次进行相应的封装,最后得到了最终的数据.这就是装饰器模式,所有的类其实最终都是同源（一致性）的,有最终的祖先,如下图所示.</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/de.png" alt><br>上图中,StringDisplay是保存原始数据的,而Border中将父类的引用组合进入自身,形成了递归的必然条件,之后让子类（SideBorder和FullBorder）来使用这个引用,从而根据自身的实际情况（要怎样装饰）来进行包装,将原始的数据getRowText(rowID)进行包裹,最终通过同源祖先类的show()方法来现实,这里祖先类Display使用了面向抽象编程的模板方法,相信大家都能看出来.对比与上一个组合模式,我们可以看到上面的部分还是很相似的,但是在composite中,都实现了add()方法,通过容器来进行组织,并且使用委托机制来存储所有的有着共同父类的元素,在显示的时候使用了树的深度优先遍历.而在装饰器模式中,我们使用的递归从上到下,沿着display的指向一点点的走到了底部,并且最终返回了过来.遍历的方式有着相似之处也有着不同之处.这里要说明的是,<code>建议大家在show()的地方打个断点(大家自己实验把)</code>,然后跟踪进去,一点点的看看我们的程序到底是怎么组织起来的,只有这样我们才能理解递归的含义,对装饰器有一个更深层次的认识.</p>
<p>Display.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Border</span> <span class="keyword">extends</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> Display display; <span class="comment">// 表示被装饰物</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">Border</span><span class="params">(Display display)</span> </span>&#123; <span class="comment">// 在生成实例时通过参数指定被装饰物</span></span><br><span class="line">		<span class="keyword">this</span>.display = display;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StringDisplay.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDisplay</span> <span class="keyword">extends</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String string;                          <span class="comment">// 要显示的字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringDisplay</span><span class="params">(String string)</span> </span>&#123;           <span class="comment">// 通过参数传入要显示的字符串</span></span><br><span class="line">        <span class="keyword">this</span>.string = string;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColumns</span><span class="params">()</span> </span>&#123;                       <span class="comment">// 字符数</span></span><br><span class="line">        <span class="keyword">return</span> string.getBytes().length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRows</span><span class="params">()</span> </span>&#123;                          <span class="comment">// 行数是1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRowText</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;             <span class="comment">// 仅当row为0时返回值</span></span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> string;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Border.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Border</span> <span class="keyword">extends</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> Display display; <span class="comment">// 表示被装饰物</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">Border</span><span class="params">(Display display)</span> </span>&#123; <span class="comment">// 在生成实例时通过参数指定被装饰物</span></span><br><span class="line">		<span class="keyword">this</span>.display = display;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SideBorder.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SideBorder</span> <span class="keyword">extends</span> <span class="title">Border</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">char</span> borderChar; <span class="comment">// 表示装饰边框的字符</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SideBorder</span><span class="params">(Display display, <span class="keyword">char</span> ch)</span> </span>&#123; <span class="comment">// 通过构造函数指定Display和装饰边框字符</span></span><br><span class="line">		<span class="keyword">super</span>(display);</span><br><span class="line">		<span class="keyword">this</span>.borderChar = ch;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColumns</span><span class="params">()</span> </span>&#123; <span class="comment">// 字符数为字符串字符数加上两侧边框字符数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span> + display.getColumns() + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRows</span><span class="params">()</span> </span>&#123; <span class="comment">// 行数即被装饰物的行数</span></span><br><span class="line">		<span class="keyword">return</span> display.getRows();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getRowText</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123; <span class="comment">// 指定的那一行的字符串为被装饰物的字符串加上两侧的边框的字符</span></span><br><span class="line">		<span class="keyword">return</span> borderChar + display.getRowText(row) + borderChar;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FullBorder.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullBorder</span> <span class="keyword">extends</span> <span class="title">Border</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FullBorder</span><span class="params">(Display display)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(display);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColumns</span><span class="params">()</span> </span>&#123; <span class="comment">// 字符数为被装饰物的字符数加上两侧边框字符数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span> + display.getColumns() + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRows</span><span class="params">()</span> </span>&#123; <span class="comment">// 行数为被装饰物的行数加上上下边框的行数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span> + display.getRows() + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getRowText</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123; <span class="comment">// 指定的那一行的字符串</span></span><br><span class="line">		<span class="keyword">if</span> (row == <span class="number">0</span>) &#123; <span class="comment">// 上边框</span></span><br><span class="line">			<span class="keyword">return</span> <span class="string">"+"</span> + makeLine(<span class="string">'-'</span>, display.getColumns()) + <span class="string">"+"</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (row == display.getRows() + <span class="number">1</span>) &#123; <span class="comment">// 下边框</span></span><br><span class="line">			<span class="keyword">return</span> <span class="string">"+"</span> + makeLine(<span class="string">'-'</span>, display.getColumns()) + <span class="string">"+"</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他边框</span></span><br><span class="line">			<span class="keyword">return</span> <span class="string">"|"</span> + display.getRowText(row - <span class="number">1</span>) + <span class="string">"|"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">makeLine</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> count)</span> </span>&#123; <span class="comment">// 生成一个重复count次字符ch的字符串</span></span><br><span class="line">		StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">			buf.append(ch);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> buf.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Display b1 = <span class="keyword">new</span> StringDisplay(<span class="string">"Hello, world."</span>);</span><br><span class="line">		Display b2 = <span class="keyword">new</span> SideBorder(b1, <span class="string">'#'</span>);</span><br><span class="line">		Display b3 = <span class="keyword">new</span> FullBorder(b2);</span><br><span class="line">		b1.show();</span><br><span class="line">		b2.show();</span><br><span class="line">		b3.show();</span><br><span class="line">		Display b4 = <span class="keyword">new</span> SideBorder(</span><br><span class="line">				<span class="keyword">new</span> FullBorder(<span class="keyword">new</span> FullBorder(<span class="keyword">new</span> SideBorder(<span class="keyword">new</span> FullBorder(<span class="keyword">new</span> StringDisplay(<span class="string">"Hello,Jason"</span>)), <span class="string">'*'</span>))), <span class="string">'/'</span>);</span><br><span class="line">		b4.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>继承保证了父类和子类的一致性（有共同的方法）,委托保证了使用委托的类和被委托对象的一致性.正如Border和Display有着一些相同的方法名称,以及一些委托处理方法.可以看到装饰模式中,保证了装饰边框与被装饰物体的一致性（有共同父类）,使用了模板方法,这个方法几乎无处不在呀,同样使用了委托（组合）,通过在原始数据上面一层层的包裹,最终得到了我们想要的输出,有着非常广泛的用处.</p>
<p><strong>我的理解</strong>:装饰者模式就是, 你要出去玩. 你穿上新买的球鞋,新买的裤子,新买的外套…然后 你感觉头型也需要整整,就用个整理头型的装饰器, 脸上有痘痘,再用个遮瑕的装饰器.就这样无限的装饰(递归的过程),最后你觉得非常完美了(退出递归). ok现在你就可以出门了.<br>当我们买了新的口红,我们只需要新写一个口红装饰器来装饰,不需要对 已经化好的装(已有的类)进行修改.</p>
<h4 id="装饰者模式-结构-出场角色"><a href="#装饰者模式-结构-出场角色" class="headerlink" title="装饰者模式 结构(出场角色)"></a>装饰者模式 结构(出场角色)</h4><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dec.png" alt></p>
<ul>
<li>部件 （Component） 声明封装器和被封装对象的公用接口.<br><code>Display</code></li>
<li>具体部件 （Concrete Component） 类是被封装对象所属的类. 它定义了基础行为, 但装饰类可以改变这些行为.<br><code>StringDisplay</code></li>
<li>基础装饰 （Base Decorator） 类拥有一个指向被封装对象的引用成员变量. 该变量的类型应当被声明为通用部件接口, 这样它就可以引用具体的部件和装饰. 装饰基类会将所有操作委派给被封装的对象.<br><code>Border</code></li>
<li>具体装饰类 （Concrete Decorators） 定义了可动态添加到部件的额外行为. 具体装饰类会重写装饰基类的方法, 并在调用父类方法之前或之后进行额外的行为.<br><code>FullBorder</code>和<code>SideBorder</code></li>
<li>客户端 （Client） 可以使用多层装饰来封装部件, 只要它能使用通用接口与所有对象互动即可.<br><code>Main</code><h4 id="最后再举个例子"><a href="#最后再举个例子" class="headerlink" title="最后再举个例子"></a>最后再举个例子</h4>在本例中, 装饰模式 能够对敏感数据进行压缩和加密, 从而将数据从使用数据的代码中独立出来.</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dec1.png" alt></p>
<p>程序使用一对装饰来封装数据源对象. 这两个封装器都改变了从磁盘读写数据的方式：</p>
<ul>
<li>当数据即将被写入磁盘前, 装饰对数据进行加密和压缩. 原始类在对改变毫无察觉的情况下, 将加密后的受保护数据写入文件.</li>
<li>当数据刚从磁盘读出后, 同样通过装饰对数据进行解压和解密. 装饰和数据源类实现同一接口, 从而能在客户端代码中相互替换.</li>
</ul>
<p>伪代码</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">// 装饰可以改变组件接口所定义的操作.</span><br><span class="line">interface DataSource <span class="keyword">is</span></span><br><span class="line">    method writeData(data)</span><br><span class="line">    method readData():data</span><br><span class="line"></span><br><span class="line">// 具体组件提供操作的默认实现.这些类在程序中可能会有几个变体.</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileDataSource</span> <span class="title">implements</span> <span class="title">DataSource</span> <span class="title">is</span></span></span><br><span class="line">    constructor FileDataSource(filename) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    method writeData(data) <span class="keyword">is</span></span><br><span class="line">        // 将数据写入文件.</span><br><span class="line"></span><br><span class="line">    method readData():data <span class="keyword">is</span></span><br><span class="line">        // 从文件读取数据.</span><br><span class="line"></span><br><span class="line">// 装饰基类和其他组件遵循相同的接口.该类的主要任务是定义所有具体装饰的封</span><br><span class="line">// 装接口.封装的默认实现代码中可能会包含一个保存被封装组件的成员变量,并</span><br><span class="line">// 且负责对其进行初始化.</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSourceDecorator</span> <span class="title">implements</span> <span class="title">DataSource</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">protected</span> <span class="title">field</span> <span class="title">wrappee</span>:</span> DataSource</span><br><span class="line"></span><br><span class="line">    constructor DataSourceDecorator(source: DataSource) <span class="keyword">is</span></span><br><span class="line">        wrappee = source</span><br><span class="line"></span><br><span class="line">    // 装饰基类会直接将所有工作分派给被封装组件.具体装饰中则可以新增一些</span><br><span class="line">    // 额外的行为.</span><br><span class="line">    method writeData(data) <span class="keyword">is</span></span><br><span class="line">        wrappee.writeData(data)</span><br><span class="line"></span><br><span class="line">    // 具体装饰可调用其父类的操作实现,而不是直接调用被封装对象.这种方式</span><br><span class="line">    // 可简化装饰类的扩展工作.</span><br><span class="line">    method readData():data <span class="keyword">is</span></span><br><span class="line">        <span class="keyword">return</span> wrappee.readData()</span><br><span class="line"></span><br><span class="line">// 具体装饰必须在被封装对象上调用方法,不过也可以自行在结果中添加一些内容.</span><br><span class="line">// 装饰必须在调用封装对象之前或之后执行额外的行为.</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EncryptionDecorator</span> <span class="title">extends</span> <span class="title">DataSourceDecorator</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">writeData</span><span class="params">(data)</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">        // 1. 对传递数据进行加密.</span></span><br><span class="line"><span class="class">        // 2. 将加密后数据传递给被封装对象 <span class="title">writeData</span>（写入数据）方法.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">readData</span><span class="params">()</span>:</span>data <span class="keyword">is</span></span><br><span class="line">        // <span class="number">1.</span> 通过被封装对象的 readData（读取数据）方法获取数据.</span><br><span class="line">        // <span class="number">2.</span> 如果数据被加密就尝试解密.</span><br><span class="line">        // <span class="number">3.</span> 返回结果.</span><br><span class="line"></span><br><span class="line">// 你可以将对象封装在多层装饰中.</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompressionDecorator</span> <span class="title">extends</span> <span class="title">DataSourceDecorator</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">writeData</span><span class="params">(data)</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">        // 1. 压缩传递数据.</span></span><br><span class="line"><span class="class">        // 2. 将压缩后数据传递给被封装对象 <span class="title">writeData</span>（写入数据）方法.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">readData</span><span class="params">()</span>:</span>data <span class="keyword">is</span></span><br><span class="line">        // <span class="number">1.</span> 通过被封装对象的 readData（读取数据）方法获取数据.</span><br><span class="line">        // <span class="number">2.</span> 如果数据被压缩就尝试解压.</span><br><span class="line">        // <span class="number">3.</span> 返回结果.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 选项 <span class="number">1</span>：装饰组件的简单示例</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">dumbUsageExample</span><span class="params">()</span> <span class="title">is</span></span></span><br><span class="line">        source = new FileDataSource("somefile.dat")</span><br><span class="line">        source.writeData(salaryRecords)</span><br><span class="line">        // 已将明码数据写入目标文件.</span><br><span class="line"></span><br><span class="line">        source = new CompressionDecorator(source)</span><br><span class="line">        source.writeData(salaryRecords)</span><br><span class="line">        // 已将压缩数据写入目标文件.</span><br><span class="line"></span><br><span class="line">        source = new EncryptionDecorator(source)</span><br><span class="line">        // 源变量中现在包含：</span><br><span class="line">        // Encryption &gt; Compression &gt; FileDataSource</span><br><span class="line">        source.writeData(salaryRecords)</span><br><span class="line">        // 已将压缩且加密的数据写入目标文件.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 选项 <span class="number">2</span>：客户端使用外部数据源.SalaryManager（工资管理器）对象并不关心</span><br><span class="line">// 数据如何存储.它们会与提前配置好的数据源进行交互,数据源则是通过程序配</span><br><span class="line">// 置器获取的.</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalaryManager</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">field</span> <span class="title">source</span>:</span> DataSource</span><br><span class="line"></span><br><span class="line">    constructor SalaryManager(source: DataSource) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    method load() <span class="keyword">is</span></span><br><span class="line">        <span class="keyword">return</span> source.readData()</span><br><span class="line"></span><br><span class="line">    method save() <span class="keyword">is</span></span><br><span class="line">        source.writeData(salaryRecords)</span><br><span class="line">    // ...其他有用的方法...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 程序可在运行时根据配置或环境组装不同的装饰堆桟.</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfigurator</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">configurationExample</span><span class="params">()</span> <span class="title">is</span></span></span><br><span class="line">        source = new FileDataSource("salary.dat")</span><br><span class="line">        <span class="keyword">if</span> (enabledEncryption)</span><br><span class="line">            source = new EncryptionDecorator(source)</span><br><span class="line">        <span class="keyword">if</span> (enabledCompression)</span><br><span class="line">            source = new CompressionDecorator(source)</span><br><span class="line"></span><br><span class="line">        logger = new SalaryManager(source)</span><br><span class="line">        salary = logger.load()</span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure>

<h4 id="装饰者模式-使用场景"><a href="#装饰者模式-使用场景" class="headerlink" title="装饰者模式 使用场景"></a>装饰者模式 使用场景</h4><ul>
<li>如果你希望在无需修改代码的情况下即可使用对象, 且希望在运行时为对象新增额外的行为, 可以使用装饰模式.<br>装饰能将业务逻辑组织为层次结构, 你可为各层创建一个装饰, 在运行时将各种不同逻辑组合成对象. 由于这些对象都遵循通用接口, 客户端代码能以相同的方式使用这些对象.</li>
<li>如果用继承来扩展对象行为的方案难以实现或者根本不可行, 你可以使用该模式.<br>许多编程语言使用 final最终关键字来限制对某个类的进一步扩展. 复用最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装.</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点<ul>
<li>你无需创建新子类即可扩展对象的行为.</li>
<li>你可以在运行时添加或删除对象的功能.</li>
<li>你可以用多个装饰封装对象来组合几种行为.</li>
<li>单一职责原则. 你可以将实现了许多不同行为的一个大类拆分为多个较小的类.</li>
</ul>
</li>
<li>缺点<ul>
<li>在封装器栈中删除特定封装器比较困难.</li>
<li>实现行为不受装饰栈顺序影响的装饰比较困难.</li>
<li>各层的初始化配置代码看上去可能会很糟糕.</li>
</ul>
</li>
</ul>
<h4 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h4><ul>
<li><p>适配器模式可以对已有对象的接口进行修改, 装饰者模式则能在不改变对象接口的前提下强化对象功能. 此外, 装饰还支持递归组合, 适配器则无法实现.</p>
</li>
<li><p>适配器能为被封装对象提供不同的接口,代理模式能为对象提供相同的接口, 装饰则能为对象提供加强的接口.</p>
</li>
<li><p>装饰可让你更改对象的外表, 策略模式则让你能够改变其本质.</p>
</li>
<li><p>装饰和代理有着相似的结构, 但是其意图却非常不同. 这两个模式的构建都基于组合原则, 也就是说一个对象应该将部分工作委派给另一个对象. 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期, 而装饰的生成则总是由客户端进行控制.</p>
</li>
</ul>
<h3 id="为什么要使用装饰者模式"><a href="#为什么要使用装饰者模式" class="headerlink" title="为什么要使用装饰者模式"></a>为什么要使用装饰者模式</h3><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/zsz.png" alt></p>
<p>新增加一个功能,导致新增子类很多, 会产生”类爆炸”<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/zsz.png" alt></p>
<p>这里我们看到如果使用子类继承父类,那么我们要写很多子类,这么做无疑增加了程序的臃肿性,并不是很灵活.这时,装饰者模式就诞生了.</p>
<p>有多少种辅料就有多少个子类<br>以后再怎增加辅料就加一个子类就好</p>
<p>动态的给一个对象添加一些额外的职责.就扩展功能而言,它比生成子类的方式更为灵活.</p>
<p>适应场景</p>
<ul>
<li>以动态的方式给对象添加之策</li>
<li>处理那些可以撤销的职责</li>
<li>当采用生成子类的方法进行扩充时,可能有大量独立的扩展,为支持每一种组合将产生大量的子类,使得子类数目呈爆炸性增长.</li>
</ul>
<h3 id="装饰者模式的接口"><a href="#装饰者模式的接口" class="headerlink" title="装饰者模式的接口"></a>装饰者模式的接口</h3><ul>
<li>抽象组件(Component): 给出一个抽象接口,以规范准备</li>
<li>被装饰这()</li>
<li>装饰者组件(Decorator): 持有组件(Component)对象的实例引用,该类的职责就是为了装饰具体组件对象,定义的基类.</li>
<li>具体装饰(ConcreteDecorator)</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/zsz2.png" alt></p>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/zsz3.png" alt><br>还可以装饰其他饮品</p>
<h3 id="真实场景案例"><a href="#真实场景案例" class="headerlink" title="真实场景案例"></a>真实场景案例</h3><p>用装饰着模式解决乱码<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/zsz4.png" alt><br>案例所设计的知识点</p>
<ul>
<li>装饰者模式</li>
<li>HTML</li>
<li>Request/Resonse</li>
<li>Servlet</li>
<li>Filter</li>
</ul>
<h3 id="IO体系中装饰者模式"><a href="#IO体系中装饰者模式" class="headerlink" title="IO体系中装饰者模式"></a>IO体系中装饰者模式</h3><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/iopng" alt></p>
<p>抽象组件:InputStream<br>被装饰者: FileInputStream, Byte..<br>装饰器: FilterInputStream</p>
<ul>
<li>django</li>
<li>flask</li>
<li>tornado</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Composite模式</title>
    <url>/2020/03/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BComposite%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/com.png" alt></p>
<a id="more"></a>

<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>如果应用的核心模型能用树状结构表示, 在应用中使用组合模式才有价值.<br>例如: 你有两类对象: <code>产品</code>和 <code>盒子</code>,一个盒子中可以包含多个 产品或者几个较小的 盒子 . 这些小 盒子中同样可以包含一些 产品或更小的 盒子 , 以此类推.</p>
<p>假设你希望在这些类的基础上开发一个定购系统. 订单中可以包含无包装的简单产品, 也可以包含装满产品的盒子……以及其他盒子. 此时你会如何计算每张订单的总价格呢？</p>
<p>订单中可能包括各种产品,这些产品放置在盒子中,然后又被放入一层又一层更大的盒子中.整个结构看上去像一颗树.</p>
<p>你可以尝试直接计算： 打开所有盒子, 找到每件产品, 然后计算总价. 这在真实世界中或许可行, 但在程序中, 你并不能简单地使用循环语句来完成该工作. 你必须事先知道所有 产品和 盒子的类别, 所有盒子的嵌套层数以及其他繁杂的细节信息. 因此, 直接计算极不方便, 甚至完全不可行.</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>组合模式建议使用一个通用接口来与<code>产品</code>和<code>盒子</code>进行交互, 并且在该接口中声明一个计算总价的方法.</p>
<ul>
<li>那么方法该如何设计呢？<br>对于一个产品, 该方法直接返回其价格； 对于一个盒子, 该方法遍历盒子中的所有项目, 询问每个项目的价格, 然后返回该盒子的总价格. 如果其中某个项目是小一号的盒子, 那么当前盒子也会遍历其中的所有项目, 以此类推, 直到计算出所有内部组成部分的价格. 你甚至可以在盒子的最终价格中增加额外费用, 作为该盒子的包装费用.</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/zh.png" alt><br><strong>组合模式以递归的方式处理对象树中的所有项目.</strong><br>该方式的最大优点在于你无需了解构成树状结构的对象的具体类. 你也无需了解对象是简单的产品还是复杂的盒子. 你只需调用通用接口以相同的方式对其进行处理即可. 当你调用该方法后, 对象会将请求沿着树结构传递下去.</p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/zh1.png" alt></p>
<p>Entry.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>; <span class="comment">// 获取名字</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>; <span class="comment">// 获取大小</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这里我们用异常处理的, 当然我们也可以用抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Entry <span class="title">add</span><span class="params">(Entry entry)</span> <span class="keyword">throws</span> FileTreatmentException </span>&#123; <span class="comment">// 加入目录条目</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> FileTreatmentException();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">()</span> </span>&#123; <span class="comment">// 为一览加上前缀并显示目录条目一览</span></span><br><span class="line">		printList(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(String prefix)</span></span>; <span class="comment">// 为一览加上前缀</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="comment">// 显示代表类的文字</span></span><br><span class="line">		<span class="keyword">return</span> getName() + <span class="string">" ("</span> + getSize() + <span class="string">")"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>File.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.size = size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">		System.out.println(prefix + <span class="string">"/"</span> + <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Directory.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">// 文件夹的名字</span></span><br><span class="line">	<span class="keyword">private</span> ArrayList directory = <span class="keyword">new</span> ArrayList(); <span class="comment">// 文件夹中目录条目的集合</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Directory</span><span class="params">(String name)</span> </span>&#123; <span class="comment">// 构造函数</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取名字</span></span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取大小</span></span><br><span class="line">		<span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">		Iterator it = directory.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Entry entry = (Entry) it.next();</span><br><span class="line">			size += entry.getSize();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Entry <span class="title">add</span><span class="params">(Entry entry)</span> </span>&#123; <span class="comment">// 增加目录条目</span></span><br><span class="line">		directory.add(entry);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(String prefix)</span> </span>&#123; <span class="comment">// 显示目录条目一览</span></span><br><span class="line">		System.out.println(prefix + <span class="string">"/"</span> + <span class="keyword">this</span>);</span><br><span class="line">		Iterator it = directory.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Entry entry = (Entry) it.next();</span><br><span class="line">			entry.printList(prefix + <span class="string">"/"</span> + name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异常类 FileTreatmentException.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTreatmentException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileTreatmentException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileTreatmentException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Directory root = <span class="keyword">new</span> Directory(<span class="string">"根目录"</span>);</span><br><span class="line"></span><br><span class="line">		Directory life = <span class="keyword">new</span> Directory(<span class="string">"我的生活"</span>);</span><br><span class="line">		File eat = <span class="keyword">new</span> File(<span class="string">"吃火锅"</span>, <span class="number">100</span>);</span><br><span class="line">		File sleep = <span class="keyword">new</span> File(<span class="string">"睡觉"</span>, <span class="number">100</span>);</span><br><span class="line">		File study = <span class="keyword">new</span> File(<span class="string">"学习"</span>, <span class="number">100</span>);</span><br><span class="line">		life.add(eat);</span><br><span class="line">		life.add(sleep);</span><br><span class="line">		life.add(study);</span><br><span class="line"></span><br><span class="line">		Directory work = <span class="keyword">new</span> Directory(<span class="string">"我的工作"</span>);</span><br><span class="line">		File write = <span class="keyword">new</span> File(<span class="string">"写博客"</span>, <span class="number">200</span>);</span><br><span class="line">		File paper = <span class="keyword">new</span> File(<span class="string">"写论文"</span>, <span class="number">200</span>);</span><br><span class="line">		File homework = <span class="keyword">new</span> File(<span class="string">"写家庭作业"</span>, <span class="number">200</span>);</span><br><span class="line">		work.add(write);</span><br><span class="line">		work.add(paper);</span><br><span class="line">		work.add(homework);</span><br><span class="line"></span><br><span class="line">		Directory relax = <span class="keyword">new</span> Directory(<span class="string">"我的休闲"</span>);</span><br><span class="line">		File music = <span class="keyword">new</span> File(<span class="string">"音乐"</span>, <span class="number">200</span>);</span><br><span class="line">		File wz = <span class="keyword">new</span> File(<span class="string">"王者荣耀"</span>, <span class="number">500</span>);</span><br><span class="line">		File cj = <span class="keyword">new</span> File(<span class="string">"和平精英"</span>, <span class="number">300</span>);</span><br><span class="line">		relax.add(music);</span><br><span class="line">		relax.add(wz);</span><br><span class="line">		relax.add(cj);</span><br><span class="line">		</span><br><span class="line">		Directory read = <span class="keyword">new</span> Directory(<span class="string">"我的阅读"</span>);</span><br><span class="line">		File book = <span class="keyword">new</span> File(<span class="string">"学习书籍"</span>, <span class="number">200</span>);</span><br><span class="line">		File novel = <span class="keyword">new</span> File(<span class="string">"娱乐小说"</span>, <span class="number">200</span>);</span><br><span class="line">		read.add(book);</span><br><span class="line">		read.add(novel);</span><br><span class="line"></span><br><span class="line">		root.add(life);</span><br><span class="line">		root.add(work);</span><br><span class="line">		root.add(relax);</span><br><span class="line">		root.add(read);</span><br><span class="line"></span><br><span class="line">		root.printList(<span class="string">"D:"</span>);</span><br><span class="line">		System.out.println(<span class="string">"================="</span>);</span><br><span class="line">		work.printList(<span class="string">"work"</span>);</span><br><span class="line">		System.out.println(<span class="string">"================="</span>);</span><br><span class="line">		novel.printList(<span class="string">"novel"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组合模式的角色"><a href="#组合模式的角色" class="headerlink" title="组合模式的角色"></a>组合模式的角色</h4><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/zh2.png" alt></p>
<ul>
<li><p>组件 （Component） 接口描述了树中简单项目和复杂项目所共有的操作.</p>
</li>
<li><p>叶节点 （Leaf） 是树的基本结构, 它不包含子项目.<br>一般情况下, 叶节点最终会完成大部分的实际工作, 因为它们无法将工作指派给其他部分.</p>
</li>
<li><p>容器 （Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位. 容器不知道其子项目所属的具体类, 它只通过通用的组件接口与其子项目交互.<br>容器接收到请求后会将工作分配给自己的子项目, 处理中间结果, 然后将最终结果返回给客户端.</p>
</li>
<li><p>客户端 （Client） 通过组件接口与所有项目交互. 因此, 客户端能以相同方式与树状结构中的简单或复杂项目交互.</p>
</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li><p><strong>如果你需要实现树状对象结构, 可以使用组合模式.</strong><br>组合模式为你提供了两种共享公共接口的基本元素类型： 简单叶节点和复杂容器. 容器中可以包含叶节点和其他容器. 这使得你可以构建树状嵌套递归对象结构.</p>
</li>
<li><p><strong>如果你希望客户端代码以相同方式处理简单和复杂元素, 可以使用该模式.</strong><br>组合模式中定义的所有元素共用同一个接口. 在这一接口的帮助下, 客户端不必在意其所使用的对象的具体类.</p>
</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点<ul>
<li>你可以利用多态和递归机制更方便地使用复杂树结构.</li>
<li>开闭原则. 无需更改现有代码, 你就可以在应用中添加新元素, 使其成为对象树的一部分.</li>
</ul>
</li>
<li>缺点<ul>
<li>开闭原则. 无需更改现有代码, 你就可以在应用中添加新元素, 使其成为对象树的一部分.</li>
</ul>
</li>
</ul>
<h4 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h4><ul>
<li>桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似. 实际上, 它们都基于组合模式——即将工作委派给其他对象, 不过也各自解决了不同的问题. 模式并不只是以特定方式组织代码的配方, 你还可以使用它们来和其他开发者讨论模式所解决的问题.</li>
<li>可以使用迭代器模式来遍历组合树.</li>
<li>可以使用访问者模式对整个组合树执行操作.</li>
<li>可以使用享元模式实现组合树的共享叶节点以节省内存.</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Strategy模式</title>
    <url>/2020/03/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BStrategy%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/cl.png" alt></p>
<a id="more"></a>
<p>在策略模式（Strategy Pattern）中,一个类的行为或其算法可以在运行时更改.</p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>策略模式比较简单,其实就是使用抽象类或者接口,定义一个方法,然后子类来实现相应的方法,之后通过一个新的类来使用这个已经定义好的组件,使用委托(组合)的方式,让定义的接口根据多态来灵活的使用相应的实现方法,最终完成一定的功能.和Builder模式比起来,Builder中新建的类还要对接口中的元素方法进行组合和操作,而策略模式只用一个方法就可以,没有这种复杂的操作,就是简单的使用已经定义好的方法,不用再次封装操作.和桥接模式相比,差别也是很明显的,桥接是功能层次和实现层次分离,而策略模式是方便扩充策略,但是这几种模式的某些部分是很类似的,只不过完成的任务有些许不同而已.</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>示例1：<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/cl3.png" alt><br>Sorter.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Strategy.Sample1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sorter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable []data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
BubbleSorter.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Strategy.Sample1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSorter</span> <span class="keyword">implements</span> <span class="title">Sorter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; data.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (data[i].compareTo(data[j]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					Comparable temp = data[i];</span><br><span class="line">					data[i] = data[j];</span><br><span class="line">					data[j] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>QuickSorter.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Strategy.Sample1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSorter</span> <span class="keyword">implements</span> <span class="title">Sorter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> low = <span class="number">0</span>, high = data.length - <span class="number">1</span>;</span><br><span class="line">		Qsort(data, low, high);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/************** 快速排序 *****************/</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Partiton</span><span class="params">(Comparable[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">		Comparable temp, pivotkey;</span><br><span class="line">		pivotkey = data[low]; <span class="comment">// 选取支点</span></span><br><span class="line">		temp = pivotkey; <span class="comment">// 暂存支点</span></span><br><span class="line">		<span class="keyword">while</span> (low &lt; high) <span class="comment">// 条件，相等则结束</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (low &lt; high &amp;&amp; data[high].compareTo(pivotkey) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				high--;<span class="comment">// 左移</span></span><br><span class="line">			&#125;</span><br><span class="line">			data[low] = data[high];<span class="comment">// 覆盖</span></span><br><span class="line">			<span class="keyword">while</span> (low &lt; high &amp;&amp; data[low].compareTo(pivotkey) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				low++; <span class="comment">// 右移</span></span><br><span class="line">			&#125;</span><br><span class="line">			data[high] = data[low];<span class="comment">// 覆盖</span></span><br><span class="line">		&#125;</span><br><span class="line">		data[low] = temp; <span class="comment">// 恢复</span></span><br><span class="line">		<span class="keyword">return</span> low; <span class="comment">// 返回分界点位置</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Qsort</span><span class="params">(Comparable[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> pivot;</span><br><span class="line">		<span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">			pivot = Partiton(data, low, high); <span class="comment">// 获得分界点位置</span></span><br><span class="line">			Qsort(data, low, pivot - <span class="number">1</span>); <span class="comment">// 排左边</span></span><br><span class="line">			Qsort(data, pivot + <span class="number">1</span>, high);<span class="comment">// 右边</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SortAndPrint.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Strategy.Sample1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortAndPrint</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Comparable[] data;</span><br><span class="line">	<span class="keyword">private</span> Sorter sorter;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SortAndPrint</span><span class="params">(Comparable[] data, Sorter sorter)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">		<span class="keyword">this</span>.sorter = sorter;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execuate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		printResult();</span><br><span class="line">		sorter.sort(data);</span><br><span class="line">		printResult();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"========================="</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">			System.out.print(data[i] + <span class="string">"  "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"\n========================="</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Strategy.Sample1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Comparable[] data1 = &#123; <span class="string">"rlj"</span>, <span class="string">"bb"</span>, <span class="string">"love"</span>, <span class="string">"forever"</span> &#125;;</span><br><span class="line">		SortAndPrint sap1 = <span class="keyword">new</span> SortAndPrint(data1, <span class="keyword">new</span> QuickSorter());</span><br><span class="line">		System.out.println(<span class="string">"=====策略一======"</span>);</span><br><span class="line">		sap1.execuate();</span><br><span class="line">		System.out.println(<span class="string">"=====策略二======"</span>);</span><br><span class="line">		Comparable[] data2 = &#123; <span class="string">"rlj"</span>, <span class="string">"jx"</span>, <span class="string">"love"</span>, <span class="string">"forever"</span> &#125;;</span><br><span class="line">		SortAndPrint sap2 = <span class="keyword">new</span> SortAndPrint(data2, <span class="keyword">new</span> BubbleSorter());</span><br><span class="line">		sap2.execuate();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例2：<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/cl.jpg" alt></li>
</ul>
<p>创建一个接口。<br>Strategy.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建实现接口的实体类。<br>OperationAdd.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 + num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OperationSubstract.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubstract</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 - num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OperationMultiply.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 * num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建 Context 类。<br>Context.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Context 来查看当它改变策略 Strategy 时的行为变化。<br>StrategyPatternDemo.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());    </span><br><span class="line">      System.out.println(<span class="string">"10 + 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubstract());      </span><br><span class="line">      System.out.println(<span class="string">"10 - 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());    </span><br><span class="line">      System.out.println(<span class="string">"10 * 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Strategy-模式中的登场角色"><a href="#Strategy-模式中的登场角色" class="headerlink" title="Strategy 模式中的登场角色"></a>Strategy 模式中的登场角色</h4><ul>
<li><p>策略 (Strategy) 接口是所有具体策略的通用接口, 它声明了一个上下文用于执行策略的方法.</p>
</li>
<li><p>具体策略 (Concrete Strategies) 实现了上下文所用算法的各种不同变体.</p>
</li>
<li><p>上下文 (Context) 维护指向具体策略的引用, 且仅通过策略接口与该对象进行交流.</p>
</li>
<li><p>类图<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/cl2.png" alt></p>
<h4 id="策略模式应用场景"><a href="#策略模式应用场景" class="headerlink" title="策略模式应用场景"></a>策略模式应用场景</h4></li>
<li><p><strong>当你想使用对象中各种不同的算法变体, 并希望能在运行时切换算法时, 可使用策略模式.</strong><br>  策略模式让你能够将对象关联至可以不同方式执行特定子任务的不同子对象, 从而以间接方式在运行时更改对象行为.</p>
</li>
<li><p><strong>当你有许多仅在执行某些行为时略有不同的相似类时, 可使用策略模式.</strong><br>  策略模式让你能将不同行为抽取到一个独立类层次结构中, 并将原始类组合成同一个, 从而减少重复代码.</p>
</li>
<li><p><strong>如果算法在逻辑的上下文中不是特别重要, 使用该模式能将类的业务逻辑与其算法实现细节隔离开来.</strong><br>  策略模式让你能将各种算法的代码、 内部数据和依赖关系与其他代码隔离开来. 不同客户端可通过一个简单接口执行算法, 并能在运行时进行切换.</p>
</li>
<li><p><strong>当类中使用了复杂条件运算符以在同一算法的不同变体中切换时, 可使用该模式.</strong><br>  策略模式将所有继承自同样接口的算法抽取到独立类中, 因此不再需要条件语句. 原始对象并不实现所有算法的变体, 而是将执行工作委派给其中的一个独立算法对象.</p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4></li>
<li><p>从上下文类中找出修改频率较高的算法 （也可能是用于在运行时选择某个算法变体的复杂条件运算符）.</p>
</li>
<li><p>声明该算法所有变体的通用策略接口.</p>
</li>
<li><p>将算法逐一抽取到各自的类中, 它们都必须实现策略接口.</p>
</li>
<li><p>在上下文类中添加一个成员变量用于保存对于策略对象的引用. 然后提供设置器以修改该成员变量. 上下文仅可通过策略接口同策略对象进行交互, 如有需要还可定义一个接口来让策略访问其数据.</p>
</li>
<li><p>客户端必须将上下文类与相应策略进行关联, 使上下文可以预期的方式完成其主要工作</p>
</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li><p>策略模式优点</p>
<ul>
<li>你可以在运行时切换对象内的算法.</li>
<li>你可以将算法的实现和使用算法的代码隔离开来.</li>
<li>你可以使用组合来代替继承.</li>
<li>开闭原则. 你无需对上下文进行修改就能够引入新的策略.</li>
</ul>
</li>
<li><p>策略模式缺点</p>
<ul>
<li>如果你的算法极少发生改变, 那么没有任何理由引入新的类和接口. 使用该模式只会让程序过于复杂.</li>
<li>客户端必须知晓策略间的不同——它需要选择合适的策略.</li>
<li>许多现代编程语言支持函数类型功能, 允许你在一组匿名函数中实现不同版本的算法. 这样, 你使用这些函数的方式就和使用策略对象时完全相同, 无需借助额外的类和接口来保持代码简洁.<h4 id="为什么需要特意编写Strategy角色呢"><a href="#为什么需要特意编写Strategy角色呢" class="headerlink" title="为什么需要特意编写Strategy角色呢"></a>为什么需要特意编写Strategy角色呢</h4>通常在编程时,算法会被卸载具体方法中.而Strategy模式却特意将算法与其他部分分离开来,只是定义了与该算法相关的接口(API),然后在程序中以委托的方法来使用算法.<br>这样看来,程序好像变复杂了.其实不然,例如,当我们想要通过改善算法来提高算法的处理速度时,如果使用了Strategy模式,就不必修改Stragegy角色的接口(API)了,仅仅修稿ConcreteStrategy角色即可.而且<strong>使用委托这种弱关联关系而已很方便地整体替换算法</strong>,例如,如果相比较原来的算法与改进后的算法的处理速度有多大区别,简单地替换下算法即可进行测试.<br>使用Stragegy模式编写想起程序时,可以方便地根据棋手的选择切换AI例程的水平.</li>
</ul>
</li>
</ul>
<h4 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h4><ul>
<li>装饰者模式可让你更改对象的外表, 策略则让你能够改变其本质.</li>
<li>模板方法模式基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法. 策略基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为. 模板方法在类层次上运作, 因此它是静态的. 策略在对象层次上运作, 因此允许在运行时切换行为.</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Bridge模式</title>
    <url>/2020/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BBridge%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/qj.png" alt></p>
<a id="more"></a>
<p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>桥接模式是一种将类的功能层次和实现层次分离的技术，所谓类的功能层次指的是类要实现什么功能，要定义多少个函数进行处理，在功能之中我们会用到继承来定义新的方法同时也能使用父类的方法，这样就构成了一个层次“父类-子类-孙类…”，这就是功能层次，与之对应的就是实现层次了，其实也很好理解，如果我们事先确定了完成一件事情的最基本的子功能，那么我们定义这些子功能为接口或者抽象类，然后使用实现类来进行实现，这样一个抽象类，多个实现类，（抽象类——&gt;(实现类1，实现类2，实现类…)）这样的结构就是实现层次，可以看到高度一直为2，而功能层次高度为N(N为继承的层次）。那么可不可以将这两者分离呢，一方面我们知道一个类的基础子功能并且能够使用到这些子功能的实现，另一方面我们可以在这些子功能的基础上定义出我们自己需要的功能（功能层次），如果可以的话，基本的元素就相当于空气、水分等元素，而我们需要的功能就是将这些东西组成一种种不同的物质。这里就用到了委托，或者说是组合。实现了功能层次和实现层次分离的结构，我们称之为桥接模式。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>示例1:<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/qj2.png" alt></li>
</ul>
<p>Display.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Bridge;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DisplayImpl impl;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Display</span><span class="params">(DisplayImpl impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        impl.rawOpen();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        impl.rawPrint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        impl.rawClose();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        open();</span><br><span class="line">        print();                    </span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CountDisplayl.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Bridge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDisplay</span> <span class="keyword">extends</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CountDisplay</span><span class="params">(DisplayImpl impl)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(impl);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiDisplay</span><span class="params">(<span class="keyword">int</span> times)</span> </span>&#123; <span class="comment">// 循环显示times次</span></span><br><span class="line">		open();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">			print();</span><br><span class="line">		&#125;</span><br><span class="line">		close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DisplayImpl.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Bridge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rawOpen</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rawPrint</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rawClose</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>l<br>StringDisplayImpl.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Bridge;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDisplayImpl</span> <span class="keyword">extends</span> <span class="title">DisplayImpl</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String string; <span class="comment">// 要显示的字符串</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> width; <span class="comment">// 以字节单位计算出的字符串的宽度</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StringDisplayImpl</span><span class="params">(String string)</span> </span>&#123; <span class="comment">// 构造函数接收要显示的字符串string</span></span><br><span class="line">		<span class="keyword">this</span>.string = string; <span class="comment">// 将它保存在字段中</span></span><br><span class="line">		<span class="keyword">this</span>.width = string.getBytes().length; <span class="comment">// 把字符串的宽度也保存在字段中，以供使用。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rawOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		printLine();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rawPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"|"</span> + string + <span class="string">"|"</span>); <span class="comment">// 前后加上"|"并显示</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rawClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		printLine();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"+"</span>); <span class="comment">// 显示用来表示方框的角的"+"</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; i++) &#123; <span class="comment">// 显示width个"-"</span></span><br><span class="line">			System.out.print(<span class="string">"-"</span>); <span class="comment">// 将其用作方框的边框</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"+"</span>); <span class="comment">// 显示用来表示方框的角的"+"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Bridge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Display d1 = <span class="keyword">new</span> Display(<span class="keyword">new</span> StringDisplayImpl(<span class="string">"Hello, China."</span>));</span><br><span class="line">        Display d2 = <span class="keyword">new</span> CountDisplay(<span class="keyword">new</span> StringDisplayImpl(<span class="string">"Hello, World."</span>));</span><br><span class="line">        CountDisplay d3 = <span class="keyword">new</span> CountDisplay(<span class="keyword">new</span> StringDisplayImpl(<span class="string">"Hello, Universe."</span>));</span><br><span class="line">        d1.display();</span><br><span class="line">        d2.display();</span><br><span class="line">        d3.display();</span><br><span class="line">        d3.multiDisplay(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以实现用其他的形式”显示”,比如实现”显示字符串若干(随机)次”的功能.</p>
<blockquote>
<p>写这段代码的时候,感觉和对象适配器模式实现很像.都用到了委托</p>
</blockquote>
<ul>
<li>示例2:<br>从晚上找到了这个例子,感觉很生动形象:<br>设备<code>Device</code>类作为实现部分， 而 遥控器<code>Remote</code>类则作为抽象部分。</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/qj3.png" alt></p>
<blockquote>
<p>最初类层次结构被拆分为两部分,设备和遥控器</p>
</blockquote>
<p>遥控器基类声明了一个指向设备对象的引用成员变量。 所有遥控器通过通用设备接口与设备进行交互， 使得同一个遥控器可以支持不同类型的设备。</p>
<p>同时可以开发独立于设备类的遥控器类， 只需新建一个遥控器子类即可。 例如， 基础遥控器可能只有两个按钮， 但你可在其基础上扩展新功能， 比如额外的一节电池或一块触摸屏。</p>
<p>客户端代码通过遥控器构造函数将特定种类的遥控器与设备对象连接起来。</p>
<p>这里只提供伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// “抽象部分”定义了两个类层次结构中“控制”部分的接口。它管理着一个指向“实</span></span><br><span class="line"><span class="comment">// 现部分”层次结构中对象的引用，并会将所有真实工作委派给该对象。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteControl</span> <span class="title">is</span></span></span><br><span class="line">    protected field device: Device</span><br><span class="line">    <span class="function">constructor <span class="title">RemoteControl</span><span class="params">(device: Device)</span> is</span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>.device </span>= device</span><br><span class="line">    <span class="function">method <span class="title">togglePower</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(device.isEnabled()</span>) then</span></span><br><span class="line"><span class="function">            device.<span class="title">disable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">else</span></span></span><br><span class="line"><span class="function">            device.<span class="title">enable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    method <span class="title">volumeDown</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        device.<span class="title">setVolume</span><span class="params">(device.getVolume()</span> - 10)</span></span><br><span class="line"><span class="function">    method <span class="title">volumeUp</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        device.<span class="title">setVolume</span><span class="params">(device.getVolume()</span> + 10)</span></span><br><span class="line"><span class="function">    method <span class="title">channelDown</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        device.<span class="title">setChannel</span><span class="params">(device.getChannel()</span> - 1)</span></span><br><span class="line"><span class="function">    method <span class="title">channelUp</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        device.<span class="title">setChannel</span><span class="params">(device.getChannel()</span> + 1)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 你可以独立于设备类的方式从抽象层中扩展类。</span></span></span><br><span class="line"><span class="function">class AdvancedRemoteControl extends RemoteControl is</span></span><br><span class="line"><span class="function">    method <span class="title">mute</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        device.<span class="title">setVolume</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// “实现部分”接口声明了在所有具体实现类中通用的方法。它不需要与抽象接口相</span></span></span><br><span class="line"><span class="function"><span class="comment">// 匹配。实际上，这两个接口可以完全不一样。通常实现接口只提供原语操作，而</span></span></span><br><span class="line"><span class="function"><span class="comment">// 抽象接口则会基于这些操作定义较高层次的操作。</span></span></span><br><span class="line"><span class="function">interface Device is</span></span><br><span class="line"><span class="function">    method <span class="title">isEnabled</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    method <span class="title">enable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    method <span class="title">disable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    method <span class="title">getVolume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    method <span class="title">setVolume</span><span class="params">(percent)</span></span></span><br><span class="line"><span class="function">    method <span class="title">getChannel</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    method <span class="title">setChannel</span><span class="params">(channel)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 所有设备都遵循相同的接口。</span></span></span><br><span class="line"><span class="function">class Tv implements Device is</span></span><br><span class="line"><span class="function">    <span class="comment">// ...</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class Radio implements Device is</span></span><br><span class="line"><span class="function">    <span class="comment">// ...</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 客户端代码中的某个位置。</span></span></span><br><span class="line"><span class="function">tv </span>= <span class="keyword">new</span> Tv()</span><br><span class="line">remote = <span class="keyword">new</span> RemoteControl(tv)</span><br><span class="line">remote.togglePower()</span><br><span class="line"></span><br><span class="line">radio = <span class="keyword">new</span> Radio()</span><br><span class="line">remote = <span class="keyword">new</span> AdvancedRemoteControl(radio)</span><br></pre></td></tr></table></figure>

<h4 id="桥接模式-适合场景"><a href="#桥接模式-适合场景" class="headerlink" title="桥接模式 适合场景"></a>桥接模式 适合场景</h4><ul>
<li><p><strong>如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。</strong><br>类的代码行数越多， 弄清其运作方式就越困难， 对其进行修改所花费的时间就越长。 一个功能上的变化可能需要在整个类范围内进行修改， 而且常常会产生错误， 甚至还会有一些严重的副作用。</p>
<p>  桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。</p>
</li>
<li><p><strong>如果你希望在几个独立维度上扩展一个类， 可使用该模式。</strong><br>桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。</p>
</li>
<li><p><strong>如果你需要在运行时切换不同实现方法， 可使用桥接模式。</strong></p>
</li>
</ul>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ol>
<li><p>明确类中独立的维度。 独立的概念可能是： 抽象/平台， 域/基础设施， 前端/后端或接口/实现。</p>
</li>
<li><p>了解客户端的业务需求， 并在抽象基类中定义它们。</p>
</li>
<li><p>确定在所有平台上都可执行的业务。 并在通用实现接口中声明抽象部分所需的业务。</p>
</li>
<li><p>为你域内的所有平台创建实现类， 但需确保它们遵循实现部分的接口。</p>
</li>
<li><p>在抽象类中添加指向实现类型的引用成员变量。 抽象部分会将大部分工作委派给该成员变量所指向的实现对象。</p>
</li>
<li><p>如果你的高层逻辑有多个变体， 则可通过扩展抽象基类为每个变体创建一个精确抽象。</p>
</li>
<li><p>客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。 此后， 客户端只需与抽象对象进行交互， 无需和实现对象打交道。</p>
</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li><p>桥接模式优点</p>
<ul>
<li><p>你可以创建与平台无关的类和程序。</p>
</li>
<li><p>客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。</p>
</li>
<li><p>开闭原则。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。</p>
</li>
<li><p>单一职责原则。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。</p>
</li>
</ul>
</li>
<li><p>桥接模式缺点</p>
<ul>
<li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 – 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。<h4 id="Bridge-模式中的登场角色"><a href="#Bridge-模式中的登场角色" class="headerlink" title="Bridge 模式中的登场角色"></a>Bridge 模式中的登场角色</h4></li>
</ul>
</li>
<li><p>Abstraction (抽象化)<br>该角色位于”类的功能层次结构”的最上层,它使用了Implementor角色的方法定义了基本的功能.该角色中保存了Implementor角色的实例.<br>Display扮演此角色</p>
</li>
<li><p>RefinedAbstraction(改善后的抽象化)<br>在Abstraction的基础上增加了新功能的角色.<br>由CountDisplay类扮演</p>
</li>
<li><p>Implementor(实现者)<br>该角色位于”类的实现层次结构”的最上层.它定义了用于实现Abstraction角色的接口(API)的方法<br>由 DisplayImpl类扮演此角色.</p>
</li>
<li><p>ConcreteImplementor(具体实现者)<br>该角色负责实现Implementor角色中定义的接口(API).在实例程序中,由StringDisplayImpl类扮演此橘色</p>
</li>
<li><p>Bridge模式的类图<br>类的两个层次结构之间的桥梁是<code>impl</code>字段<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/br.png" alt></p>
<h4 id="拓展思路的要点"><a href="#拓展思路的要点" class="headerlink" title="拓展思路的要点"></a>拓展思路的要点</h4></li>
<li><p>分开后 更容易扩展<br>Bridge模式将 <strong>类的功能层次结构</strong> 与 <strong>类的实现层次结构</strong> 分离开了.将类的者两个层次结构分离开有利于独立地对它们进行扩展.<br>当想要增加功能时,只需要在<strong>类的功能层次结构</strong>一侧增加类即可,不必对”类的实现层次结构”做任何修改.而且,<strong>增加后的共嗯那个可以被”所有的实现”</strong>使用.</p>
</li>
<li><p>继承是强关联,委托是弱关联<br>只有Display类的实例生成时,才与作为参数被传入的类构成关联.例如,在程序中,当Main类生成Display类和CountDisplay类的实例时,才将StringDisplayImpl的实例作为参数传递给Display类和CountDisplay类.<br>如果我们不传递StringDisplayImpl类的实例,而是将其他ConcreteImplementor角色的实例传递给Display类和CountDisplay类,就能很容易地改变实现.这时,发生变化的代码只有Main类,Display类和DisplayImpl类则不需要做任何修改.</p>
</li>
</ul>
<h4 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h4><ul>
<li><p>桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， <a href>适配器模式</a>通常在已有程序中使用， 让相互不兼容的类能很好地合作。</p>
</li>
<li><p>桥接、 <a href>状态模式</a>和<a href>策略模式</a> (在某种程度上包括适配器) 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
</li>
<li><p>你可以将抽象工厂模式和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>桥接模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Abstract Factory模式</title>
    <url>/2020/03/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BAbstract%20Factory%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ab3.png" alt></p>
<a id="more"></a>

<ul>
<li>意图: 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li>
<li>何时使用: 系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</li>
</ul>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote>
<p>Builder模式用来组装复杂的实例，Builder就是我们盖房子的一块块砖头，钢筋和水泥，以及简单的用法，使用监工将这些元素有机的组合在了一起就能够建造整个建筑了，是监工将这些原材料按照一定的次序和特定的处理流程糅合在了一起，这个过程就是组装了。而现在我们学习抽象工厂模式，将关键零件组装成产品。</p>
</blockquote>
<blockquote>
<p>抽象工厂模式是一个非常复杂的模式，和工厂方法简直差别太大了，但是也有相同之处，那就是抽象工厂也是用了工厂方法来创造产品，只不过抽象工厂模式中包含了零件、产品、工厂、抽象等概念，这样就非常的复杂了，一般还要用到模板方法、迭代器甚至原型模式等，就“抽象”两个字来说，就是将所有的角色都分成两部分，一部分是这个角色的的抽象类，另一部分是这个角色的具体类（实现类），工厂就是沿用了工厂模式，因此抽象工厂模式主要分成两大部分，抽象部分和具体部分，如图所示。</p>
</blockquote>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/af.png" alt></p>
<p>就上面的抽象部分，最重要的就是抽象的工厂类、抽象的零件类（Link和Tray）、抽象的产品类（Page），这两个零件有共同之处，因此通过Item类进行抽象便于两者之间的互通。下面的具体实现部分就是对抽象的实现了，之后我们使用Main类来进行整合，可以发现我们只用对抽象类进行编程，完全不用使用任何的具体类就能实现我们想要的功能，甚至导致编译器在编译的时候还需要指出需要编译的具体类，因为我们使用了<strong>Class.forName()</strong>方法实现了反射。这样的结构看似非常的庞大，其实仔细的推敲，反而妙趣横生，当我们还想创建另一个具体的工厂的时候实在是太简单不过了，原来抽象工厂的代码都不用修改，只用按照相应的抽象实现就可以了，之后我们就可以直接使用了，只用在Main中将<strong>Class.forName()</strong>所指定的类改一下就可以了，非常的方便。凡是有利就有弊，如果我们对抽象工厂中的某些定义不满意了呢，这个时候如果我们对抽象方法进行一定的调整和更改（增加或删除），那么所有实现了该抽象工厂的具体工厂的类都需要进行修改，如果有100个具体工厂，无疑是非常可怕的，因此我们应该理智的取舍，</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>我们将类分成三个部分，这样思路更加清晰，第一部分是抽象工厂中的类，第二部分是具体实现的具体工厂类，第三部分是测试使用的Main类。</p>
<ol>
<li><p>抽象工厂包</p>
<ul>
<li>抽象的零件类 Item.java<br>capation字段表示项目的”标题”<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Abstract_Factory.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> String caption;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(String caption)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.caption = caption;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">makeHTML</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>抽象的零件 Link.java<br>抽象地表示HTML的超链接的类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Abstract_Factory.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Link</span> <span class="keyword">extends</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> String url;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Link</span><span class="params">(String caption, String url)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(caption);</span><br><span class="line">		<span class="keyword">this</span>.url = url;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>抽象的零件:Tray.java<br>表示一个含有多个Link类和Tray类的容器<br>虽然Tray类也继承了Item类的抽象方法makeHTML,但是它并没有实现该方法因此,Tray也是个抽象类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Abstract_Factory.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Tray</span> <span class="keyword">extends</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> ArrayList tray = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Tray</span><span class="params">(String caption)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(caption);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">		tray.add(item);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>抽象的产品:Page.java<br>Page类是抽象地表示HTML页面的类.<br>为了强调调用的是Page类自己的makeHTML方法,我们显示地加上了this.<br>makeHTML是一个抽象方法.有子类实现.<br>output方法是一个简单的 模板模式的 方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Abstract_Factory.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> String title;</span><br><span class="line">	<span class="keyword">protected</span> String author;</span><br><span class="line">	<span class="keyword">protected</span> ArrayList content = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Page</span><span class="params">(String title, String author)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.title = title;</span><br><span class="line">		<span class="keyword">this</span>.author = author;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">		content.add(item);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			String filename = title + <span class="string">".html"</span>;</span><br><span class="line">			Writer writer = <span class="keyword">new</span> FileWriter(filename);</span><br><span class="line">			writer.write(<span class="keyword">this</span>.makeHTML());</span><br><span class="line">			writer.close();</span><br><span class="line">			System.out.println(filename + <span class="string">" 编写完成。"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">makeHTML</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>抽象的工厂:Factory.java<br>getFactory方法可以根据指定的类名生成具体工厂的实例.<br>下文会对Class类的forName方法和newInstance方法进行解释.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Abstract_Factory.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Factory <span class="title">getFactory</span><span class="params">(String classname)</span> </span>&#123;</span><br><span class="line">		Factory factory = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			factory = (Factory) Class.forName(classname).newInstance();<span class="comment">//反射</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			System.err.println(<span class="string">"没有找到 "</span> + classname + <span class="string">"类。"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> factory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Link <span class="title">createLink</span><span class="params">(String caption, String url)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Tray <span class="title">createTray</span><span class="params">(String caption)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Page <span class="title">createPage</span><span class="params">(String title, String author)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Main类<br> 使用工厂将零件组装成产品 Main.java<br> Main类会使用factory生成Link和Tray,然后将Link和Tray都放入Tray中.最后生成Page并将生成结果输出至文件.</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Abstract_Factory;</span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Abstract_Factory.factory.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        if (args.length != 1) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Usage: java Main class.name.of.ConcreteFactory");</span></span><br><span class="line"><span class="comment">//            System.out.println("Example 1: java Main listfactory.ListFactory");</span></span><br><span class="line"><span class="comment">//            System.out.println("Example 2: java Main tablefactory.TableFactory");</span></span><br><span class="line"><span class="comment">//            System.exit(0);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">		String s1 = <span class="string">"com.edu.tju.GOF.Abstract_Factory.listfactory.ListFactory"</span>;</span><br><span class="line">		String s2 = <span class="string">"com.edu.tju.GOF.Abstract_Factory.tablefactory.TableFactory"</span>;</span><br><span class="line">		</span><br><span class="line">		Factory factory = Factory.getFactory(s1);</span><br><span class="line"></span><br><span class="line">		Link people = factory.createLink(<span class="string">"yjn"</span>, <span class="string">"http://tjuyjn.top/"</span>);</span><br><span class="line">		Link gmw = factory.createLink(<span class="string">"rlj"</span>, <span class="string">"https://r1895.github.io/"</span>);</span><br><span class="line"></span><br><span class="line">		Link us_yahoo = factory.createLink(<span class="string">"Yahoo!"</span>, <span class="string">"http://www.yahoo.com/"</span>);</span><br><span class="line">		Link jp_yahoo = factory.createLink(<span class="string">"Yahoo!Japan"</span>, <span class="string">"http://www.yahoo.co.jp/"</span>);</span><br><span class="line">		Link excite = factory.createLink(<span class="string">"Excite"</span>, <span class="string">"http://www.excite.com/"</span>);</span><br><span class="line">		Link google = factory.createLink(<span class="string">"Google"</span>, <span class="string">"http://www.google.com/"</span>);</span><br><span class="line"></span><br><span class="line">		Tray traynews = factory.createTray(<span class="string">"友链"</span>);</span><br><span class="line">		traynews.add(people);</span><br><span class="line">		traynews.add(gmw);</span><br><span class="line"></span><br><span class="line">		Tray trayyahoo = factory.createTray(<span class="string">"Yahoo!"</span>);</span><br><span class="line">		trayyahoo.add(us_yahoo);</span><br><span class="line">		trayyahoo.add(jp_yahoo);</span><br><span class="line"></span><br><span class="line">		Tray traysearch = factory.createTray(<span class="string">"检索引擎"</span>);</span><br><span class="line">		traysearch.add(trayyahoo);</span><br><span class="line">		traysearch.add(excite);</span><br><span class="line">		traysearch.add(google);</span><br><span class="line"></span><br><span class="line">		Page page = factory.createPage(<span class="string">"LinkPage"</span>, <span class="string">"Jason"</span>);</span><br><span class="line">		page.add(traynews);</span><br><span class="line">		page.add(traysearch);</span><br><span class="line">		page.output();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>具体工厂包</p>
<ul>
<li><p>ListFactory.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Abstract_Factory.listfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Abstract_Factory.factory.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Link <span class="title">createLink</span><span class="params">(String caption, String url)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ListLink(caption, url);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Tray <span class="title">createTray</span><span class="params">(String caption)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ListTray(caption);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Page <span class="title">createPage</span><span class="params">(String title, String author)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ListPage(title, author);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ListLink.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Abstract_Factory.listfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Abstract_Factory.factory.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListLink</span> <span class="keyword">extends</span> <span class="title">Link</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ListLink</span><span class="params">(String caption, String url)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(caption, url);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">makeHTML</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"  &lt;li&gt;&lt;a href=\""</span> + url + <span class="string">"\"&gt;"</span> + caption + <span class="string">"&lt;/a&gt;&lt;/li&gt;\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ListLink类和ListTray类都是Item类的子类,所以可以放心调用makeHTML方法.</p>
</li>
<li><p>ListTray.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Abstract_Factory.listfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Abstract_Factory.factory.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTray</span> <span class="keyword">extends</span> <span class="title">Tray</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ListTray</span><span class="params">(String caption)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(caption);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">makeHTML</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		buffer.append(<span class="string">"&lt;li&gt;\n"</span>);</span><br><span class="line">		buffer.append(caption + <span class="string">"\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;ul&gt;\n"</span>);</span><br><span class="line">		Iterator it = tray.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Item item = (Item) it.next();</span><br><span class="line">			buffer.append(item.makeHTML());</span><br><span class="line">		&#125;</span><br><span class="line">		buffer.append(<span class="string">"&lt;/ul&gt;\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;/li&gt;\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> buffer.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ListPage.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Abstract_Factory.listfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Abstract_Factory.factory.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListPage</span> <span class="keyword">extends</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ListPage</span><span class="params">(String title, String author)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(title, author);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">makeHTML</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		buffer.append(<span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;body&gt;\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;h1&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;ul&gt;\n"</span>);</span><br><span class="line">		Iterator it = content.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Item item = (Item) it.next();</span><br><span class="line">			buffer.append(item.makeHTML());</span><br><span class="line">		&#125;</span><br><span class="line">		buffer.append(<span class="string">"&lt;/ul&gt;\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;hr&gt;&lt;address&gt;"</span> + author + <span class="string">"&lt;/address&gt;"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;/body&gt;&lt;/html&gt;\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> buffer.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后效果图是这样的<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ab1.png" alt></p>
</li>
</ul>
</li>
</ol>
<p>可以看到完全组成了一个网页。到了这里大家可能很质疑，难道费了这么大的功夫就是为了实现这么简单的功能？！其实这里我们可以看到抽象工厂的强大之处，零件的组装与嵌套，相互关联，通过迭代器、模板方法、工厂方法等模式最终实现了这种功能，可扩展性非常之强大，如果还要生成其他种类的工厂，将非常的方便，直接写实现类就可以了，其他代码基本上不需要改动，这样的功能可以说非常强大了，至今为止我们很多的代码都是<code>强耦合</code>的，很难实现复用，而这个抽象的工厂就可以实现高层次的复用，只需要知道实现类的类名就可以执行了，我们完全可以实现其他工厂，从而实现其他的功能。抽象工厂模式最重要的就是可复用性和完美的隔离性，其中使用了makeHTML()非常多次，通过迭代器来展现了这个方法的多态。灵活使用抽象工厂模式可以说是设计模式真正入门的起点。抽象工厂将抽象零件组装成抽象产品，易于增加具体的工厂难于增加新的零件。</p>
<h4 id="添加其他工厂"><a href="#添加其他工厂" class="headerlink" title="添加其他工厂"></a>添加其他工厂</h4><p>照着上面代码的格式 仿生一个table工厂<br>TableFactor.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Abstract_Factory.tablefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Abstract_Factory.factory.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Link <span class="title">createLink</span><span class="params">(String caption, String url)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> TableLink(caption, url);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Tray <span class="title">createTray</span><span class="params">(String caption)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> TableTray(caption);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Page <span class="title">createPage</span><span class="params">(String title, String author)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> TablePage(title, author);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TableLink.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Abstract_Factory.tablefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Abstract_Factory.factory.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableLink</span> <span class="keyword">extends</span> <span class="title">Link</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TableLink</span><span class="params">(String caption, String url)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(caption, url);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">makeHTML</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"&lt;td&gt;&lt;a href=\""</span> + url + <span class="string">"\"&gt;"</span> + caption + <span class="string">"&lt;/a&gt;&lt;/td&gt;\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TablePage.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Abstract_Factory.tablefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Abstract_Factory.factory.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TablePage</span> <span class="keyword">extends</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TablePage</span><span class="params">(String title, String author)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(title, author);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">makeHTML</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		buffer.append(<span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;body&gt;\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;h1&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;table width=\"80%\" border=\"3\"&gt;\n"</span>);</span><br><span class="line">		Iterator it = content.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Item item = (Item) it.next();</span><br><span class="line">			buffer.append(<span class="string">"&lt;tr&gt;"</span> + item.makeHTML() + <span class="string">"&lt;/tr&gt;"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		buffer.append(<span class="string">"&lt;/table&gt;\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;hr&gt;&lt;address&gt;"</span> + author + <span class="string">"&lt;/address&gt;"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;/body&gt;&lt;/html&gt;\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> buffer.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TableTray.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Abstract_Factory.tablefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Abstract_Factory.factory.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableTray</span> <span class="keyword">extends</span> <span class="title">Tray</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TableTray</span><span class="params">(String caption)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(caption); <span class="comment">// 使用super(...)表达式</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">makeHTML</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		buffer.append(<span class="string">"&lt;td&gt;"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;table width=\"100%\" border=\"1\"&gt;&lt;tr&gt;"</span>);</span><br><span class="line">		buffer.append(</span><br><span class="line">				<span class="string">"&lt;td bgcolor=\"#cccccc\" align=\"center\" colspan=\""</span> + tray.size() + <span class="string">"\"&gt;&lt;b&gt;"</span> + caption + <span class="string">"&lt;/b&gt;&lt;/td&gt;"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;/tr&gt;\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;tr&gt;\n"</span>);</span><br><span class="line">		Iterator it = tray.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Item item = (Item) it.next();</span><br><span class="line">			buffer.append(item.makeHTML());</span><br><span class="line">		&#125;</span><br><span class="line">		buffer.append(<span class="string">"&lt;/tr&gt;&lt;/table&gt;"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;/td&gt;"</span>);</span><br><span class="line">		<span class="keyword">return</span> buffer.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ab2.png" alt></p>
<p>可以看出抽象工厂模式易于增加具体的工厂,但是增加新的零件的话,经编写完成的具体工厂越多,修改的工作量就会越大.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>实现方式:</p>
<ul>
<li>以不同的产品类型与产品变体为维度绘制矩阵。</li>
<li>为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。</li>
<li>声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。</li>
<li>为每种产品变体实现一个具体工厂类。</li>
<li>在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类。</li>
<li>找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>你可以确保同一工厂生成的产品相互匹配。</li>
<li>你可以避免客户端和具体产品代码的耦合。</li>
<li>单一职责原则。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。</li>
<li>开闭原则。 向应用程序中引入新产品变体时， 你无需修改客户端代码。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li>QQ 换皮肤，一整套一起换</li>
<li>生成不同操作系统的程序。</li>
</ul>
</li>
<li><p>注意事项:</p>
<ul>
<li>产品族难扩展，产品等级易扩展。<h4 id="Abstract-Factory模式中登场的角色"><a href="#Abstract-Factory模式中登场的角色" class="headerlink" title="Abstract Factory模式中登场的角色"></a>Abstract Factory模式中登场的角色</h4></li>
</ul>
</li>
<li><p>AbstractProduct(抽象产品)<br>AbstractProduct角色负责定义AbstractFactory 角色所生成的抽象零件和产品的接口(API).在程序中,Link,Tray,Page 类扮演此角色.</p>
</li>
<li><p>AbstractFactory(抽象工厂)<br>AbstractFactory角色负责定义用于生成产品的接口(API).在实例程序中,由Factory类扮演此角色.</p>
</li>
<li><p>Client (委托者)<br>Client角色仅会调用AbstractFactory角色和AbstractProduct角色的接口(API)来进行工作,对于具体的零件,产品和工厂一无所知.在程序中,由Main类扮演此角色.</p>
</li>
<li><p>ContreteProduct(具体产品)<br>ConcreteProduct角色负责实现AbstractProduct角色的接口(API).在程序中<br>ListLink类,ListTray类,ListPage类扮演此角色</p>
</li>
<li><p>ConcreteFactory(具体工厂)<br>ConcreteFactory角色负责实现AbstractFactory角色的接口(API).<br>listfactory类扮演此角色</p>
</li>
<li><p>AbstractFactory模式的类图(忽略了Client角色)<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/af1.png" alt></p>
</li>
</ul>
<h4 id="抽象工厂模式-与其他模式的关系"><a href="#抽象工厂模式-与其他模式的关系" class="headerlink" title="抽象工厂模式 与其他模式的关系"></a>抽象工厂模式 与其他模式的关系</h4><ul>
<li>在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。</li>
<li>抽象工厂模式通常基于一组<a href>工厂方法</a>， 但你也可以使用<a href>原型模式</a>来生成这些类的方法。</li>
<li>你可以将抽象工厂和<a href>桥接模式</a>搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</li>
</ul>
<h4 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h4><p><a href="https://www.jianshu.com/p/9be58ee20dee" target="_blank" rel="noopener">传送🚪</a><br><a href="https://baike.baidu.com/item/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/6015990" target="_blank" rel="noopener">JAVA反射机制</a></p>
<p>尽管反射机制带来了极大的灵活性及方便性，但反射也有缺点。反射机制的功能非常强大，但不能滥用。在能不使用反射完成时，尽量不要使用，原因有以下几点：</p>
<ol>
<li>性能问题。<br>Java反射机制中包含了一些动态类型，所以Java虚拟机不能够对这些动态代码进行优化。因此，反射操作的效率要比正常操作效率低很多。我们应该避免在对性能要求很高的程序或经常被执行的代码中使用反射。而且，如何使用反射决定了性能的高低。如果它作为程序中较少运行的部分，性能将不会成为一个问题。</li>
<li>安全限制。<br>使用反射通常需要程序的运行没有安全方面的限制。如果一个程序对安全性提出要求，则最好不要使用反射。</li>
<li>程序健壮性。<br>反射允许代码执行一些通常不被允许的操作，所以使用反射有可能会导致意想不到的后果。反射代码破坏了Java程序结构的抽象性，所以当程序运行的平台发生变化的时候，由于抽象的逻辑结构不能被识别，代码产生的效果与之前会产生差异。</li>
</ol>
<h4 id="熟能生巧"><a href="#熟能生巧" class="headerlink" title="熟能生巧"></a>熟能生巧</h4><p>用抽象工厂模式设计农场类。</p>
<p>分析：农场中除了像畜牧场一样可以养动物，还可以培养植物，如养马、养牛、种菜、种水果等，所以本实例比前面介绍的畜牧场类复杂，必须用抽象工厂模式来实现。</p>
<blockquote>
<p>本例用抽象工厂模式来设计两个农场，一个是韶关农场用于养牛和种菜，一个是上饶农场用于养马和种水果，可以在以上两个农场中定义一个生成动物的方法 newAnimal() 和一个培养植物的方法 newPlant()。</p>
</blockquote>
<p>对马类、牛类、蔬菜类和水果类等具体产品类，由于要显示它们的图像<a href="http://c.biancheng.net/uploads/soft/181113/3-1Q114160J0.zip" target="_blank" rel="noopener">（点此下载图片）</a>，所以它们的构造函数中用到了 JPanel、JLabel 和 ImageIcon 等组件，并定义一个 show() 方法来显示它们。<br>客户端程序通过对象生成器类 ReadXML 读取 XML 配置文件中的数据来决定养什么动物和培养什么植物<a href="http://c.biancheng.net/uploads/soft/181113/3-1Q114160S7.zip" target="_blank" rel="noopener">（点此下载 XML 文件）</a>。其结构图如图所示<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/abf.png" alt></p>
<p><a href="http://c.biancheng.net/view/1351.html" target="_blank" rel="noopener">源码</a></p>
<p><a href="https://www.cnblogs.com/gclokok/p/10029088.html" target="_blank" rel="noopener">抽象工厂和工厂方法的区别</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Builder模式</title>
    <url>/2020/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BBuilder%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/builder1.png" alt></p>
<a id="more"></a>
<p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>意图:将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</li>
<li>解决问题: 主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</li>
<li>何时使用: ：一些基本部件不会变，而其组合经常变化的时候。</li>
<li>解决方法: 将变与不变分离开<ul>
<li>建造者: 创建和提供实例, 导演: 管理创造出来的实例的依赖关系.</li>
</ul>
</li>
<li>实例:<ul>
<li>一些基本部件不会变，而其组合经常变化的时候。</li>
<li>Java中的StringBuilder</li>
</ul>
</li>
<li>优点:<ul>
<li>建造者独立,易扩展</li>
<li>便于控制细节风险</li>
</ul>
</li>
<li>缺点:<ul>
<li>产品必须有共同点,范围有限制.</li>
<li>如内部变化复杂,会有很多的建造类</li>
</ul>
</li>
<li>使用场景<ul>
<li>需要生成的对象具有复杂的内部结构</li>
<li>需要生成的对象内部属性本身相互依赖。</li>
</ul>
</li>
<li>注意事项<ul>
<li>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</li>
</ul>
</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><blockquote>
<p>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。<br>我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。<br>然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。</p>
</blockquote>
<ul>
<li>类图<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/builder.jpg" alt></li>
</ul>
<ol>
<li>创建一个表示食物条目和食品包装的接口<br>Item.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Packing.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建实现Packing接口的实体类<br>Wrapper.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> <span class="keyword">implements</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Wrapper"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Bottle.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bottle</span> <span class="keyword">implements</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Bottle"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建实现 Item 接口的抽象类，该类提供了默认的功能。</li>
</ol>
<p>Burger.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Burger</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Wrapper();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ColdDrink.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ColdDrink</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Bottle();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>创建扩展了 Burger 和 ColdDrink 的实体类。</li>
</ol>
<p>VegBurger.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VegBurger</span> <span class="keyword">extends</span> <span class="title">Burger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">25.0f</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Veg Burger"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ChickenBurger.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChickenBurger</span> <span class="keyword">extends</span> <span class="title">Burger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">50.5f</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Chicken Burger"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Coke.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coke</span> <span class="keyword">extends</span> <span class="title">ColdDrink</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">30.0f</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Coke"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pepsi.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pepsi</span> <span class="keyword">extends</span> <span class="title">ColdDrink</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">35.0f</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Pepsi"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>创建一个 Meal 类，带有上面定义的 Item 对象。<br>Meal.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Item&gt; items = <span class="keyword">new</span> ArrayList&lt;Item&gt;();    </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">      items.add(item);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">float</span> cost = <span class="number">0.0f</span>;</span><br><span class="line">      <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">         cost += item.price();</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">return</span> cost;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showItems</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">         System.out.print(<span class="string">"Item : "</span>+item.name());</span><br><span class="line">         System.out.print(<span class="string">", Packing : "</span>+item.packing().pack());</span><br><span class="line">         System.out.println(<span class="string">", Price : "</span>+item.price());</span><br><span class="line">      &#125;        </span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。<br>MealBuider.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MealBuilder</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Meal <span class="title">prepareVegMeal</span> <span class="params">()</span></span>&#123;</span><br><span class="line">      Meal meal = <span class="keyword">new</span> Meal();</span><br><span class="line">      meal.addItem(<span class="keyword">new</span> VegBurger());</span><br><span class="line">      meal.addItem(<span class="keyword">new</span> Coke());</span><br><span class="line">      <span class="keyword">return</span> meal;</span><br><span class="line">   &#125;   </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Meal <span class="title">prepareNonVegMeal</span> <span class="params">()</span></span>&#123;</span><br><span class="line">      Meal meal = <span class="keyword">new</span> Meal();</span><br><span class="line">      meal.addItem(<span class="keyword">new</span> ChickenBurger());</span><br><span class="line">      meal.addItem(<span class="keyword">new</span> Pepsi());</span><br><span class="line">      <span class="keyword">return</span> meal;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。<br>BuilderPatternDemo.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MealBuilder mealBuilder = <span class="keyword">new</span> MealBuilder();</span><br><span class="line"> </span><br><span class="line">      Meal vegMeal = mealBuilder.prepareVegMeal();</span><br><span class="line">      System.out.println(<span class="string">"Veg Meal"</span>);</span><br><span class="line">      vegMeal.showItems();</span><br><span class="line">      System.out.println(<span class="string">"Total Cost: "</span> +vegMeal.getCost());</span><br><span class="line"> </span><br><span class="line">      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();</span><br><span class="line">      System.out.println(<span class="string">"\n\nNon-Veg Meal"</span>);</span><br><span class="line">      nonVegMeal.showItems();</span><br><span class="line">      System.out.println(<span class="string">"Total Cost: "</span> +nonVegMeal.getCost());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
再举个例子:<br>类图是这样的<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/builder.png" alt></li>
</ol>
<p>Builder 抽象类：<br>Builder.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeString</span><span class="params">(String str)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeTitle</span><span class="params">(String title)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeItems</span><span class="params">(String[] items)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HtmlBuilder 实现类：<br>HtmlBuilder.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter pw;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        filename=<span class="string">"D:\\"</span>+title+<span class="string">".html"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pw=<span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(filename));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        pw.println(<span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;"</span>+title+<span class="string">"&lt;/title&gt;&lt;/head&gt;&lt;body&gt;"</span>);</span><br><span class="line">        pw.println(<span class="string">"&lt;h1&gt;"</span>+title+<span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        pw.println(<span class="string">"&lt;p&gt;"</span>+str+<span class="string">"&lt;/p&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeItems</span><span class="params">(String[] items)</span> </span>&#123;</span><br><span class="line">        pw.println(<span class="string">"&lt;ul&gt;"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;items.length;i++)&#123;</span><br><span class="line">            pw.println(<span class="string">"&lt;li&gt;"</span>+items[i]+<span class="string">"&lt;/li&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pw.println(<span class="string">"&lt;/ul&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pw.println(<span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">        pw.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filename;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TextBuilder 实现类：</p>
<p>TextBuilder.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        sb.append(<span class="string">"====================="</span>);</span><br><span class="line">        sb.append(<span class="string">"["</span>+title+<span class="string">"]"</span>+<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        sb.append(<span class="string">"@"</span>+str+<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeItems</span><span class="params">(String[] items)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;items.length;i++)&#123;</span><br><span class="line">            sb.append(<span class="string">"   ."</span>+items[i]+<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sb.append(<span class="string">"====================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Director 监工类：<br>Director.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder=builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String [] items1=<span class="keyword">new</span> String[]&#123;<span class="string">"奏国歌"</span>,<span class="string">"升国旗"</span>&#125;;</span><br><span class="line">        String [] items2=<span class="keyword">new</span> String[]&#123;<span class="string">"观众鼓掌"</span>,<span class="string">"有序撤离"</span>&#125;;</span><br><span class="line">        builder.makeTitle(<span class="string">"今日头条"</span>);</span><br><span class="line">        builder.makeString(<span class="string">"毕业典礼"</span>);</span><br><span class="line">        builder.makeItems(items1);</span><br><span class="line">        builder.makeString(<span class="string">"典礼结束"</span>);</span><br><span class="line">        builder.makeItems(items2);</span><br><span class="line">        builder.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main 类：<br>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String choice="plain";</span></span><br><span class="line">        String choice=<span class="string">"html"</span>;</span><br><span class="line">        <span class="keyword">if</span>(choice==<span class="string">"plain"</span>)&#123;</span><br><span class="line">            TextBuilder t=<span class="keyword">new</span> TextBuilder();</span><br><span class="line">            Director d=<span class="keyword">new</span> Director(t);</span><br><span class="line">            d.construct();</span><br><span class="line">            System.out.println(t.getResult());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="string">"html"</span>)&#123;</span><br><span class="line">            HtmlBuilder html=<span class="keyword">new</span> HtmlBuilder();</span><br><span class="line">            Director d=<span class="keyword">new</span> Director(html);</span><br><span class="line">            d.construct();</span><br><span class="line">            System.out.println(html.getResult());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            usage();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用 plain，编辑文本文件"</span>);</span><br><span class="line">        System.out.println(<span class="string">"使用 html，编辑网页文件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Builder-模式中的登场角色"><a href="#Builder-模式中的登场角色" class="headerlink" title="Builder 模式中的登场角色"></a>Builder 模式中的登场角色</h4><p>由第二个示例举例</p>
<ul>
<li>Builder (建造者)<br>Builder角色负责定义用于生成实例的接口(API).Builder角色中准备了用于生成实例的方法.<br>示例中,Builder类扮演此角色</li>
<li>ConcreteBuilder (具体的建造者)<br>ConcreteBuilder 角色是负责实现Builder角色的接口的类(API).这里定义了在生成实例时实际被调用的方法.此外,在ConcreteBuilder 角色中还定义了获取最终生成结果的方法.<br>在示例程序中,由TextBuilder类和HTMLBuilder类角色扮演</li>
<li>Director (监工)<br>Director角色负责使用Builder角色的接口(API)来生成示例.它并不依赖于Concrete角色.为了确保不论ConcreteBuilder角色是如何被定义的.Director都能正常工作.它只实现在Builder角色中被定义的方法.<br>Director类扮演此角色</li>
<li>Client (使用者)<br>该角色使用了Builder模式,Main类扮演此角色</li>
<li>Builder模式的类图<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/bu2.png" alt></li>
<li>Builder模式的时序图<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/bu1.png" alt><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>关于Builder模式，我们一定要分清和模板方法的区别，其实就是到底谁承担了”监工”的责任，在模板方法中父类承担了这个责任，而在Builder中，有另外一个专门的类来完成这样的操作，这样做的好处是类的隔离，比如说在Main中，用户根本就不知道有Builder这个抽象类，同样的Director这个监工的根本就不管到底是哪一个实现类，因为任何一个都会被转换为父类，然后进行处理（面向抽象编程的思想），因此很好的实现了隔离，同样的这样设计的好处是复用了，隔离的越好复用起来就越方便，我们完全可以思考，假如还有另外一个监工，使用了不同的construct方法来组装这些复杂的事件，那么对于原来的代码我们不用做任何的修改，只用增加这样的一个监工类，然后定义好相应的方法就好了，之后再Main中使用，这样的一种思想使得我们不用修改源代码，复用（Builder以及其子类）就很方便了，同样的，如果想增加一个新的Builder的子类，只要照着父类的方法进行填充，再加上自己的方法就好了，完全不用修改代码，这也是一种复用，因此这种复用（组件）的思想在设计模式中随处可见，本质就是高内聚低耦合，组件开发，尽量不修改原来的代码，有可扩展性，理解了这一点，我们再看看模板方法，责任全放在了父类里，如果责任需要改变，则必须要修改父类中的责任方法了，这样就修改了原来的代码，不利于复用，这也是两者的本质区别。</li>
</ul>
<h4 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h4><p><strong>谁知道什么?</strong><br>在面向对象编程中,”谁知道什么”是非常重要的.也就是说,我们需要在编程时注意哪个类可以使用哪个方法以及 使用这个方法到底好不好.</p>
<p>在实例2中,Main类并不知道(没有调用)Builder类,它只是调用了Director类的construct方法.这样Director类就会开始工作(Main类对此一无所知),并完成文档的编写.<br>另一方面,Director类知道Builder类,它调用Builder类的方法来编写文档,但是它并不知道它”真正”使用的是哪个类.也就是说它不知道它所使用的类到底是TextBuilder类,HTMLBuilder类还是其他Builder类的其他子类.不过也没有必要知道.因为Director类只是用了Builder类的方法,而Builder类的子类都已经实现了哪些方法.<br>Director类不知道自己使用的究竟是Builder类的哪个子类也好. 这是因为”<strong>只有不知道子类才能替换</strong>“,不论是将TextBuilder的实例传递给Director,还是将HTMLBuilder的实例传递给Director,它都可以正常工作,原因正是Director类还不知道Builder类的具体的子类.<br>正是因为不知道才能够替换,正是因为可以替换,组件才具有高价值.作为设计人员,我们必须时刻关注这种”<strong>可替换性</strong>“</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Prototype模式</title>
    <url>/2020/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BPrototype%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pt1.png" alt></p>
<a id="more"></a>

<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>意图: 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</li>
<li>何时使用:<ul>
<li>当一个系统应该独立于它的产品创建，构成和表示时。</li>
<li>当要实例化的类是在运行时刻指定时，例如，通过动态装载。</li>
<li>为了避免创建一个与产品类层次平行的工厂类层次时。 </li>
<li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li>
</ul>
</li>
<li>解决方法:利用已有的一个原型对象，快速地生成和原型对象一样的实例。<ul>
<li>实现克隆操作，在 JAVA 继承 Cloneable，重写 clone(),在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。(.NET是个什么东西感兴趣的可以自行查阅)</li>
<li>原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。</li>
</ul>
</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pt.png" alt><br>Product.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Prototype.framework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> <span class="keyword">extends</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(String word)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">createClone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Manager.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Prototype.framework.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">    HashMap hashmap = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String key,Product p)</span></span>&#123;</span><br><span class="line">        hashmap.put(key, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        Product p=(Product)hashmap.get(key);</span><br><span class="line">        <span class="keyword">return</span> p.createClone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MessageBox.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Prototype;</span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Prototype.framework.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageBox</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">char</span> decochar;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MessageBox</span><span class="params">(<span class="keyword">char</span> decochar)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.decochar = decochar;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> length = s.getBytes().length;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length + <span class="number">4</span>; i++) &#123;</span><br><span class="line">			System.out.print(decochar);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">""</span>);</span><br><span class="line">		System.out.println(decochar + <span class="string">" "</span> + s + <span class="string">" "</span> + decochar);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length + <span class="number">4</span>; i++) &#123;</span><br><span class="line">			System.out.print(decochar);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Product <span class="title">createClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Product p = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			p = (Product) clone();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Underline.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Prototype.framework.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Underline</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">char</span> ulchar;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Underline</span><span class="params">(<span class="keyword">char</span> ulchar)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ulchar = ulchar;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> length = s.getBytes().length;</span><br><span class="line">		System.out.println(<span class="string">"\""</span> + s + <span class="string">"\""</span>);</span><br><span class="line">		System.out.print(<span class="string">" "</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">			System.out.print(ulchar);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Product <span class="title">createClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Product p = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			p = (Product) clone();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Prototype.framework.Manager;</span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Prototype.framework.Product;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 准备</span></span><br><span class="line">		Manager manager = <span class="keyword">new</span> Manager();</span><br><span class="line">		Underline uline = <span class="keyword">new</span> Underline(<span class="string">'~'</span>);</span><br><span class="line">		MessageBox mbox = <span class="keyword">new</span> MessageBox(<span class="string">'*'</span>);</span><br><span class="line">		MessageBox sbox = <span class="keyword">new</span> MessageBox(<span class="string">'/'</span>);</span><br><span class="line">		manager.register(<span class="string">"strong message"</span>, uline);</span><br><span class="line">		manager.register(<span class="string">"warning box"</span>, mbox);</span><br><span class="line">		manager.register(<span class="string">"slash box"</span>, sbox);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 生成</span></span><br><span class="line">		Product p1 = manager.create(<span class="string">"strong message"</span>);</span><br><span class="line">		p1.use(<span class="string">"Hello,rlj."</span>);</span><br><span class="line">		Product p2 = manager.create(<span class="string">"warning box"</span>);</span><br><span class="line">		p2.use(<span class="string">"Hello,jason."</span>);</span><br><span class="line">		Product p3 = manager.create(<span class="string">"slash box"</span>);</span><br><span class="line">		p3.use(<span class="string">"Hello,girls."</span>);</span><br><span class="line">		Product p4 = manager.create(<span class="string">"slash box"</span>);</span><br><span class="line">		p3.use(<span class="string">"Hello,girls."</span>);</span><br><span class="line">		System.out.println(p1.getClass() == p2.getClass());<span class="comment">//false</span></span><br><span class="line">		System.out.println(p3.getClass() == p4.getClass());<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="登场角色"><a href="#登场角色" class="headerlink" title="登场角色"></a>登场角色</h4><p>原型模式中有三个登场角色:</p>
<ol>
<li><strong>原型角色(Prototype)</strong>：<br>Product角色负责定义用于复制现有实例来生成新的实例的方法.在示例程序中,由Product接口扮演此角色.</li>
<li><strong>具体原型角色(ConcretePrototype)</strong>：<br>ConcretePrototype 角色负责实现复制现有实例并生成新实例的方法.在示例程序中,由MessageBox类和Underline类扮演此角色.</li>
<li><strong>使用者角色(Client)</strong>：维护一个注册表，并提供一个找出正确实例原型的方法。最后，提供一个获取新实例的方法，用来委托复制实例的方法生成新实例。<br>在实例中Manager类扮演此角色.</li>
</ol>
<h4 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h4><ol>
<li><p>在Java中,我们可以使用new关键字指定类名来生成类的实例.像这样使用new来生成实例时,是必须指定类名的.但是在开发过程中,有时候也会有”在不指定类名的前提下生成实例”的需求.例如一下的情况,我们就不能根据类来生成实例,而要根据现有的实例来生成实例</p>
<ul>
<li>对象种类繁多,无法将它们整合在一个类中时</li>
<li>难以根据类生成实例时<br>  生成实例的过程过于负责,很难根据类来生成实例.</li>
<li>想解耦框架与生成的实例时</li>
</ul>
</li>
<li><p>python 中的 原型模式</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="comment"># 用copy包实现深拷贝(copy.deepcopy())和浅拷贝(copy.copy())</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod,ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line">    _id =<span class="string">""</span></span><br><span class="line">    in_type = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getType</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.in_type</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getID</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setID</span><span class="params">(self,in_id)</span>:</span></span><br><span class="line">        self._id = in_id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clone</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#深拷贝</span></span><br><span class="line">        myclone = copy.deepcopy(self)</span><br><span class="line">        <span class="keyword">return</span> myclone</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span><span class="params">(Shape)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">       self.in_type = <span class="string">"Rectangel"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Inside Rectangle.draw() method."</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span><span class="params">(Shape)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.in_type = <span class="string">"Square"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Inside Square.draw() method."</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span><span class="params">(Shape)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.in_type = <span class="string">"Circle"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Inside Circle.draw() method."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据实体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeCache</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#Python 无静态变量，用开放类变量</span></span><br><span class="line">    shapeMap = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getShape</span><span class="params">(self,shapeID)</span>:</span></span><br><span class="line">        cachedShape = self.shapeMap[shapeID]</span><br><span class="line">        <span class="keyword">return</span> cachedShape.clone()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadCache</span><span class="params">()</span>:</span></span><br><span class="line">        circle1 = Circle()</span><br><span class="line">        circle1.setID(<span class="string">"1"</span>)</span><br><span class="line">        ShapeCache.shapeMap[circle1.getID()] = circle1</span><br><span class="line"></span><br><span class="line">        square1 = Square()</span><br><span class="line">        square1.setID(<span class="string">"2"</span>)</span><br><span class="line">        ShapeCache.shapeMap[square1.getID()] = square1</span><br><span class="line"></span><br><span class="line">        rectangle1 = Rectangle()</span><br><span class="line">        rectangle1.setID(<span class="string">"3"</span>)</span><br><span class="line">        ShapeCache.shapeMap[rectangle1.getID()] = rectangle1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用输出</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ShapeCache.loadCache()</span><br><span class="line">    myShape = ShapeCache()</span><br><span class="line"></span><br><span class="line">    cloneShape1 = myShape.getShape(<span class="string">"1"</span>)</span><br><span class="line">    print(<span class="string">"Shape : %s"</span>  %cloneShape1.getType())</span><br><span class="line">    cloneShape1.draw()</span><br><span class="line"></span><br><span class="line">    cloneShape2 = myShape.getShape(<span class="string">"2"</span>)</span><br><span class="line">    print(<span class="string">"Shape : %s"</span> % cloneShape2.getType())</span><br><span class="line">    cloneShape2.draw()</span><br><span class="line"></span><br><span class="line">    cloneShape3 = myShape.getShape(<span class="string">"3"</span>)</span><br><span class="line">    print(<span class="string">"Shape : %s"</span> % cloneShape3.getType())</span><br><span class="line">    cloneShape3.draw()</span><br></pre></td></tr></table></figure>
</li>
<li><p>clone方法和java.lang.Cloneable接口</p>
<p> Java语言为我们准备了用于复制实例的clone方法.请注意,要想调用clone方法,<strong>被复制对象的类必须实现java.lang.Cloneable接口</strong>,不论是被复制对象的类实现了Cloneable接口还是其某个父类实现Cloneable接口,亦或是被复制对象的类实现了Cloneable接口的子接口都可以.</p>
<p> 实现了Cloneable接口的类的实例可以调用clone 进行复制,clone方法的返回值是复制出的新的实例(clone方法内部所进行的处理是分配与要复制的实例同样大小的空间,接着将要复制的实例字段的值复制到所分配的内存空间中去).</p>
<p> 如果没有实现Cloneable接口的类的实例调用了clone方法,则会在运行时抛出<code>CloneNotSupportedException</code>异常.</p>
</li>
</ol>
<ul>
<li><p>那么clone方法是在哪里定义的呢?<br>clone方法定义在java.lang.Object中.因为Object类是所有Java类的父类,因此所有的Java类都继承了clone方法.</p>
</li>
<li><p>我们需要实现Cloneable的哪些方法呢?<br>提到Cloneable接口,很容易让人误以为Cloneable接口中声明了clone方法,其实这是错误的.在Cloneable接口中并没有声明任何方法.它知识被用来标记”可以使用clone方法进行复制”的.这样的接口被称为<strong>标记接口</strong>.</p>
</li>
<li><p>clone方法进行的是浅拷贝</p>
<h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>个人理解就是,比如说我有一双aj11康扣,有一天刷完鞋丢了.<br>可是我很喜欢这双鞋,所以我又买了一双(深拷贝),并且在这双鞋上签上了名字(<strong>修改对象参数</strong>,不会影响原来的康扣,<strong>重新分配空间</strong>).<br>但是有一天,我突然又找到了我丢的那双,上面一定是没有写着名字的(勉强看作浅拷贝吧.鞋还是原来的鞋)<br><a href="https://www.cnblogs.com/shakinghead/p/7651502.html" target="_blank" rel="noopener">传送🚪</a></p>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4></li>
</ul>
<ol>
<li>除了Cloneable,java中还有哪些常见的标记接口呢?</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
        <tag>Hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Singleton模式</title>
    <url>/2020/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BSingleton%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dl.png" alt></p>
<a id="more"></a>

<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br>注意:</p>
<ul>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ul>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li><p>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
</li>
<li><p>主要解决：一个全局使用的类频繁地创建与销毁。</p>
</li>
<li><p>何时使用：当您想控制实例数目，节省系统资源的时候。</p>
</li>
<li><p>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
</li>
<li><p>关键代码：构造函数是私有的。</p>
</li>
<li><p>应用实例：</p>
<ul>
<li>1、一个班级只有一个班主任。</li>
<li>2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li>
<li>3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>2、避免对资源的多重占用（比如写文件操作）。</li>
</ul>
</li>
<li><p>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
</li>
<li><p>使用场景：</p>
<ul>
<li>1、要求生产唯一序列号。</li>
<li>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。<br>注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</li>
</ul>
</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>SingleObject类有它的构造函数和本身的一个静态实例.<br>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。<br>SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/singleton_pattern_uml_diagram.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.Singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;                                 </span><br><span class="line">        System.out.println(<span class="string">"生成了一个实例。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.edu.tju.Singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Start."</span>);</span><br><span class="line">        Singleton obj1 = Singleton.getInstance();</span><br><span class="line">        Singleton obj2 = Singleton.getInstance();</span><br><span class="line">        <span class="keyword">if</span> (obj1 == obj2) &#123;</span><br><span class="line">            System.out.println(<span class="string">"obj1与obj2是相同的实例。"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"obj1与obj2是不同的实例。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"End."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单例模式的几种实现方法"><a href="#单例模式的几种实现方法" class="headerlink" title="单例模式的几种实现方法"></a>单例模式的几种实现方法</h4><p>当然单例模式有很多种, 很容易想到的就是每次实例的时候,判断系统是否已经有这个单例，如果有则返回，如果没有则创建。<br>我们称乎上述所说的形式为懒汉式,但是,那样的线程是不安全的.</p>
<p><strong>1. 懒汉式,线程不安全</strong></p>
<ul>
<li>是否 Lazy 初始化：是</li>
<li>是否多线程安全：否</li>
<li>实现难度：易</li>
<li>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</li>
</ul>
<blockquote>
<p>注: lazy initialization就是在使用的时候才进行初始化，与之对应的是在类加载的时候就初始化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以利用 加锁 <code>synchronized</code>来解决多线程问题</p>
<p><strong>2.懒汉式,线程安全</strong></p>
<ul>
<li>是否 Lazy 初始化：是</li>
<li>是否多线程安全：是</li>
<li>实现难度：易</li>
<li>描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br>优点：第一次调用才初始化，避免内存浪费。<br>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上文我们使用的是饿汉式的形式<br><strong>3.饿汉式</strong></p>
<ul>
<li>是否 Lazy 初始化：否</li>
<li>是否多线程安全：是</li>
<li>实现难度：易</li>
<li>描述：这种方式比较常用，但容易产生垃圾对象。</li>
<li>优点：没有加锁，执行效率会提高。</li>
<li>缺点：类加载时就初始化，浪费内存。<br>它基于 <code>classloader</code> 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>4.双检锁/双重校验锁（DCL，即 double-checked locking）</strong></p>
<ul>
<li><strong>JDK 版本</strong>：JDK1.5 起</li>
<li>是否 Lazy 初始化：是</li>
<li>是否多线程安全：是</li>
<li>实现难度：较复杂</li>
</ul>
<blockquote>
<p>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注: <a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">volatile传送🚪</a></p>
<p><strong>5.登记式/静态内部类</strong></p>
<ul>
<li>是否 Lazy 初始化：是</li>
<li>是否多线程安全：是</li>
<li>实现难度：一般</li>
<li>描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<blockquote>
<p>这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实例:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6.枚举</strong></p>
<ul>
<li>JDK 版本：JDK1.5 起</li>
<li>是否 Lazy 初始化：否</li>
<li>是否多线程安全：是</li>
<li>实现难度：易<blockquote>
<p>描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>通过枚举创建单例模式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//定义一个静态枚举类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">enum</span> SingletonEnum&#123;</span><br><span class="line">        <span class="comment">//创建一个枚举对象，该对象天生为单例</span></span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> User user;</span><br><span class="line">        <span class="comment">//私有化枚举的构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SingletonEnum</span><span class="params">()</span></span>&#123;</span><br><span class="line">            user=<span class="keyword">new</span> User();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">getInstnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//对外暴露一个获取User对象的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonEnum.INSTANCE.getInstnce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        System.out.println(User.getInstance());</span><br><span class="line">        System.out.println(User.getInstance());</span><br><span class="line">        System.out.println(User.getInstance()==User.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>经验之谈</strong>：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>
<h4 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h4><p>反序列化机制破解单例模式（枚举除外）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreakSingleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//先根据单例模式创建对象(单例模式所以s1,s2是一样的)</span></span><br><span class="line">     Singleton s1=Singleton.getInstance();</span><br><span class="line">     Singleton s2=Singleton.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将s1写入本地某个路径</span></span><br><span class="line">     FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(<span class="string">"本地某个路径下文件"</span>);</span><br><span class="line">     ObjectOutputStream oos=<span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">     oos.writeObject(s1);</span><br><span class="line">     oos.close();</span><br><span class="line">     fos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//从本地某个路径读取写入的对象</span></span><br><span class="line">     ObjectInputStream ois=<span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"和上面的本地参数路径相同"</span>));</span><br><span class="line">    Singleton s3=(Singleton) ois.readObject();</span><br><span class="line">     System.out.println(s1);</span><br><span class="line">     System.out.println(s2);</span><br><span class="line">     System.out.println(s3);<span class="comment">//s3是一个新对象</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何避免实现序列化单例模式的漏洞：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton(); </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//反序列化定义该方法，则不需要创建新对象</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类的加载和初始化时机"><a href="#类的加载和初始化时机" class="headerlink" title="类的加载和初始化时机"></a>类的加载和初始化时机</h4><p><a href="https://www.cnblogs.com/zyrblog/p/9224249.html" target="_blank" rel="noopener">类的加载和初始化时机</a>这篇文章分析的很透彻</p>
<h4 id="单例模式与其他模式的关系-补充"><a href="#单例模式与其他模式的关系-补充" class="headerlink" title="单例模式与其他模式的关系(补充)"></a>单例模式与其他模式的关系(补充)</h4><ul>
<li>外观模式类通常可以使用单例模式类， 因为在大部分情况下一个外观对象就足够了。</li>
<li>抽象工厂模式、 生成器模式和原型模式都可以用单例来实现。</li>
</ul>
<h4 id="static关键字的基本用法"><a href="#static关键字的基本用法" class="headerlink" title="static关键字的基本用法"></a>static关键字的基本用法</h4><ul>
<li><p>static关键字基本概念</p>
<blockquote>
<p>我们可以一句话来概括：方便在没有创建对象的情况下来进行调用。<br>也就是说：被static关键字修饰的不需要创建对象去调用，直接根据类名就可以去访问。对于这个概念，下面根据static关键字的四个基本使用来描述。然后在下一部分再来去分析static的原理，希望你能认真读完。</p>
</blockquote>
</li>
<li><p>static关键字修饰类<br>java里面static一般用来修饰成员变量或函数。但有一种特殊用法是用static修饰内部类，普通类是不允许声明为静态的，只有内部类才可以。下面看看如何使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">// static关键字修饰内部类</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">		InnerClass() &#123;</span><br><span class="line">			System.out.println(<span class="string">"=======静态内部类======"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InnerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"========静态内部方法========"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 直接通过StaticTest美名访问静态内部类InnerClass</span></span><br><span class="line">		InnerClass inner = <span class="keyword">new</span> StaticTest.InnerClass();</span><br><span class="line">		<span class="comment">// 静态内部类可以和普通类一样使用</span></span><br><span class="line">		inner.InnerMethod();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *=======静态内部类======</span></span><br><span class="line"><span class="comment">*========静态内部方法========</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>如果没有用static修饰InterClass，则只能new 一个外部类实例。再通过外部实例创建内部类。</p>
</li>
<li><p>static关键字修饰方法<br>修饰方法的时候，其实跟类一样，可以直接通过类名来进行调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticMethod</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"===========静态方法==========="</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//方式一:直接通过类名</span></span><br><span class="line">		StaticMethod.test();</span><br><span class="line">		<span class="comment">//方式二:</span></span><br><span class="line">		StaticMethod fdd = <span class="keyword">new</span> StaticMethod();</span><br><span class="line">		fdd.test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>static关键字修饰变量</p>
</li>
</ul>
<p>被static修饰的成员变量叫做静态变量，也叫做类变量，说明这个变量是属于这个类的，而不是属于是对象，没有被static修饰的成员变量叫做实例变量，说明这个变量是属于某个具体的对象的。</p>
<p>我们同样可以使用上面的方式进行调用变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticVar</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">"Jason"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接通过类名</span></span><br><span class="line">    StaticVar.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>static关键字修饰代码块</li>
</ul>
<p>静态代码块在类第一次被载入时执行，在这里主要是想验证一下，类初始化的顺序:</p>
<blockquote>
<p>父类静态变量<br>父类静态代码块<br>子类静态变量<br>子类静态代码块<br>父类普通变量<br>父类普通代码块<br>父类构造函数<br>子类普通变量<br>子类普通代码块<br>子类构造函数</p>
</blockquote>
<p>代码验证一下:<br>首先我们定义一个父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	<span class="comment">//父类静态代码块</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"父类static"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//父类构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类构造函数"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后定义一个子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"子类static"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类constructor"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Son();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>父类static<br>子类static<br>父类构造函数<br>子类constructor</p>
</blockquote>
<p><a href="https://baijiahao.baidu.com/s?id=1636927461989417537&wfr=spider&for=pc" target="_blank" rel="noopener">深入分析static</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
        <tag>static</tag>
        <tag>类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Factory Method模式</title>
    <url>/2020/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BFactory%20Method%20%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>用Template Method模式来构建生成实例的工厂,就是Factory Method模式.<br>在Factory Method模式中,父类决定实例的生成方式,但并不决定所要生成的具体的类,具体的处理全部交给子类负责.这样就可以将生成实例的框架和实际负责生成实例的类<strong>解耦</strong></p>
<a id="more"></a>

<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>意图: 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</li>
<li>何时使用：我们明确地计划不同条件下创建不同实例时。</li>
<li>应用实例：<ol>
<li>您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 </li>
<li>Hibernate 换数据库只需换方言和驱动就可以。</li>
</ol>
</li>
<li>优点:<ul>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。 </li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 </li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ul>
</li>
<li>缺点：<ul>
<li>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</li>
</ul>
</li>
<li>使用场景:<ul>
<li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 </li>
<li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </li>
<li>设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。    </li>
</ul>
</li>
<li>注意事项：<br>  作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 <code>new</code> 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/fm.png" alt></li>
</ul>
<p>Factory.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Factory_Method.framework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Product <span class="title">create</span><span class="params">(String owner)</span> </span>&#123;</span><br><span class="line">		Product p = createProduct(owner);</span><br><span class="line">		registerProduct(p);</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Product <span class="title">createProduct</span><span class="params">(String owner)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">registerProduct</span><span class="params">(Product product)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getAllProductOwner</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Product.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Factory_Method.framework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDCard.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Factory_Method.idcard;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Factory_Method.framework.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDCard</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String owner;</span><br><span class="line"></span><br><span class="line">	IDCard(String owner) &#123;</span><br><span class="line">		System.out.println(<span class="string">"制作"</span> + owner + <span class="string">"的ID卡。"</span>);</span><br><span class="line">		<span class="keyword">this</span>.owner = owner;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"使用"</span> + owner + <span class="string">"的ID卡。"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> owner;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDCardFactory.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Factory_Method.idcard;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Factory_Method.framework.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDCardFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	List owners = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(String owner)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"为 "</span> + owner + <span class="string">" 创造产品成功..."</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> IDCard(owner);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerProduct</span><span class="params">(Product p)</span> </span>&#123;</span><br><span class="line">		String owner = ((IDCard) p).getOwner();</span><br><span class="line">		owners.add(owner);</span><br><span class="line">		System.out.println(<span class="string">"注册 "</span> + owner + <span class="string">" 的产品成功..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllProductOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; owners.size(); i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"产品用户："</span> + owners.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Factory_Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Factory_Method.idcard.*;</span><br><span class="line"><span class="keyword">import</span> com.edu.tju.GOF.Factory_Method.framework.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> IDCardFactory();</span><br><span class="line">        Product card1 = factory.create(<span class="string">"rlj"</span>);</span><br><span class="line">        Product card2 = factory.create(<span class="string">"jason"</span>);</span><br><span class="line">        Product card3 = factory.create(<span class="string">"zjr"</span>);</span><br><span class="line">        card1.use();</span><br><span class="line">        card2.use();</span><br><span class="line">        card3.use();</span><br><span class="line">        factory.getAllProductOwner();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="登场角色"><a href="#登场角色" class="headerlink" title="登场角色"></a>登场角色</h4><ul>
<li><strong>Product (产品)</strong><br>Product角色属于框架的一方,是一个抽象类.它定义了在Factory Method模式中生成的那些实例所持有的接口(API),但具体的处理则由子类ConcreteProduct角色决定.在示例中由Product类扮演此角色.</li>
<li><strong>Creator (创建者)</strong><br>Creator角色属于框架的一方,它是负责生成Product角色的抽象类,但具体的处理则由子类ConcreteCreator角色决定, 在示例中由 Factory类 扮演此角色.<br>Creator角色对实际负责生成的实例ConcreteCreator角色一无所知,它唯一知道的就是,只要调用Product角色和生成实例的方法,就可以生成Product的实例. <code>createProduct</code>就是生成实例的方法.<strong>不用new关键字来生成实例,而是调用生成实例的专用方法来生成实例,这样就可以防止父类与其他具体类耦合.</strong></li>
<li><strong>ConcreteProduct (具体的产品)</strong><br>ConcreteProduct角色属于具体加工的以放,它决定了具体的产品.在示例程序中,由IDCard扮演此角色.</li>
<li><strong>ConcreteCreatror (具体的创建者)</strong><br>ConcreteCreatror角色属于具体加工的一方,它负责生成具体的产品.在示例程序中,由IDFactory类来扮演此角色.</li>
<li>Factory Method模式的类图<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/fmethod.png" alt></li>
</ul>
<h4 id="工厂方法模式适用场景"><a href="#工厂方法模式适用场景" class="headerlink" title="工厂方法模式适用场景"></a>工厂方法模式适用场景</h4><p>在以下情况下可以使用工厂方法模式：</p>
<ul>
<li><p>一个类不知道它所需要的对象的类<br>在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</p>
</li>
<li><p>一个类通过其子类来指定创建哪个对象<br>在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</p>
</li>
<li><p>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>联系迭代器模式,迭代器间接地使用了工厂方法来创造迭代器对象。在这里我们思考可不可以将工厂类和产品类这两个抽象类改成接口，答案是不能，因为我们使用了模板，模板的定义就要求我们能在父类中定义实际的概括性的操作（模板方法），而接口只能定义协议，不能定义实现；第二个问题，在工厂类里面我们可不可以直接创造产品，答案是不能，因为如果在工厂类的创造产品方法中我们使用new Product()；来做的话，Product就不能为抽象类了，因为抽象类不能new出对象。对于产品类的实现的构造方法里面我们可以看到使用了默认的定义域，这样只能在本包中使用该方法，保证了使用权限安全。<br>迭代器使用了工厂方法，工厂方法使用了模板方法，都是用了继承、接口、抽象等机制因此我们可以看到设计模式不是独立的，而是相互之间有着关系和区别的，在学习的时候我们要善于总结设计模式之间的共同之处和不同之处，活学活用.</p>
</li>
</ul>
<h4 id="生成示例-方法的三种实现方式"><a href="#生成示例-方法的三种实现方式" class="headerlink" title="生成示例,方法的三种实现方式"></a>生成示例,方法的三种实现方式</h4><p>createProduct方法是抽象方法,也就是说需要在子类中实现该方法<br>createProduct方法的实现方式一般有以下3种.</p>
<ul>
<li><p>指定其为抽象方法<br>指定为抽象方法后,子类就必须实现该方法.如果子类不实现该方法,编译器将会报告编译错误.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">createProduct</span><span class="params">(String name)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为其实现默认处理<br>实现默认处理后,如果子类没有实现该方法,将进行默认处理.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Product(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过,这时是使用new关键字创建出实例的.因此不能将Product类定义为抽象类</p>
</li>
<li><p>在其中抛出异常<br>默认处理若为抛出异常,这样一来,如果未在子类种实现该方法,程序就会再运行的时候出错(报错,告知开发人员没有createProduct方法)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> FactoryMethodRuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过,需要另外编写<code>FactoryMethodRuntimeException</code> 异常类</p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Template Method模式</title>
    <url>/2020/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BTemplate%20Method%20%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mb.png" alt></p>
<a id="more"></a>

<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>意图:定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li>
<li>如何解决:在父类中定义处理流程的框架,在子类中实现具体处理的模式.</li>
<li>应用实例:</li>
</ul>
<ol>
<li>盖房子的过程都是一样,地基,走线,房梁,装修等. 不同是我们是盖什么房子,用什么材料盖.</li>
<li>spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</li>
</ol>
<ul>
<li>优点:<ul>
<li>封装不变部分,扩展可变部分.</li>
<li>提供公共代码,便于维护</li>
<li>行为由父类控制,子类实现.</li>
</ul>
</li>
<li>缺点:<ul>
<li>每一个不同的实现都需要一个子类来实现,导致类的个数增加，使得系统更加庞大。</li>
</ul>
</li>
<li>使用场景: </li>
</ul>
<ol>
<li>有多个子类共有的方法，且逻辑相同</li>
<li>重要的、复杂的方法，可以考虑作为模板方法。</li>
</ol>
<ul>
<li>注意事项:为防止恶意操作,一般模板方法都加上 final 关键词。</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。<br>TemplatePatternDemo，我们的演示类使用 Game 来演示模板模式的用法。<br>示例的类图<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mb.jpg" alt></p>
<p>创建一个抽象类，它的模板方法被设置为 final。<br>Game.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模板</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 初始化游戏</span></span><br><span class="line">		initialize();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 开始游戏</span></span><br><span class="line">		startPlay();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 结束游戏</span></span><br><span class="line">		endPlay();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建扩展上述类的实体类<br>Cricket.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cricket</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Cricket Game Finished!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Cricket Game Initialized! Start playing."</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Cricket Game Started. Enjoy the game!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Football.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Football Game Finished!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Football Game Initialized! Start playing."</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Football Game Started. Enjoy the game!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>因此说模板非常容易理解，使用起来也很简单，但是在工程中我们往往将模板与其他模式结合起来，因此我们要认清模板的本质，将具有相同操作的多种事物抽象出这些相同的操作，然后将这些操作有机的整合起来变成模板类，另外也要注意在模板方法的定义final表示此方法不能被继承和重写，这无疑是重要的，规定和法则不能被其他人所改变。</p>
<h4 id="类的层次与抽象类"><a href="#类的层次与抽象类" class="headerlink" title="类的层次与抽象类"></a>类的层次与抽象类</h4><p>类的层次</p>
<ul>
<li>站在子类的角度进行思考<ul>
<li>在子类中可以使用父类中定义的方法</li>
<li>可以通过在子类中增加方法以实现新的功能</li>
<li>在子类中重写父类的方法可以改变程序的行为</li>
</ul>
</li>
<li>站在父类的角度进行思考<ul>
<li>期待子类去实现抽象方法</li>
<li>要求子类去实现抽象方法<br>也就是说,子类具有实现在父类中所声明的抽象方法的责任,因此,这种责任被称为”子类责任”(subclass responsibility)</li>
</ul>
</li>
</ul>
<p>在模板模式中,一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p>
<h4 id="java-final关键字"><a href="#java-final关键字" class="headerlink" title="java final关键字"></a>java final关键字</h4><ul>
<li>修饰类<pre><code>当用final去修饰一个类的时候，表示这个类不能被继承。</code></pre><ul>
<li>a. 被final修饰的类，final类中的成员变量可以根据自己的实际需要设计为final。</li>
<li>b. final类中的成员方法都会被隐式的指定为final方法。</li>
</ul>
</li>
</ul>
<p><strong>说明：</strong><br>   在自己设计一个类的时候，要想好这个类将来是否会被继承，如果可以被继承，则该类不能使用fianl修饰，在这里呢，一般来说工具类我们往往都会设计成为一个fianl类。在JDK中，被设计为final类的有String、System等。</p>
<ul>
<li><p>修饰方法<br> 被final修饰的方法不能被重写。</p>
<ul>
<li>a. 一个类的private方法会隐式的被指定为final方法。</li>
<li>b. 如果父类中有final修饰的方法，那么子类不能去重写。</li>
</ul>
</li>
<li><p>修饰变量<br>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p>
</li>
</ul>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3736238.html" target="_blank" rel="noopener">传送🚪</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>适配器</tag>
        <tag>final</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Adapter模式</title>
    <url>/2020/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BAdapter%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ad.png" alt></p>
<a id="more"></a>

<p>适配器模式(Adapter Pattern) 是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。适配器模式将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。<br>如果学过Android开发的对适配器应该不陌生.</p>
<h4 id="什么时候使用Adapter模式"><a href="#什么时候使用Adapter模式" class="headerlink" title="什么时候使用Adapter模式"></a>什么时候使用Adapter模式</h4><blockquote>
<p>那么如果某个方法就是我们所需要的方法,那么直接在程序中使用不就可以了吗?为什么还要考虑使用Adapter模式呢?那么,究竟应当在什么时候使用Adapter模式呢?</p>
</blockquote>
<p>Adapter模式会对现有的类进行适配,生成新的类.通过该模式可以很方便地创建我们需要的方法群.当出现Bug时,由于我们很明确地知道Bug不在现有的类(Adaptee角色)中,所以只需调查扮演Adaptee角色的类即可.这样一来,代码问题的排查就会变得非常简单.</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li><p>意图: 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</li>
<li><p>何时使用: </p>
<ul>
<li>系统需要使用现有的类，而此类的接口不符合系统的需要。 </li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 </li>
<li>通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</li>
</ul>
</li>
<li><p>应用实例:</p>
<ul>
<li>美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 - JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 </li>
<li>在 LINUX 上运行 WINDOWS 程序。 </li>
<li>JAVA 中的 jdbc。</li>
</ul>
</li>
<li><p>优点:</p>
<ul>
<li>单一职责原则:你可以将接口或数据转换代码从程序主要业务逻辑中分离。</li>
<li>开闭原则:只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</li>
</ul>
</li>
<li><p>缺点:</p>
<ul>
<li>代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。</li>
<li>由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类</li>
</ul>
</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>适配器模式分为两类,所谓“适配”就是适当的配合或者恰当的配合，想一下电源的适配器，完成的作用是将交流电220V转化成不同的直流电压，来对手机、电脑、台灯等充电，如果没有这些适配器，我们的设备早就着火了或者报废了，是一件很可怕的事情，那么适配器就是起到一个转换的作用，将物质（数据）由某种形式转换成另一种形式，使得适配后的一方能够接收和使用，那么我们通过分析也知道，适配器中的角色大体上分为三种使用适配器的角色（手机等）、适配器本身（适配器）、被适配的角色（交流电）。可是作为高内聚低耦合的设计思想指导，我们在手机和适配器中间再加上一层接口，手机直接使用这个接口来使用适配器，而不是高耦合的直接使用，因此主要的角色就有四个了。再考虑到适配器和被适配的角色之间的适配方式，我们可以使用继承来适配也可以使用组合来适配，因此，适配器也就分为通过使用继承的适配器——<strong>类适配器</strong>和使用组合（委托）的适配器——<strong>对象适配器。</strong></p>
<ul>
<li>示例 1 (对象适配器)</li>
</ul>
<p>我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。<br>我们还有另一个接口 AdvancedMediaPlayer 和实现了AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。<br>我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。<br>AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo，我们的演示类使用 AudioPlayer 类来播放各种格式。</p>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/adapter.jpg" alt></p>
<ul>
<li>为媒体播放器和更高级的媒体播放器创建接口<br>MediaPlayer.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
AdvancedMediaPlayer.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建实现了AdvancedMediaPlayer接口的实体类<br>VlcPlayer.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VlcPlayer</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Playing vlc file. Name: "</span> + fileName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 什么也不做</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Mp4Player.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mp4Player</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 什么也不做</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Playing mp4 file. Name: "</span> + fileName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建实现了MediaPlayer接口的适配器类<br>MediaAdapter.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaAdapter</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	AdvancedMediaPlayer advancedMusicPlayer;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MediaAdapter</span><span class="params">(String audioType)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">"vlc"</span>)) &#123;</span><br><span class="line">			advancedMusicPlayer = <span class="keyword">new</span> VlcPlayer();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">"mp4"</span>)) &#123;</span><br><span class="line">			advancedMusicPlayer = <span class="keyword">new</span> Mp4Player();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">"vlc"</span>)) &#123;</span><br><span class="line">			advancedMusicPlayer.playVlc(fileName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">"mp4"</span>)) &#123;</span><br><span class="line">			advancedMusicPlayer.playMp4(fileName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建实现了 MediaPlayer 接口的实体类。</li>
</ul>
<p>AudioPlayer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">	MediaAdapter mediaAdapter;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 播放 mp3 音乐文件的内置支持</span></span><br><span class="line">		<span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">"mp3"</span>)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Playing mp3 file. Name: "</span> + fileName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// mediaAdapter 提供了播放其他文件格式的支持</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">"vlc"</span>) || audioType.equalsIgnoreCase(<span class="string">"mp4"</span>)) &#123;</span><br><span class="line">			mediaAdapter = <span class="keyword">new</span> MediaAdapter(audioType);</span><br><span class="line">			mediaAdapter.play(audioType, fileName);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"Invalid media. "</span> + audioType + <span class="string">" format not supported"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 AudioPlayer 来播放不同类型的音频格式。</li>
</ul>
<p>AdapterPatternDemo.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPatternDemo</span> </span>&#123;</span><br><span class="line">	   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	      AudioPlayer audioPlayer = <span class="keyword">new</span> AudioPlayer();</span><br><span class="line">	 </span><br><span class="line">	      audioPlayer.play(<span class="string">"mp3"</span>, <span class="string">"beyond the horizon.mp3"</span>);</span><br><span class="line">	      audioPlayer.play(<span class="string">"mp4"</span>, <span class="string">"alone.mp4"</span>);</span><br><span class="line">	      audioPlayer.play(<span class="string">"vlc"</span>, <span class="string">"far far away.vlc"</span>);</span><br><span class="line">	      audioPlayer.play(<span class="string">"avi"</span>, <span class="string">"mind me.avi"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>Playing mp3 file. Name: beyond the horizon.mp3<br>Playing mp4 file. Name: alone.mp4<br>Playing vlc file. Name: far far away.vlc<br>Invalid media. avi format not supported</p>
</blockquote>
<ul>
<li>示例 2 (类适配器)</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ad1.png" alt><br>Banner 类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banner</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Banner</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name=name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithParen</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"("</span>+name+<span class="string">")"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithAster</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"*"</span>+name+<span class="string">"*"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Print接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PrintBanner类的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner</span> <span class="keyword">extends</span> <span class="title">Banner</span> <span class="keyword">implements</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintBanner</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"...开始弱适配..."</span>);</span><br><span class="line">        showWithParen();</span><br><span class="line">        System.out.println(<span class="string">"...弱适配成功..."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"...开始强适配..."</span>);</span><br><span class="line">        showWithAster();</span><br><span class="line">        System.out.println(<span class="string">"...强适配成功..."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main类代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Print p = <span class="keyword">new</span> PrintBanner(<span class="string">"Hello"</span>);</span><br><span class="line">        p.printWeak();</span><br><span class="line">        p.printStrong();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例3 (对象适配器)</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ad2.png" alt></p>
<ul>
<li>Banner 类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banner</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Banner</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name=name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithParen</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"("</span>+name+<span class="string">")"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithAster</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"*"</span>+name+<span class="string">"*"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Print抽象类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>PrintBanner类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner</span> <span class="keyword">extends</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Banner banner;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintBanner</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        banner=<span class="keyword">new</span> Banner(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"...开始弱适配..."</span>);</span><br><span class="line">        banner.showWithParen();</span><br><span class="line">        System.out.println(<span class="string">"...弱适配成功..."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"...开始强适配..."</span>);</span><br><span class="line">        banner.showWithAster();</span><br><span class="line">        System.out.println(<span class="string">"...强适配成功..."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Main函数<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Print p=<span class="keyword">new</span> PrintBanner(<span class="string">"Hello"</span>);</span><br><span class="line">        p.printStrong();</span><br><span class="line">        p.printWeak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
示例3与示例2 的Main类和Banner类 都没有改动,只是将Print接口变成了抽象类,那么PrintBanner不能同时继承两个类，因此将Banner对象组合到适配器之中，因此叫做对象适配器.</li>
</ul>
<h4 id="适配器模式-实现方式"><a href="#适配器模式-实现方式" class="headerlink" title="适配器模式 实现方式"></a>适配器模式 实现方式</h4><ol>
<li><p>确保至少有两个类的接口不兼容：</p>
<ul>
<li>一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性服务类。</li>
<li>一个或多个将受益于使用服务类的客户端类。</li>
</ul>
</li>
<li><p>声明客户端接口， 描述客户端如何与服务交互。</p>
</li>
<li><p>创建遵循客户端接口的适配器类。 所有方法暂时都为空。</p>
</li>
<li><p>在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。</p>
</li>
<li><p>依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， 自身只负责接口或数据格式的转换。</p>
</li>
<li><p>客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。</p>
</li>
</ol>
<h4 id="Adapter模式中的登场角色"><a href="#Adapter模式中的登场角色" class="headerlink" title="Adapter模式中的登场角色"></a>Adapter模式中的登场角色</h4><ul>
<li>Target (对象)<br>该角色负责定义所需的方法.<br>由Print接口/类</li>
<li>Client(请求者)<br>该角色负责使用Target角色定义的方法进行具体处理<br>由Main类扮演</li>
<li>Adaptee(被适配)<br>Adaptee是一个持有既定方法的角色<br>Banner类扮演</li>
<li>Adapter(适配)<br>使用Adaptee角色的方法来满足Target角色的需求. 这是Adapter模式的目的.也是Adapter角色的作用</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ad3.png" alt></p>
<h4 id="功能完全不同的类"><a href="#功能完全不同的类" class="headerlink" title="功能完全不同的类"></a>功能完全不同的类</h4><p>当然,当Adaptee角色和Target角色的功能完全不同时,Adapter模式是无法使用的.就如同我们无法用交流100伏特电压让自来水管出水一样.</p>
<h4 id="关于委托"><a href="#关于委托" class="headerlink" title="关于委托"></a>关于委托</h4><p>委托是一种重要的编程方式。与继承相对，是可复用编程的重要方法。</p>
<p>委托指的是在A类中以各种方式利用B类，完成类的功能。</p>
<ul>
<li><p>委托的类型：</p>
<ul>
<li><p>A use B<br>B类对象在A类中出现，但是是以局部变量或是方法参数的形式出现的。A类中并没有B类的对象作为域。</p>
<p>一般称这种delegation为临时性的delegation。</p>
</li>
<li><p>A has B</p>
<p>  B类对象在A类中出现，B类的对象是A类的域之一。B类对象通过A类对象的constructor方法或其它方法从外部输入A类对象。</p>
<p>  A has B有两种情况。</p>
<ul>
<li>Association。A类对象和B类对象之间并没有从属关系。</li>
<li>Aggregation。A类对象由B类聚合而成，但是B类可以脱离A类单独存在。</li>
</ul>
<p>一般称这种delegation为永久性的delegation。</p>
</li>
<li><p>A ispartof B<br>B类对象在A类中出现，B类的对象是A类的域之一。B类对象在A类对象内创建。<br>B类对象不能脱离A类对象独立存在。</p>
<p>一般称这种delegation为永久性的delegation。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>适配器</tag>
        <tag>委托</tag>
      </tags>
  </entry>
  <entry>
    <title>Java每天学一点</title>
    <url>/2020/03/18/Java%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9/</url>
    <content><![CDATA[<p>Only action can relieve the uneasiness.</p>
<a id="more"></a>
<h2 id="Java每天学一点"><a href="#Java每天学一点" class="headerlink" title="Java每天学一点"></a>Java每天学一点</h2><p>当初学java的时候,偷懒没怎么学,敲的代码太少.如今又选了java进阶.<br>从头开始,一点一点学吧.</p>
<h3 id="1-如何对HashMap按键值排序"><a href="#1-如何对HashMap按键值排序" class="headerlink" title="1.如何对HashMap按键值排序"></a>1.如何对HashMap按键值排序</h3><ol>
<li>创建一个简单的HashMap,并插入一些键和值.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; aMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;(); </span><br><span class="line"><span class="comment">//adding keys and values </span></span><br><span class="line">aMap.put(<span class="string">"Five"</span>, <span class="number">5</span>); </span><br><span class="line">aMap.put(<span class="string">"Seven"</span>, <span class="number">7</span>);</span><br><span class="line">aMap.put(<span class="string">"Four"</span>, <span class="number">4</span>);</span><br><span class="line">aMap.put(<span class="string">"Eight"</span>, <span class="number">8</span>); </span><br><span class="line">aMap.put(<span class="string">"One"</span>, <span class="number">1</span>); </span><br><span class="line">aMap.put(<span class="string">"Two"</span>, <span class="number">2</span>); </span><br><span class="line">aMap.put(<span class="string">"Three"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li>
<li>利用Set entrySet(): 返回Map.Entry对象的视图集,即映像中的关键字/值对<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String,Integer&gt;&gt; mapEntries = aMap.entrySet();</span><br></pre></td></tr></table></figure></li>
<li>从上述mapEntries创建LinkedList。我们将排序这个链表来解决顺序问题<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Map.Entry&lt;String,Integer&gt;&gt; aList = <span class="keyword">new</span> LinkedList&lt;Map.Entry&lt;String,Integer&gt;&gt;(mapEntries);</span><br></pre></td></tr></table></figure>
当然 ArrayList应该也是可以的.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sorting the List </span></span><br><span class="line">Collections.sort(aList, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String,Integer&gt;&gt;()&#123;</span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; ele1, Map.Entry&lt;String, Integer&gt; ele2)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> ele1.getValue().compareTo(ele2.getValue()); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>Collections.sort()是一个内置方法,仅排序值的列表。它在Collections类中重载。这两种个方法是<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></span><br></pre></td></tr></table></figure></li>
<li>完整代码为<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.ahui;</span><br><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortHashMapByValues</span> </span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortMapByValues</span><span class="params">(Map&lt;String, Integer&gt; aMap)</span></span>&#123;</span><br><span class="line">		 Set&lt;Map.Entry&lt;String,Integer&gt;&gt; mapEntries = aMap.entrySet();</span><br><span class="line">	     System.out.println(<span class="string">"Values and Keys before sorting "</span>); </span><br><span class="line">	     <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry : mapEntries)</span><br><span class="line">	    	 System.out.println(entry.getKey() + <span class="string">" - "</span>+ entry.getValue()); </span><br><span class="line">	     <span class="comment">//use LinkedList to sort, because insertion of elements in linked list is faster than ArrayList. </span></span><br><span class="line">	     List&lt;Map.Entry&lt;String,Integer&gt;&gt; aList = <span class="keyword">new</span> LinkedList&lt;Map.Entry&lt;String,Integer&gt;&gt;(mapEntries); </span><br><span class="line">	     <span class="comment">// sorting the List </span></span><br><span class="line">	     Collections.sort(aList, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String,Integer&gt;&gt;()&#123;</span><br><span class="line">	    	 <span class="meta">@Override</span> </span><br><span class="line">	         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; ele1, Map.Entry&lt;String, Integer&gt; ele2)</span></span>&#123;</span><br><span class="line">	    		 <span class="keyword">return</span> ele1.getValue().compareTo(ele2.getValue()); </span><br><span class="line">	        &#125;</span><br><span class="line">	     &#125;); </span><br><span class="line">	     <span class="comment">// Storing the list into Linked HashMap to preserve the order of insertion. </span></span><br><span class="line">	     Map&lt;String,Integer&gt; aMap2 = <span class="keyword">new</span> LinkedHashMap&lt;String, Integer&gt;();</span><br><span class="line">	     <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry: aList)&#123;</span><br><span class="line">	    	 aMap2.put(entry.getKey(), entry.getValue()); </span><br><span class="line">	     &#125; </span><br><span class="line">	     <span class="comment">// printing values after sorting of map </span></span><br><span class="line">	     System.out.println(<span class="string">"Values and Keys after sorting "</span>); </span><br><span class="line">	     <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry : aMap2.entrySet())&#123;</span><br><span class="line">	    	 System.out.println(entry.getKey() + <span class="string">" - "</span> + entry.getValue()); </span><br><span class="line">	     &#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Map&lt;String,Integer&gt; aMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;(); </span><br><span class="line">        <span class="comment">//adding keys and values </span></span><br><span class="line">        aMap.put(<span class="string">"Five"</span>, <span class="number">5</span>); </span><br><span class="line">        aMap.put(<span class="string">"Seven"</span>, <span class="number">7</span>);</span><br><span class="line">        aMap.put(<span class="string">"Four"</span>, <span class="number">4</span>);</span><br><span class="line">        aMap.put(<span class="string">"Eight"</span>, <span class="number">8</span>); </span><br><span class="line">        aMap.put(<span class="string">"One"</span>, <span class="number">1</span>); </span><br><span class="line">        aMap.put(<span class="string">"Two"</span>, <span class="number">2</span>); </span><br><span class="line">        aMap.put(<span class="string">"Three"</span>, <span class="number">3</span>); </span><br><span class="line">        sortMapByValues(aMap); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-java中Comparator的用法-排序-分组"><a href="#2-java中Comparator的用法-排序-分组" class="headerlink" title="2.java中Comparator的用法(排序,分组)"></a>2.java中Comparator的用法(排序,分组)</h3><p>下面是javaSE一些使用到Comparator接口的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(T[],Comparator&lt;? <span class="keyword">super</span> T&gt; c);</span><br><span class="line">Collections.sort(List&lt;T&gt; list,Comparator&lt;? <span class="keyword">super</span> T&gt; c);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用场景<ul>
<li>排序</li>
<li>分组</li>
</ul>
</li>
</ul>
<p>排序的例子在上面对<code>HashMap</code>排序已经说过了.<br>我们就直接看分组吧.</p>
<p>使用Comparator和for循环处理列表,来进行分类；通过调用者实现Comparator接口的比较逻辑,来告诉程序应该怎么比较,通过比较之后得结果来进行分组。比如生活中的拳击比赛,会有公斤级的概念,那么程序中应该实现的处理逻辑是只要两个人的体重在同一个区间则为同一组公斤级的选手。下面例子中按照手机的颜色和重量级别两个维度来进行分组,因此分组的核心逻辑其实就是比较逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jason.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorGroup</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Nubia</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> String name;<span class="comment">// 手机名称</span></span><br><span class="line">		<span class="keyword">public</span> String color;<span class="comment">// 颜色</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> weight;<span class="comment">// 重量</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Nubia</span><span class="params">(String name, String color, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">			<span class="keyword">this</span>.color = color;</span><br><span class="line">			<span class="keyword">this</span>.weight = weight;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"Nubia [name="</span> + name + <span class="string">",color="</span> + color + <span class="string">"色, weight="</span> + weight + <span class="string">"g]"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Title</span>:divider</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>:Jason</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>:2019年9月17日</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:TODO 按条件分组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datas_待分组的数据List</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> condition_是否为同一组的判断条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> List&lt;List&lt;T&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;List&lt;T&gt;&gt; divider(Collection&lt;T&gt; datas, Comparator&lt;? <span class="keyword">super</span> T&gt; condition) &#123;</span><br><span class="line">		<span class="comment">// 初始化话分组List&lt;List&lt;T&gt;&gt;</span></span><br><span class="line">		List&lt;List&lt;T&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;T&gt;&gt;();</span><br><span class="line">		<span class="comment">// 是否为同一组数据的标识</span></span><br><span class="line">		<span class="keyword">boolean</span> isSameGroup = <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">// 遍历待分组的完整List数据</span></span><br><span class="line">		<span class="keyword">for</span> (T data : datas) &#123;</span><br><span class="line">			isSameGroup = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; result.size(); j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (condition.compare(data, result.get(j).get(<span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">					isSameGroup = <span class="keyword">true</span>;</span><br><span class="line">					result.get(j).add(data);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!isSameGroup) &#123;</span><br><span class="line">				<span class="comment">// 创建分组List</span></span><br><span class="line">				List&lt;T&gt; groupList = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">				result.add(groupList);</span><br><span class="line">				groupList.add(data);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对分组的List按重量升序排列</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortListNubia</span><span class="params">(List&lt;List&lt;Nubia&gt;&gt; sortNubia)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 对分组的List按重量升序排列</span></span><br><span class="line">		Comparator&lt;List&lt;Nubia&gt;&gt; comparator = <span class="keyword">new</span> Comparator&lt;List&lt;Nubia&gt;&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(List&lt;Nubia&gt; nb1, List&lt;Nubia&gt; nb2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> nb1.get(<span class="number">0</span>).weight - nb2.get(<span class="number">0</span>).weight;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Collections.sort(sortNubia, comparator);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 初始化List数据</span></span><br><span class="line">		List&lt;Nubia&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		list.add(<span class="keyword">new</span> ComparatorGroup().new Nubia(<span class="string">"努比亚z7mini"</span>, <span class="string">"黑金"</span>, <span class="number">143</span>));</span><br><span class="line">		list.add(<span class="keyword">new</span> ComparatorGroup().new Nubia(<span class="string">"努比亚z11mini"</span>, <span class="string">"黑金"</span>, <span class="number">138</span>));</span><br><span class="line">		list.add(<span class="keyword">new</span> ComparatorGroup().new Nubia(<span class="string">"努比亚红魔Mars"</span>, <span class="string">"黑红"</span>, <span class="number">193</span>));</span><br><span class="line">		list.add(<span class="keyword">new</span> ComparatorGroup().new Nubia(<span class="string">"努比亚红魔3 "</span>, <span class="string">"黑红"</span>, <span class="number">215</span>));</span><br><span class="line">		list.add(<span class="keyword">new</span> ComparatorGroup().new Nubia(<span class="string">"努比亚X"</span>, <span class="string">"蓝银"</span>, <span class="number">181</span>));</span><br><span class="line">		list.add(<span class="keyword">new</span> ComparatorGroup().new Nubia(<span class="string">"努比亚布拉格 "</span>, <span class="string">"蓝银"</span>, <span class="number">140</span>));</span><br><span class="line">		<span class="comment">// 按颜色分组</span></span><br><span class="line">		List&lt;List&lt;Nubia&gt;&gt; byColors = divider(list, <span class="keyword">new</span> Comparator&lt;Nubia&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Nubia nb1, Nubia nb2)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// 按颜色分组</span></span><br><span class="line">				<span class="keyword">return</span> nb1.color.compareTo(nb2.color);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">// 按重量升序</span></span><br><span class="line">		sortListNubia(byColors);</span><br><span class="line">		System.out.println(<span class="string">"按颜色分组:"</span>);</span><br><span class="line">		<span class="keyword">for</span> (List&lt;Nubia&gt; list2 : byColors) &#123;</span><br><span class="line">			System.out.println(list2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 按重量分组</span></span><br><span class="line">		List&lt;List&lt;Nubia&gt;&gt; byWeight = divider(list, <span class="keyword">new</span> Comparator&lt;Nubia&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Nubia nb1, Nubia nb2)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// 按重量区间</span></span><br><span class="line">				<span class="keyword">return</span> ((nb1.weight / <span class="number">30</span>) == (nb2.weight / <span class="number">30</span>)) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">// 按重量升序</span></span><br><span class="line">		sortListNubia(byWeight);</span><br><span class="line">		System.out.println(<span class="string">"按重量级分组:"</span>);</span><br><span class="line">		<span class="keyword">for</span> (List&lt;Nubia&gt; list2 : byWeight) &#123;</span><br><span class="line">			System.out.println(list2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<blockquote>
<p>按颜色分组:<br>[Nubia [name=努比亚z7mini,color=黑金色, weight=143g], Nubia [name=努比亚z11mini,color=黑金色, weight=138g]]<br>[Nubia [name=努比亚X,color=蓝银色, weight=181g], Nubia [name=努比亚布拉格 ,color=蓝银色, weight=140g]]<br>[Nubia [name=努比亚红魔Mars,color=黑红色, weight=193g], Nubia [name=努比亚红魔3 ,color=黑红色, weight=215g]]<br>按重量级分组:<br>[Nubia [name=努比亚z7mini,color=黑金色, weight=143g], Nubia [name=努比亚z11mini,color=黑金色, weight=138g], Nubia [name=努比亚布拉格 ,color=蓝银色, weight=140g]]<br>[Nubia [name=努比亚红魔Mars,color=黑红色, weight=193g], Nubia [name=努比亚X,color=蓝银色, weight=181g]]<br>[Nubia [name=努比亚红魔3 ,color=黑红色, weight=215g]]</p>
</blockquote>
<h3 id="3-遍历map的四种方法及Map-entry详解"><a href="#3-遍历map的四种方法及Map-entry详解" class="headerlink" title="3.遍历map的四种方法及Map.entry详解"></a>3.遍历map的四种方法及Map.entry详解</h3><p>Map.entrySet() 这个方法返回的是一个<code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code><br>Map.Entry 是Map中的一个接口,他的用途是表示一个映射项（里面有Key和Value）,而<code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code>表示一个映射项的Set。Map.Entry里有相应的getKey和getValue方法,即JavaBean,让我们能够从一个项中取出Key和Value。</p>
<p>下面是遍历Map的四种方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jason.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">		map.put(<span class="string">"1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">		map.put(<span class="string">"2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">		map.put(<span class="string">"3"</span>, <span class="string">"value3"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第一种：普遍使用,二次取值</span></span><br><span class="line">		System.out.println(<span class="string">"通过Map.keySet遍历key和value："</span>);</span><br><span class="line">		<span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"key= "</span> + key + <span class="string">" and value= "</span> + map.get(key));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第二种</span></span><br><span class="line">		System.out.println(<span class="string">"通过Map.entrySet使用iterator遍历key和value："</span>);</span><br><span class="line">		Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">			System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第三种：推荐,尤其是容量大时</span></span><br><span class="line">		System.out.println(<span class="string">"通过Map.entrySet遍历key和value"</span>);</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第四种</span></span><br><span class="line">		System.out.println(<span class="string">"通过Map.values()遍历所有的value,但不能遍历key"</span>);</span><br><span class="line">		<span class="keyword">for</span> (String v : map.values()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"value= "</span> + v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看HashMap的源代码:会发现,HashMap的底层实现用的是一个Entry数组.<br>我们在HashMap的源码的674行发现了Entry的定义,原来他是HashMap的一个内部类,并且实现了Map.Entry接口<br>我们再看一下Map.Entry这个接口是怎么定义的,发现原来他是Map的一个内部接口并且定义了一些方法<br>原来Entry实现的Map.Entry接口里面定义了getKey(),getValue(),setKey(),setValue()等方法相当于一个javaBean,对键值对进行了一个封装便于后面的操作,从这里我们其实也可以联想到不光是HashMap,譬如LinkedHashMap,TreeMap 等继承自map的容器存储key-value对都应该使用的是Entry只不过组织Entry的形式不一样,HashMap用的是数组加链表的形式,LinkedHashMap用的是链表的形式,TreeMap应该使用的二叉树的形式.想多了解一下的可以查看源码.</p>
<p><a href="https://blog.csdn.net/kyi_zhu123/article/details/52769469" target="_blank" rel="noopener">转自</a></p>
<blockquote>
<p>Only action can relieve the uneasiness.     - 2020-03-18 20:20</p>
</blockquote>
<h3 id="4-常用快捷键"><a href="#4-常用快捷键" class="headerlink" title="4.常用快捷键"></a>4.常用快捷键</h3><ol>
<li>ctrl+o: 快速outline<blockquote>
<p>如果想要查看当前类的方法或某个特定方法，但又不想把代码拉上拉下，也不想使用查找功能的话，就用ctrl+o吧。它可以列出当前类中的所有方法及属性，你只需输入你想要查询的方法名，点击enter就能够直接跳转至你想去的位置。</p>
</blockquote>
</li>
</ol>
<p><img src="/2020/03/18/Java%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9/j1.jpg" alt></p>
<ol start="2">
<li>ctrl+e：快速转换编辑器<blockquote>
<p>这组快捷键将帮助你在打开的编辑器之间浏览。使用ctrl+page down或ctrl+page up可以浏览前后的选项卡，但是在很多文件打开的状态下，ctrl+e会更加有效率。</p>
</blockquote>
</li>
</ol>
<p><img src="/2020/03/18/Java%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9/j2.jpg" alt></p>
<ol start="3">
<li><p>alt + shift + r:重命名</p>
<blockquote>
<p>   重命名属性及方法在几年前还是个很麻烦的事，需要大量使用搜索及替换，以至于代码变得零零散散的。今天的Java IDE提供源码处理功能，Eclipse也是一样。现在，变量和方法的重命名变得十分简单，你会习惯于在每次出现更好替代名称的时候都做一次重命名。要使 用这个功能，将鼠标移动至属性名或方法名上，按下alt+shift+r，输入新名称并点击回车。就此完成。如果你重命名的是类中的一个属性，你可以点击alt+shift+r两次，这会呼叫出源码处理对话框，可以实现get及set方法的自动重命名。</p>
</blockquote>
</li>
<li><p>shift+enter及ctrl+shift+enter</p>
<blockquote>
<p>Shift+enter在当前行之下创建一个空白行，与光标是否在行末无关。Ctrl+shift+enter则在当前行之前插入空白行。</p>
</blockquote>
</li>
<li><p>alt+shift+l以及alt+shift+m：提取本地变量及方法</p>
<blockquote>
<p>源码处理还包括从大块的代码中提取变量和方法的功能。比如，要从一个string创建一个常量，那么就选定文本并按下alt+shift+l即可。如果同 一个string在同一类中的别处出现，它会被自动替换。方法提取也是个非常方便的功能。将大方法分解成较小的、充分定义的方法会极大的减少复杂度，并提 升代码的可测试性。</p>
</blockquote>
</li>
<li><p>Alt+方向键</p>
<blockquote>
<p>这也是个节省时间的法宝。这个组合将当前行的内容往上或下移动。在try/catch部分，这个快捷方式尤其好使。</p>
</blockquote>
</li>
<li><p>ctrl+m</p>
<blockquote>
<p>大显示屏幕能够提高工作效率是大家都知道的。Ctrl+m是编辑器窗口最大化的快捷键。</p>
</blockquote>
</li>
<li><p>ctrl+.及ctrl+1：下一个错误及快速修改。配合Ctrl+Q，快速回到最后一次编辑的地方</p>
<blockquote>
<p>ctrl+.将光标移动至当前文件中的下一个报错处或警告处。这组快捷键我一般与ctrl+1一并使用，即修改建议的快捷键。新版Eclipse的修改建议做的很不错，可以帮你解决很多问题，如方法中的缺失参数，throw/catch exception，未执行的方法等等。</p>
</blockquote>
</li>
<li><p>ctrl+shift+f: 格式化代码</p>
</li>
<li><p>ctrl+Q 回到最后一次编辑的地方</p>
</li>
<li><p>Alt+左右方向键</p>
<blockquote>
<p>我们经常会遇到看代码时Ctrl+左键，层层跟踪，然后迷失在代码中的情况，这时只需要按“Alt+左方向键”就可以退回到上次阅读的位置，同理，按“Alt+右方向键”会前进到刚才退回的阅读位置，就像浏览器的前进和后退按钮一样。</p>
</blockquote>
</li>
<li><p>Ctrl+Shift+O 导入包</p>
</li>
<li><p>ctrl+d 删除当前行</p>
</li>
<li><p>Ctrl+Shift+X 把当前选中的文本全部变味小写<br>Ctrl+Shift+Y 把当前选中的文本全部变为小写</p>
</li>
</ol>
<p>更多快捷键组合可在Eclipse按下ctrl+shift+L查看。</p>
<blockquote>
<p>今天没有新知识,就学下eclipse快捷键吧.eclipse写java用起来还是很方便的.<br>Only action can relieve the uneasiness.            —2020/03/20</p>
</blockquote>
<h3 id="5-耦合和解耦-转载"><a href="#5-耦合和解耦-转载" class="headerlink" title="5.耦合和解耦(转载)"></a>5.耦合和解耦(转载)</h3><p>百度解释:   </p>
<blockquote>
<p>耦合是指两个或两个以上的体系或两种运动形式间通过相互作用而彼此影响以至联合起来的现象。<br>解耦就是用数学方法将两种运动分离开来处理问题。 </p>
</blockquote>
<p>这是形象搞笑的比喻：</p>
<blockquote>
<p>完全可以这么想像嘛，有一对热恋中的男女，水深火热的，谁离开谁都不行了，离开就得死，要是对方有一点风吹草动，这一方就得地动山摇。<br>可以按照琼瑶阿姨的路子继续想象，想成什么样都不过分，他们之间的这种状态就应该叫做“偶合”。<br>他们这么下去，有人看不惯了，有一些掌握话语权的权利机构觉得有必要出面阻止了，这样下去不是个事吖，你得先爱祖国，爱社会，爱人民，爱这大好河山才行啊，<br>于是棒打鸳鸯，让他们之间对对方的需要，抽象成一种生理需要，这就好办了，把她抽象成女人，他抽象成男人，当他需要女人时，就把她当做女人送来，反之亦然，<br>看上去他们仍在一起，没什么变化，实质上呢，他们已经被成功的拆散了，当有一天他需要女人时，来了另外一个女人，嘿嘿 他不会反对的。<br>对方怎么变他也不会关心了。这就是“解偶”。</p>
</blockquote>
<p>较为具体的说明就是有的时候程序需要修改，我只需要改正一部分，单是如果程序的耦合性很强的话就需要从头再写一遍很不划算，而正常的开发中都是改那部分，重写那部分，<br>把配置文件一改就成了，java中通过接口（interface），spring技术中的IOC等实现的解耦合，重写覆盖父类的方法也是一种解耦行为</p>
<p><a href>转载地址忘记了</a></p>
<h3 id="6-贫血模型-充血模型"><a href="#6-贫血模型-充血模型" class="headerlink" title="6.贫血模型,充血模型"></a>6.贫血模型,充血模型</h3><p>程序中级设计讲到了,贫血模型和充血模型.要求设计一个虚拟钱包系统.<br>以该系统理解了贫血模型和充血模型的区别</p>
<ul>
<li>MVC三层架构<ul>
<li>MVC 三层架构中的 M 表示 Model，V 表示 View，C 表示 Controller。<br>它将整个项目分为三层：展示层、逻辑层、数据层</li>
<li>现在很多 Web 或者 App 项目都是前后端分离的，后端负责暴露接口给前端调用。这种情况下，我们一般就将后端项目分为 Repository 层、Service 层、Controller 层。其中，Repository 层负责数据访问，Service 层负责业务逻辑，Controller 层负责暴露接口。<h4 id="钱包业务背景介绍"><a href="#钱包业务背景介绍" class="headerlink" title="钱包业务背景介绍"></a>钱包业务背景介绍</h4></li>
</ul>
</li>
<li>五个功能：充值、支付、提现、查询余额、交易流水。</li>
<li>业务划分两大块：虚拟钱包、三方支付。文中主要涉及虚拟钱包。</li>
<li>交易流水的两种实现方式：<ul>
<li>一条记录，出账入账在一起；</li>
<li>两条记录，支付与被支付。文中推荐第二种。</li>
</ul>
</li>
<li>交易流水还可以分两种形式：<ul>
<li>用户看的，包含交易类型；</li>
<li>系统看的，只有余额的加减。<h4 id="基于贫血模型的传统开发模式"><a href="#基于贫血模型的传统开发模式" class="headerlink" title="基于贫血模型的传统开发模式"></a>基于贫血模型的传统开发模式</h4></li>
</ul>
</li>
</ul>
<ol>
<li>基于虚拟钱包，一个典型的 Web 后端项目的三层结构。</li>
<li>Controller 中，接口实现比较简单，主要就是调用 Service 的方法。</li>
<li>重点说Service 层，VirtualWalletBo 是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑，业务逻辑集中在 VirtualWalletService 中。</li>
</ol>
<h4 id="基于充血模型的-DDD-开发模式"><a href="#基于充血模型的-DDD-开发模式" class="headerlink" title="基于充血模型的 DDD 开发模式"></a>基于充血模型的 DDD 开发模式</h4><ol>
<li>也是重点说Service 层，把虚拟钱包 VirtualWallet 类设计成一个充血的Domain 领域模型，并且将原来在 Service 类中的中的部分业务逻辑移动到 VirtualWallet 类中，让Service 类的实现依赖 VirtualWallet 类。</li>
<li>此例子中，领域模型 VirtualWallet 类很单薄，包含的业务逻辑很简单。不过，如果虚拟钱包系统需要支持更复杂的业务逻辑，那充血模型的优势就显现出来了。比如，我们要支持透支一定额度和冻结部分余额的功能。</li>
</ol>
<ul>
<li><p>在基于充血模型的 DDD 开发模式中，哪些功能逻辑会放到 Service 类中？</p>
<ol>
<li>Service 类负责与 Repository 交流。将流程性的代码逻辑与领域模型的业务逻辑解耦，让领域模型更加可复用。</li>
<li>Service 类负责跨领域模型的业务聚合功能。</li>
<li>Service 类负责一些非功能性及与三方系统交互的工作。</li>
</ol>
</li>
<li><p>Repository层和Controller层继续沿用贫血模型<br>  基于充血模型的DDD开发模式跟基于贫血模型的传统开发模式相比，Controller层和Repository层的代码基本上相同。 这是因为REpository层的Entity生命周期有限，Controller层的VO只是单纯作为一种DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在Service层。所以，Repository层和Controller层继续沿用贫血模型的设计思路是没有问题</p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_38345081/article/details/103311449?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">相关的代码实现</a></p>
</li>
</ul>
<ol>
<li>基于贫血模型的传统开发模式<br>VirtualWaletController类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualWalletController</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过构造函数或者 IOC 框架注入</span></span><br><span class="line">  <span class="keyword">private</span> VirtualWalletService virtualWalletService;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getBalance</span><span class="params">(Long walletId)</span> </span>&#123; ... &#125; <span class="comment">// 查询余额</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debit</span><span class="params">(Long walletId, BigDecimal amount)</span> </span>&#123; ... &#125; <span class="comment">// 出账</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">credit</span><span class="params">(Long walletId, BigDecimal amount)</span> </span>&#123; ... &#125; <span class="comment">// 入账</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Long fromWalletId, Long toWalletId, BigDecimal amount)</span> </span>&#123; ...&#125; <span class="comment">// 转账</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
VirtualWalletBo<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualWalletBo</span> </span>&#123;<span class="comment">// 省略 getter/setter/constructor 方法</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> Long createTime;</span><br><span class="line">  <span class="keyword">private</span> BigDecimal balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
VirtualWalletService<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualWalletService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过构造函数或者 IOC 框架注入</span></span><br><span class="line">  <span class="keyword">private</span> VirtualWalletRepository walletRepo;</span><br><span class="line">  <span class="keyword">private</span> VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> VirtualWalletBo <span class="title">getVirtualWallet</span><span class="params">(Long walletId)</span> </span>&#123;</span><br><span class="line">    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWalletBo walletBo = convert(walletEntity);</span><br><span class="line">    <span class="keyword">return</span> walletBo;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getBalance</span><span class="params">(Long walletId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> virtualWalletRepo.getBalance(walletId);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debit</span><span class="params">(Long walletId, BigDecimal amount)</span> </span>&#123;</span><br><span class="line">    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);</span><br><span class="line">    BigDecimal balance = walletEntity.getBalance();</span><br><span class="line">    <span class="keyword">if</span> (balance.compareTo(amount) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSufficientBalanceException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    walletRepo.updateBalance(walletId, balance.subtract(amount));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">credit</span><span class="params">(Long walletId, BigDecimal amount)</span> </span>&#123;</span><br><span class="line">    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);</span><br><span class="line">    BigDecimal balance = walletEntity.getBalance();</span><br><span class="line">    walletRepo.updateBalance(walletId, balance.add(amount));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Long fromWalletId, Long toWalletId, BigDecimal amount)</span> </span>&#123;</span><br><span class="line">    VirtualWalletTransactionEntity transactionEntity = <span class="keyword">new</span> VirtualWalletTransactionEntity();</span><br><span class="line">    transactionEntity.setAmount(amount);</span><br><span class="line">    transactionEntity.setCreateTime(System.currentTimeMillis());</span><br><span class="line">    transactionEntity.setFromWalletId(fromWalletId);</span><br><span class="line">    transactionEntity.setToWalletId(toWalletId);</span><br><span class="line">    transactionEntity.setStatus(Status.TO_BE_EXECUTED);</span><br><span class="line">    Long transactionId = transactionRepo.saveTransaction(transactionEntity);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      debit(fromWalletId, amount);</span><br><span class="line">      credit(toWalletId, amount);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InsufficientBalanceException e) &#123;</span><br><span class="line">      transactionRepo.updateStatus(transactionId, Status.CLOSED);</span><br><span class="line">      ...rethrow exception e...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      transactionRepo.updateStatus(transactionId, Status.FAILED);</span><br><span class="line">      ...rethrow exception e...</span><br><span class="line">    &#125;</span><br><span class="line">    transactionRepo.updateStatus(transactionId, Status.EXECUTED);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>基于充血模型的DDD开发模式<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualWallet</span> </span>&#123; <span class="comment">// Domain 领域模型 (充血模型)</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> Long createTime = System.currentTimeMillis();;</span><br><span class="line">  <span class="keyword">private</span> BigDecimal balance = BigDecimal.ZERO;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">VirtualWallet</span><span class="params">(Long preAllocatedId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = preAllocatedId;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">balance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debit</span><span class="params">(BigDecimal amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.balance.compareTo(amount) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientBalanceException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.balance.subtract(amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">credit</span><span class="params">(BigDecimal amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidAmountException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.balance.add(amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualWalletService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过构造函数或者 IOC 框架注入</span></span><br><span class="line">  <span class="keyword">private</span> VirtualWalletRepository walletRepo;</span><br><span class="line">  <span class="keyword">private</span> VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> VirtualWallet <span class="title">getVirtualWallet</span><span class="params">(Long walletId)</span> </span>&#123;</span><br><span class="line">    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWallet wallet = convert(walletEntity);</span><br><span class="line">    <span class="keyword">return</span> wallet;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getBalance</span><span class="params">(Long walletId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> virtualWalletRepo.getBalance(walletId);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debit</span><span class="params">(Long walletId, BigDecimal amount)</span> </span>&#123;</span><br><span class="line">    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWallet wallet = convert(walletEntity);</span><br><span class="line">    wallet.debit(amount);</span><br><span class="line">    walletRepo.updateBalance(walletId, wallet.balance());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">credit</span><span class="params">(Long walletId, BigDecimal amount)</span> </span>&#123;</span><br><span class="line">    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWallet wallet = convert(walletEntity);</span><br><span class="line">    wallet.credit(amount);</span><br><span class="line">    walletRepo.updateBalance(walletId, wallet.balance());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Long fromWalletId, Long toWalletId, BigDecimal amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... 跟基于贫血模型的传统开发模式的代码一样...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这种充血模型的设计思路，看起来领域模型VitualWallet类很单薄，包含的业务逻辑很简单，这种思路貌似没太大优势。<br>这也是大部分业务系统都使用基于贫血模型开发的原因。<br>不过当虚拟钱包需要支持更复杂的业务的时候，它的优势就会显现出来。<br>比如要支持透支一定额度和冻结部分余额的功能，这是重新设计VirtualWallet类的实现代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualWallet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> Long createTime = System.currentTimeMillis();;</span><br><span class="line">  <span class="keyword">private</span> BigDecimal balance = BigDecimal.ZERO;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isAllowedOverdraft = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">private</span> BigDecimal overdraftAmount = BigDecimal.ZERO;</span><br><span class="line">  <span class="keyword">private</span> BigDecimal frozenAmount = BigDecimal.ZERO;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">VirtualWallet</span><span class="params">(Long preAllocatedId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = preAllocatedId;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freeze</span><span class="params">(BigDecimal amount)</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfreeze</span><span class="params">(BigDecimal amount)</span> </span>&#123; ...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseOverdraftAmount</span><span class="params">(BigDecimal amount)</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decreaseOverdraftAmount</span><span class="params">(BigDecimal amount)</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOverdraft</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openOverdraft</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">balance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getAvaliableBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigDecimal totalAvaliableBalance = <span class="keyword">this</span>.balance.subtract(<span class="keyword">this</span>.frozenAmount);</span><br><span class="line">    <span class="keyword">if</span> (isAllowedOverdraft) &#123;</span><br><span class="line">      totalAvaliableBalance += <span class="keyword">this</span>.overdraftAmount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalAvaliableBalance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debit</span><span class="params">(BigDecimal amount)</span> </span>&#123;</span><br><span class="line">    BigDecimal totalAvaliableBalance = getAvaliableBalance();</span><br><span class="line">    <span class="keyword">if</span> (totoalAvaliableBalance.compareTo(amount) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientBalanceException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.balance.subtract(amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">credit</span><span class="params">(BigDecimal amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidAmountException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.balance.add(amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a href="https://www.cnblogs.com/NewBigLiang/p/4971513.html" target="_blank" rel="noopener">贫血模型和充血模型</a><br>文章提到了一句化, 不要为了面向对象而面向对象.感觉很有道理,但又不是很理解.<br><a href="https://www.infoq.cn/article/ddd-in-practice/" target="_blank" rel="noopener">领域驱动设计和开发实战</a></li>
</ol>
<h3 id="7-Generic-泛型"><a href="#7-Generic-泛型" class="headerlink" title="7.Generic 泛型"></a>7.Generic 泛型</h3><ul>
<li><p><strong>加入泛型之前：如果我们有如下需求：一个StringArr，你只想放string，但你并不能阻止其他类型数据放入</strong>。为了通用性，这样的数组一般都是Object。当我们获取里面的值的时候，就得强制转换，这就是它的缺点。</p>
</li>
<li><p><strong>加入泛型之后：</strong> 例如：<code>ArrayList&lt;String&gt; stringValues=new ArrayList&lt;String&gt;();</code>这样，就指定了具体的类型，添加一些数据的时候，如果不符合初定的类型，就会报错，<strong>安全性提高！</strong> 再有就是指定了具体的类型，<strong>提高了代码的质量，可读性提高！</strong></p>
</li>
<li><p>实现原理:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayString = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayInteger = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        System.out.println(arrayString.getClass()==arrayInteger.getClass());#true</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，两者的类型分明不同，输出的结果却是true，这是因为，泛型它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的。 这就是为什么，Java的泛型被称为“伪泛型”的原因</p>
</li>
</ul>
<p><strong>注意:</strong></p>
<ul>
<li><p>泛型变量不允许是基本数据类型，只能是他们的包装类</p>
</li>
<li><p>静态方法和静态变量不可以使用泛型类所声明的泛型类型参数</p>
</li>
<li><p>java泛型中的标记符含义</p>
<ul>
<li>E - Element (在集合中使用，因为集合中存放的是元素)</li>
<li>T - Type（Java 类）</li>
<li>K - Key（键）</li>
<li>V - Value（值）</li>
<li>N - Number（数值类型）</li>
<li>？ - 表示不确定的java类型<ul>
<li>? extends</li>
<li>? super</li>
</ul>
</li>
<li>S、U、V - 2nd、3rd、4th types</li>
</ul>
</li>
<li><p>Object跟这些标记符代表的java类型有啥区别呢？</p>
<blockquote>
<p>Object是所有类的根类，任何类的对象都可以设置给该Object引用变量，使用的时候可能需要类型强制转换，但是用使用了泛型T、E等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。</p>
</blockquote>
</li>
</ul>
<h4 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h4><p>泛型有三种常用的使用方式：泛型类，泛型接口和泛型方法。</p>
<h5 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h5><p>一个泛型类（generic class）就是具有一个或多个类型变量的类。下面通过一个简单的<code>Pair</code>类作为例子。对于这个类来说，我们只关注泛型，而不会为数据存储的细节烦恼。下面是Pair类的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 泛型类</span></span><br><span class="line"><span class="comment"> * Java库中 E表示集合的元素类型，K 和 V分别表示表的关键字与值的类型</span></span><br><span class="line"><span class="comment"> * T（需要时还可以用临近的字母 U 和 S）表示“任意类型”</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> T name;</span><br><span class="line">    <span class="keyword">private</span> T price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T name, T price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(T name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(T price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pair</code>类引入了一个类型变量T，用尖括号（<code>&lt;&gt;</code>）括起来，并放在类名的后面。泛型类可以有多个类型变量。例如，可以定义Pair类，其中第一个域和第二个域使用不同的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt; </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>类方法中的类型变量指定方法的返回类型以及域和局部变量的类型。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T first; <span class="comment">//uses the type variable</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用具体的类型替换类型变量就可以实例化泛型类型，</span><br><span class="line">Pair&lt;String&gt;</span><br><span class="line">可以将结果想象成带有构造器的普通类：</span><br><span class="line">Pair&lt;String&gt;()</span><br><span class="line">Pair&lt;String&gt;(String,String)</span><br><span class="line">和方法：</span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">String <span class="title">getPrice</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(String)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Fruit"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FruitGenerator</span><span class="params">(T next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FruitGenerator&lt;String&gt; fruit = <span class="keyword">new</span> FruitGenerator&lt;&gt;(<span class="string">"Fruit"</span>);</span><br><span class="line">        System.out.println(fruit.next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(ArrayAlg.getMiddle(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是在普通类中定义的，而不是在泛型类中定义的。然而，这是一个泛型方法，可以从尖括号和类型变量看出这一点。注意，<strong>类型变量放在修饰符（这里是 public static）的后面，返回类型的前面</strong></p>
<p><a href="https://www.cnblogs.com/coprince/p/8603492.html" target="_blank" rel="noopener">这篇文章的泛型讲的很详细</a></p>
<h3 id="8-java编译"><a href="#8-java编译" class="headerlink" title="8.java编译"></a>8.java编译</h3><p>一直都在使用IDE来写java, 今天学习一下如何命令行来运行一个java项目<br>但是不只是运行一个HelloWorld.java文件,还要学习一下如果运行一个项目呢</p>
<ul>
<li>使用javac命令java<br>可以通过只敲击javac 看到各种命令参数。</li>
</ul>
<h4 id="不带包名的类如何编译"><a href="#不带包名的类如何编译" class="headerlink" title="不带包名的类如何编译"></a>不带包名的类如何编译</h4><p>新建一个HelloWorld.java文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命令行进入当前文件的位置<br>命令:java HelloWorld.java<br>    java HelloWorld<br>输出结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\&gt;javac HelloWorld.java</span><br><span class="line"></span><br><span class="line">D:\&gt;java HelloWorld</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<ul>
<li><p>那么如果输出是中文,会怎样?<br>我们输出一句”我来了”看一下结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\&gt;javac HelloWorld.java</span><br><span class="line">HelloWorld.java:<span class="number">5</span>: 错误: 编码 GBK 的不可映射字符 (<span class="number">0x86</span>)</span><br><span class="line">        System.out.println(<span class="string">"Hello World!,鎴戞潵浜?"</span>);</span><br><span class="line">                                             ^</span><br><span class="line"><span class="number">1</span> 个错误</span><br></pre></td></tr></table></figure>
<p>编译不通过<br>输出 :你好”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\&gt;javac HelloWorld.java</span><br><span class="line">D:\&gt;java HelloWorld</span><br><span class="line">Hello World!,浣犲ソ</span><br></pre></td></tr></table></figure>
<p>编译成功,输出乱码</p>
</li>
<li><p>原因分析<br>javac是java compiler的命令，是将.java文件编译成.class文件的过程。我们需要先将文件读入内存，才能进行编译。<br>读入内存需要知道文件的编码格式，才能正确的将文件读取。我们查看一下java源文件的编码，发现是UTF-8。而java编译器默认的字符集可以通过如下代码查看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Charset.defaultCharset());</span><br></pre></td></tr></table></figure>
<p>会发现输出GBK。</p>
</li>
</ul>
<p>也就是java编译器认为文件采用GBK编码，而实际上文件是采用UTF-8编码。然后“你好吗”三个字的UTF-8码值，转换成GBK就是”浣犲ソ鍚�”，这个问号“�”就是一个GBK不可映射的字符。可以用下面的代码试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"你好吗"</span>;</span><br><span class="line"> </span><br><span class="line">String s1 = <span class="keyword">new</span> String(s.getBytes(<span class="string">"utf-8"</span>), <span class="string">"gbk"</span>);</span><br><span class="line"> </span><br><span class="line">System.out.println(s1);</span><br></pre></td></tr></table></figure>
<p>而如果是”你好”两个字的UTF-8码值转换成GBK是这三个字符”浣犲ソ”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"你好"</span>;</span><br><span class="line"> </span><br><span class="line">String s1 = <span class="keyword">new</span> String(s.getBytes(<span class="string">"utf-8"</span>), <span class="string">"gbk"</span>);</span><br><span class="line"> </span><br><span class="line">System.out.println(s1);</span><br></pre></td></tr></table></figure>
<p>编译器使用了UTF-8的二进制值来尝试转换成GBK，第一次认识到了一个不认识的字符，因为UTF-8的范围很大，这个码值在GBK中没有，就报了这个错。</p>
<p>而第二次编译通过，是因为“你好”这两个字的UTF-8编码，恰好能转换成GBK编码，所以能编译通过。但是编译通过并不保证内容就是正确的，输出的时候仍然是乱码。</p>
<ul>
<li>那么问题又来了<br>为什么我们通过IDE就能编译通过呢</li>
</ul>
<p>通过IDE，不可能分开java文件编码和java compiler的编码格式的，文件设置成什么编码，编译器都会知道，就会用什么编码来解析。原生的javac不会这样，它只会按照默认的系统编码来编，这个时候如果文件编码不同，就出现这个问题了。<br>知道了原因，怎么解决，两种解决方案，最终目的是为了文件编码和解码字符集相同<br>1）如果文件是UTF-8编码的，我们使用-encoding UTF-8 来显式指定为UTF-8的编码格式<br>2）将文件改为GBK编码，如果使用windows自带的记事本，保存为ANSI，中国区域会使用GBK编码。如果使用其它高级文本编辑工具，如：notepad++、Emeditor、UE这样的，另存为指定格式。</p>
<h4 id="带包名的类如何编译"><a href="#带包名的类如何编译" class="headerlink" title="带包名的类如何编译"></a>带包名的类如何编译</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo2020;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行：<br>我们会发现编译成功，A.class被编译到了D盘根目录下。运行报错“错误：找不到或无法加载主类A”</p>
<p><img src="/2020/03/18/Java%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9/by.png" alt></p>
<ul>
<li>原因分析:<ul>
<li>有包的java程序，需要用完整包名来执行<br>由于我们没有指定classpath，jvm准备在当前路径下查找HelloWorld.class来装载，找了一圈没找到（确实有个HelloWorld类，但是HelloWorld类的完整路径是mypack.HelloWorld，所以不是这个），报错找不到或无法加载主类。</li>
<li>有包的java程序，文件路径中必须包含包名，并以包名结尾<br>jvm看了一下有包，于是将包转换为路径，也就是期望在D:/mypack文件夹下，找到HelloWorld.class文件进行装载。也没找到。</li>
</ul>
</li>
</ul>
<p>如果有包，java命令必须在包的上层目录执行完整路径名（完全限定名），上例中HelloWorld.class的完全限定名是mypack.HelloWorld。如果在D盘下，有一个HelloWorld.java，包路径为aaa.bbb.ccc，必须在D盘下，执行java aaa.bbb.ccc.A才行，此处的“在D盘下”，暂时可以看做直接在D盘下，也可以通过-cp指定到D盘下，这个后面还会说。</p>
<ul>
<li>解决方法<br>我们可以使用-d . 来让编译器以当前路径为基准，自动创建包路径，这个-d .放在前面，放在后面都可以<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">D:\&gt;javac HelloWorld<span class="selector-class">.java</span> -d .</span><br><span class="line"></span><br><span class="line">D:\&gt;java mypack.HelloWorld</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
这个-d 可以将文件编译到指定目录下。</li>
</ul>
<p>假设我们在D盘下创建一个aa的目录，然后执行javac -d aa A.java，效果不贴了.<br>使用-classpath指定包的上级目录<br>使用-classpath（或者 -cp，简写，意思相同）指定.class的目录，使用相对路径，绝对路径都可以，这个目录直接通到mypack的上级即可<br>我们可以通过-classpath指定.class在哪个根目录下，然后从这个目录拼接上包路径来构成完整路径。</p>
<p><a href="https://blog.csdn.net/u011531425/article/details/80961628" target="_blank" rel="noopener">点击此处,查看更多</a></p>
<h4 id="java命令行运行java项目"><a href="#java命令行运行java项目" class="headerlink" title="java命令行运行java项目"></a>java命令行运行java项目</h4><p><a href="https://blog.csdn.net/huagong_adu/article/details/6929817" target="_blank" rel="noopener">点击查看</a></p>
<blockquote>
<p>有点烦躁了.去峡谷转一转,<br>Only action can relieve the uneasiness.            —2020/03/21</p>
</blockquote>
<h3 id="9-异常处理"><a href="#9-异常处理" class="headerlink" title="9.异常处理"></a>9.异常处理</h3><p><img src="/2020/03/18/Java%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9/j7.png" alt></p>
<h4 id="异常处理5个关键字"><a href="#异常处理5个关键字" class="headerlink" title="异常处理5个关键字"></a>异常处理5个关键字</h4><pre><code>![](Java每天学一点/j8.png)</code></pre><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><h4 id="throwable类-异常方法"><a href="#throwable类-异常方法" class="headerlink" title="throwable类 异常方法"></a>throwable类 异常方法</h4><h4 id="throws-和-throw-区别"><a href="#throws-和-throw-区别" class="headerlink" title="throws 和 throw 区别"></a>throws 和 throw 区别</h4><ul>
<li>throw：指的是在方法中人为抛出一个异常对象（这个异常对象可能是自己实例化或者抛出已存在的）；</li>
<li>throws：在方法的声明上使用，表示此方法在调用时必须处理异常。<h4 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h4></li>
</ul>
<h4 id="Error与Exception的区别"><a href="#Error与Exception的区别" class="headerlink" title="Error与Exception的区别"></a>Error与Exception的区别</h4><ul>
<li><p>Error（错误）是系统中的错误，程序员是不能改变的和处理的，是在程序编译时出现的错误，只能通过修改程序才能修正。一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。</p>
</li>
<li><p>Exception（异常）表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。</p>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>如果要自定义异常类，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）。如果要自定义非检查异常，则扩展自RuntimeException。</p>
</li>
</ul>
<ul>
<li>处理多个异常时,捕获范围小的异常要放在捕获范围大的异常之前处理</li>
</ul>
<p><a href="https://www.cnblogs.com/zhangchao0515/p/9613701.html" target="_blank" rel="noopener">java异常的详解</a></p>
<h3 id="10-java反射"><a href="#10-java反射" class="headerlink" title="10. java反射"></a>10. java反射</h3><ul>
<li><p>概念:Java反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。</p>
</li>
<li><p>反射的应用场合：在编译时根本无法知道该对象或类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息.</p>
</li>
<li><p>反射的作用：通过反射可以使程序代码访问装载到JVM 中的类的内部信息</p>
<ul>
<li><p>获取已装载类的成员变量信息</p>
</li>
<li><p>获取已装载类的方法</p>
</li>
<li><p>获取已装载类的构造方法信息</p>
</li>
</ul>
</li>
<li><p>常用方法:</p>
<ul>
<li>getName()获得类的完整名字</li>
<li>getPackage()获取此类所属的包</li>
<li>getSuperclass()获得此类的父类对应的Class对象</li>
<li>getField(String name)获得类的指定属性 </li>
<li>getMethods()获得类的public类型的方法</li>
<li>getMethod (String name,Class [] args)获得类的指定方法<blockquote>
<p>每个Method对象对应一个方法，获得Method对象后，可以调用其invoke() 来调用对应方法    Object invoke(Object obj,Object [] args):obj代表当前方法所属的对象的名字，args代表当前方法的参数列表，返回值Object是当前方法的返回值，即执行当前方法的结果。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>反射的缺点:</p>
<ul>
<li>性能问题<br>  1.使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此Java反射机制主要应用在对灵活性和扩展性要求很高的系统框架上,普通程序不建议使用。<br>  2.反射包括了一些动态类型，所以JVM无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被 执行的代码或对性能要求很高的程序中使用反射。</li>
<li>使用反射会模糊程序内部逻辑<br>  程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂。</li>
<li>安全限制<br>  使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如Applet，那么这就是个问题了</li>
<li>内部暴露<br>  由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用－－代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</li>
</ul>
</li>
</ul>
<p>如果只是用一两次,可以忽略反射对性能的影响,只有运行上百万千万次才会感觉到对性能明显的影响.</p>
<ul>
<li>代码简介,提高代码的复用率,外部调用方便<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123; <span class="comment">//水果接口</span></span><br><span class="line">　 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>; <span class="comment">//吃水果</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123; <span class="comment">//定义苹果</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">"**吃苹果。"</span>); </span><br><span class="line">　　&#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">"**吃橘子。"</span>); </span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">　　　　Fruit fruit = <span class="keyword">null</span> ;</span><br><span class="line">　　　　<span class="keyword">try</span>&#123;</span><br><span class="line">　　　　　　fruit = (Fruit) Class.forName(className).newInstance() ;</span><br><span class="line">　　　　&#125;<span class="keyword">catch</span>(Exception e )&#123;</span><br><span class="line">　　　　　　e.printStackTrace() ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> fruit ;</span><br><span class="line">　 &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryDemo</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">　　<span class="comment">//通过工厂类取得接口实例，传入完整的包.类名称</span></span><br><span class="line">　　　　Fruit f = Factory.getInstance(<span class="string">"cn.yonyong.reflection.testdemo.Apple"</span>) ;</span><br><span class="line">　　　　<span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123; <span class="comment">//判断是否取得接口实例</span></span><br><span class="line">　　　　　　f.eat() ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果部用反射,，那么我们如果再加一个西瓜类，就得在Factory里判断，每添加一个类都要修改一次Factory，但用了反射只用在调用的时候传入完整的类名就可完成。结果：用反射，修改一处代码；不用反射，修改两处代码。</li>
</ul>
<p>[反<strong>_____</strong>射]<a href="https://blog.csdn.net/huangliniqng/article/details/88554510" target="_blank" rel="noopener">https://blog.csdn.net/huangliniqng/article/details/88554510</a></p>
<ul>
<li><a href="https://blog.csdn.net/vikeyyyy/article/details/79083097" target="_blank" rel="noopener">invoke</a> 干啥的?<br><a href="https://blog.csdn.net/qq_36470686/article/details/85015753?utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">8错</a><br><a href="https://blog.csdn.net/lililuni/article/details/83449088?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">福利</a></li>
</ul>
<p>java.lang<br>java.Class</p>
<h3 id="11-杂文篇"><a href="#11-杂文篇" class="headerlink" title="11.杂文篇"></a>11.杂文篇</h3><h4 id="11-1-StringUtils"><a href="#11-1-StringUtils" class="headerlink" title="11.1 StringUtils"></a>11.1 StringUtils</h4><ul>
<li>public static boolean isEmpty(String str)<br>判断某字符串是否为空，为空的标准是str == null 或 str.length() == 0</li>
<li>public static boolean isNotEmpty(String str)</li>
<li>public static boolean isBlank(String str)<br>判断某字符串是否为空或长度为0或由空白符(whitespace)构成</li>
<li>public static String trim(String str)<br>去掉字符串两端的控制符(control characters, char &lt;= 32)<br>如果输入为null则返回null</li>
<li>public static String trimToNull(String str)<br>去掉字符串两端的控制符(control characters, char &lt;= 32)<br>如果变为null或”“，则返回null</li>
<li>public static String strip(String str)<br>去掉字符串两端的空白符(whitespace)，</li>
<li>public static String stripToNull(String str)</li>
<li>public static String[] split(String str)</li>
<li>53.public static String[] split(String str, char separatorChar)</li>
</ul>
<p>…不一一列举了.不需要背下来,大家看一遍 知道都能做什么就好了</p>
<p><a href="https://www.cnblogs.com/liangjiejava/p/9850067.html" target="_blank" rel="noopener">https://www.cnblogs.com/liangjiejava/p/9850067.html</a></p>
<h4 id="11-2-int和Integer的区别"><a href="#11-2-int和Integer的区别" class="headerlink" title="11.2 int和Integer的区别"></a>11.2 int和Integer的区别</h4><p>基本区别:</p>
<ul>
<li>（1）Integer是int的包装类；int是基本数据类型；</li>
<li>（2）Integer变量必须实例化后才能使用；int变量不需要；</li>
<li>（3）Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；</li>
<li>（4）Integer的默认值是null；int的默认值是0。</li>
</ul>
<p>深入比较:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        Integer i2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        Integer i3 = <span class="number">1</span>;</span><br><span class="line">        Integer i4 = <span class="number">127</span>;</span><br><span class="line">        Integer i5 = <span class="number">127</span>;</span><br><span class="line">        Integer i6 = <span class="number">128</span>;</span><br><span class="line">        Integer i7 = <span class="number">128</span>;</span><br><span class="line">        <span class="keyword">int</span> i8 = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//1、直接比较时，比较两者的地址，每次new生成的都是新的对象</span></span><br><span class="line">        System.out.println(i1==i2);<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//2、integer和int比较时会自动拆箱转换为int类型，然后比较两者的值</span></span><br><span class="line">        System.out.println(i1==i8);<span class="comment">//ture</span></span><br><span class="line">        <span class="comment">//3、非new生成i3指向的是java常量池的对象，new是新生成的</span></span><br><span class="line">        System.out.println(i1==i3);<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//4、127和128问题，JavaAPI中对Integer定义：在-128到127(含)之间的数会缓存，只存在一个对象中，即在此创建只是从缓存中取</span></span><br><span class="line">            <span class="comment">//超过这个每次创建就会new，即产生新的对象</span></span><br><span class="line">        System.out.println(i4==i5);<span class="comment">//true</span></span><br><span class="line">        System.out.println(i6==i7);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-3-null和“”的区别"><a href="#11-3-null和“”的区别" class="headerlink" title="11.3  null和“”的区别"></a>11.3  null和“”的区别</h4><p>本质的区别:</p>
<ul>
<li>null是没有地址的</li>
<li>“”是有地址的,里面的内容为空</li>
</ul>
<p>具体区别:</p>
<ol>
<li>做成员变量（字段/属性/类变量）时，如果只写String str；那么是默认赋值为null的。null的话，你屏幕输出（toString方法）的结果为字符串null，而且其它调用str的操作，编译可通过，运行时会空指针异常，此时是异常。</li>
<li>做局部变量（方法里的变量）时，如果只写String str；是不会默认赋值null的，这里仅声明了一个str变量，在栈内存中有定义，但没有任何值，null其实也是一种值。此时任何调用str的操作，编译时就均会报错，是error，不是异常。</li>
<li>“”是空字符串，但也是字符串，没有什么东西。 而null是空的意思，什么都没有，没有地址</li>
</ol>
<p><code>String str = null</code>;和<code>String str1</code>; 这两者也是不同的，前者是分配了内存，也就是说，你对他可以进行相关操作，而不会报错，后者是不可以的。</p>
<h4 id="11-4-Java-StringTokenizer"><a href="#11-4-Java-StringTokenizer" class="headerlink" title="11.4 Java StringTokenizer"></a>11.4 Java StringTokenizer</h4><p>Java StringTokenizer 属于 java.util 包，用于分隔字符串。</p>
<ul>
<li>StringTokenizer 构造方法：<ol>
<li>StringTokenizer(String str) ：构造一个用来解析 str 的StringTokenizer 对象。java 默认的分隔符是空格(“”)、制表符(\t)、换行符(\n)、回车符(\r)。</li>
<li>StringTokenizer(String str, String delim) ：构造一个用来解析 str 的 StringTokenizer 对象，并提供一个指定的分隔符。</li>
<li>StringTokenizer(String str, String delim, boolean returnDelims) ：构造一个用来解析 str 的 StringTokenizer 对象，并提供一个指定的分隔符，同时，指定是否返回分隔符。</li>
</ol>
</li>
<li>String Tokenizer常用方法<ol>
<li>int countTokens()：返回nextToken方法被调用的次数。</li>
<li>boolean hasMoreTokens()：返回是否还有分隔符。</li>
<li>boolean hasMoreElements()：判断枚举 （Enumeration） 对象中是否还有数据。</li>
<li>String nextToken()：返回从当前位置到下一个分隔符的字符串。</li>
<li>Object nextElement()：返回枚举 （Enumeration） 对象的下一个元素。</li>
<li>String nextToken(String delim)：与 4 类似，以指定的分隔符返回结果。</li>
</ol>
</li>
<li>实例<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        String str = <span class="string">"runoob,google,taobao,facebook,zhihu"</span>;</span><br><span class="line">        <span class="comment">// 以 , 号为分隔符来分隔字符串</span></span><br><span class="line">        StringTokenizer st=<span class="keyword">new</span> StringTokenizer(str,<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">while</span>(st.hasMoreTokens()) &#123; </span><br><span class="line">            System.out.println(st.nextToken());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果为：</span></span><br><span class="line">runoob</span><br><span class="line">google</span><br><span class="line">taobao</span><br><span class="line">facebook</span><br><span class="line">zhihu</span><br></pre></td></tr></table></figure>
实例2<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用第一种构造函数："</span>);</span><br><span class="line">        StringTokenizer st1 = <span class="keyword">new</span> StringTokenizer(<span class="string">"Only action can relieve the uneasiness"</span>, <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">while</span> (st1.hasMoreTokens())</span><br><span class="line">            System.out.println(st1.nextToken());</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"使用第二种构造函数："</span>);</span><br><span class="line">        StringTokenizer st2 = <span class="keyword">new</span> StringTokenizer(<span class="string">"Jason says : Only action can relieve the uneasiness"</span>, <span class="string">" :"</span>);</span><br><span class="line">        <span class="keyword">while</span> (st2.hasMoreTokens())</span><br><span class="line">            System.out.println(st2.nextToken());</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"使用第三种构造函数："</span>);</span><br><span class="line">        StringTokenizer st3 = <span class="keyword">new</span> StringTokenizer(<span class="string">"Jason says : Only action can relieve the uneasiness"</span>, <span class="string">" :"</span>,  <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">while</span> (st3.hasMoreTokens())</span><br><span class="line">            System.out.println(st3.nextToken());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意,第二个参数是String类型,String类型中的每个字符都是分隔符,根据第三个构造函数的输出可以看出</strong><br>如果我们想要分割一篇文章的词汇,统计所出现的次数,就可以将第二个参数设置为”,.?! ;:/“‘“ 双引号需要转义</p>
<h4 id="11-5-equals和-的区别"><a href="#11-5-equals和-的区别" class="headerlink" title="11.5  equals和==的区别"></a>11.5  equals和==的区别</h4><p>他们最大的区别就是一个是方法，一个是关系操作符。<br>Object类中的equals方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span> == obj;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可见它直接比较的对象本身.<br>String类中的equals方法源码（重写Object中的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String) anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的equals比较当中，都运用到了<code>==</code>，这就说明，equals（不管哪个类中的）是<code>==</code>的扩展。</p>
<p>引用《java编程思想》中的原话：</p>
<blockquote>
<p>关系操作符生成的是一个boolean结果，它们计算的是操作数的值之间的关系</p>
</blockquote>
<p><strong>总结:</strong></p>
<ul>
<li>当<code>==</code>比较基本数据类型的时候，就是比较他们本身的值。</li>
<li>而<code>==</code>比较引用数据类型的时候， 就是比较他们在内存的地址</li>
<li>equals用来比较引用数据类型一般都要重写该方法。例如String类就重写了这个方法，</li>
<li>如果没有重写equals就直接比较，就是比较他们的内存地址</li>
<li>equals不能用于基本数据类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str;</span><br><span class="line">        str = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">        String str2 = str;</span><br><span class="line">        System.out.println(str==str2); # true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的str中存储的并不是“a”，而是它所指向的对象的地址。所以将他赋值给str2，比较他俩时返回的就是true</p>
<p><strong>hashCode()方法</strong>也类似</p>
<h4 id="11-6-string和各种格式互转-string转int-int转string-其他类型转String"><a href="#11-6-string和各种格式互转-string转int-int转string-其他类型转String" class="headerlink" title="11.6 string和各种格式互转 string转int int转string,其他类型转String"></a>11.6 string和各种格式互转 string转int int转string,其他类型转String</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = String.valueOf(value); <span class="comment">// 其中 value 为任意一种数字类型。 </span></span><br><span class="line"><span class="comment">//字符串型转换成各种数字类型：</span></span><br><span class="line">String s = <span class="string">"169"</span>; </span><br><span class="line"><span class="keyword">byte</span> b = Byte.parseByte( s ); </span><br><span class="line"><span class="keyword">short</span> t = Short.parseShort( s ); </span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt( s ); </span><br><span class="line"><span class="keyword">long</span> l = Long.parseLong( s ); </span><br><span class="line">Float f = Float.parseFloat( s ); </span><br><span class="line">Double d = Double.parseDouble( s );</span><br><span class="line">判断字符时候大小写及其转换</span><br><span class="line">Character.isUpperCase(c); <span class="comment">// 是否是大写</span></span><br><span class="line">Character.isLowerCase(c); <span class="comment">// 是否是小写</span></span><br><span class="line">Character.toUpperCase(c); <span class="comment">// 转换大写</span></span><br><span class="line">Character.toLowerCase(c); <span class="comment">// 转化小写</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ASCII码<ul>
<li>48-57  : 0-9</li>
<li>65-90: A-Z</li>
<li>97-122: a-z</li>
</ul>
</li>
</ul>
<h4 id="11-7-java计算程序运行时间"><a href="#11-7-java计算程序运行时间" class="headerlink" title="11.7 java计算程序运行时间"></a>11.7 java计算程序运行时间</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();    <span class="comment">//获取开始时间</span></span><br><span class="line">doSomething();    <span class="comment">//测试的代码段</span></span><br><span class="line"><span class="keyword">long</span> endTime = System.currentTimeMillis();    <span class="comment">//获取结束时间</span></span><br><span class="line">System.out.println(<span class="string">"程序运行时间："</span> + (endTime - startTime) + <span class="string">"ms"</span>);    <span class="comment">//输出程序运行时间</span></span><br></pre></td></tr></table></figure>
<p>以纳秒为单位:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> startTime=System.nanoTime();   <span class="comment">//获取开始时间  </span></span><br><span class="line">doSomeThing(); <span class="comment">//测试的代码段  </span></span><br><span class="line"><span class="keyword">long</span> endTime=System.nanoTime(); <span class="comment">//获取结束时间  </span></span><br><span class="line">System.out.println(<span class="string">"程序运行时间： "</span>+(endTime-startTime)+<span class="string">"ns"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="11-8-关于Set中toArray"><a href="#11-8-关于Set中toArray" class="headerlink" title="11.8 关于Set中toArray()"></a>11.8 关于Set中toArray()</h4><p>Set的toArray方法<br>下面是想把Set转换为String数组,于是就用到了Set的toArray()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();  </span><br><span class="line">........          </span><br><span class="line">String[] strs = (String[]) set.toArray();</span><br></pre></td></tr></table></figure>
<p>程序编译的时候很正常，当运行的时候却报了 ClassCastException.</p>
<blockquote>
<p>那么,String是Object的子类,而set.toArray()返回的就是一个Object数组,为什么就不能转换呢?</p>
</blockquote>
<p>其实,String是一种类型， String[]是另一种类型，这是不同的概念。<br>Object可以强转为String（只要可以）不代表<code>Object[]</code>类型可以强转为<code>String[]</code>类型。<br>再者,对于Set而言，它只知道它内部保存的是Object，所以默认情况下，toArray只能是返回一个由这些Object构成的Object数组出来。但程序的作者或许更清楚其内部元素的更具体的类型，因此，HashSet类提供了toArray的另一个重载版本，允许用户指定一种比Object[]更具体的数组类型，方法是传递一个用户想要的数组类型的一个数组实例进去，多长都无所谓（因此我们常常使用一个0长度的，毕竟把类型带进去就OK了），于是，toArray内部就会按照你想要的这种类型，给构造一个数组出来。这样构造出来的数组，当然是很安全地被调用者转换回那个实际的类型。</p>
<p><strong>划重点</strong>:<br><font color="red">String 和String[]不是一种类型 ，不要犯想当然的错误。</font></p>
<h4 id="11-9-String类的深入理解"><a href="#11-9-String类的深入理解" class="headerlink" title="11.9#### String类的深入理解"></a>11.9#### String类的深入理解</h4><p>了解一个类的最好的方式就是看源码</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">public final <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence</span><br><span class="line">&#123;</span><br><span class="line">    /** The value <span class="keyword">is</span> used <span class="keyword">for</span> character storage. */</span><br><span class="line">    private final char value[];</span><br><span class="line"></span><br><span class="line">    /** The offset <span class="keyword">is</span> the first index of the storage that <span class="keyword">is</span> used. */</span><br><span class="line">    private final int offset;</span><br><span class="line"></span><br><span class="line">    /** The count <span class="keyword">is</span> the number of characters <span class="keyword">in</span> the String. */</span><br><span class="line">    private final int count;</span><br><span class="line"></span><br><span class="line">    /** Cache the hash code <span class="keyword">for</span> the string */</span><br><span class="line">    private int hash; // Default to <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    /** use serialVersionUID <span class="keyword">from</span> JDK <span class="number">1.0</span><span class="number">.2</span> <span class="keyword">for</span> interoperability */</span><br><span class="line">    private static final long serialVersionUID = <span class="number">-6849794470754667710L</span>;</span><br><span class="line">	</span><br><span class="line">	public String substring(int beginIndex, int endIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endIndex &gt; count) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &gt; endIndex) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(endIndex - beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this :</span><br><span class="line">        new String(offset + beginIndex, endIndex - beginIndex, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">    int otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> this;</span><br><span class="line">    &#125;</span><br><span class="line">    char buf[] = new char[count + otherLen];</span><br><span class="line">    getChars(<span class="number">0</span>, count, buf, <span class="number">0</span>);</span><br><span class="line">    str.getChars(<span class="number">0</span>, otherLen, buf, count);</span><br><span class="line">    <span class="keyword">return</span> new String(<span class="number">0</span>, count + otherLen, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String replace(char oldChar, char newChar) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">        int len = count;</span><br><span class="line">        int i = <span class="number">-1</span>;</span><br><span class="line">        char[] val = value; /* avoid getfield opcode */</span><br><span class="line">        int off = offset;   /* avoid getfield opcode */</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val[off + i] == oldChar) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">        char buf[] = new char[len];</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">0</span> ; j &lt; i ; j++) &#123;</span><br><span class="line">            buf[j] = val[off+j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            char c = val[off + i];</span><br><span class="line">            buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new String(<span class="number">0</span>, len, buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...更多的不再展示</span><br></pre></td></tr></table></figure>
<p>从以上的源码中可以获得信息</p>
<ul>
<li><p>String是final类，这意味着，这个类不能被继承，也不可有子类，其中的方法默认都是final方法</p>
</li>
<li><p>String类是通过char数组来保存字符串的</p>
</li>
<li><p>String类对字符串的操作都是对新字符串操作。</p>
<blockquote>
<p>也就是说,String对象一旦被创建就不会改变,任何改变操作都不会改变原字符串,而生成新的对象</p>
</blockquote>
</li>
<li><p>字符串常量池</p>
<blockquote>
<p>每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串不可变，所以常量池中一定不存在两个相同的字符串</p>
</blockquote>
</li>
<li><p>静态常量池和运行时常量池</p>
<ul>
<li>静态常量池，即.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。</li>
<li>运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。<br>想了解更多,文末给出原文链接</li>
</ul>
</li>
</ul>
<h4 id="11-10-static深入分析"><a href="#11-10-static深入分析" class="headerlink" title="11.10 static深入分析"></a>11.10 static深入分析</h4><p>基本介绍：static的存在就是为了，不创建对象来调用这些属性或者方法，也是核心思想。<br>几种使用场景:</p>
<ol>
<li>修饰“内部类”</li>
<li>修饰变量</li>
<li>修饰方法</li>
<li>修饰代码块</li>
</ol>
<p>首先：修饰“内部类”，要注意普通类是不允许声明为静态的，只有内部类才可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        InnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"static innerClass"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"static innerMethod"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InnerClass innerClass = <span class="keyword">new</span> Test.InnerClass();</span><br><span class="line">        innerClass.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修饰代码块时，执行的顺序（加载的顺序）如下：</p>
<blockquote>
<p>父类静态变量<br>父类静态代码块<br>子类静态变量<br>子类静态代码块<br>父类普通变量<br>父类普通代码块<br>父类构造函数<br>子类普通变量<br>子类普通代码块<br>子类构造函数</p>
</blockquote>
<p>总结一下就是，静态的先被加载（在这个基础上，父类优先于子类，在父类优先于子类的基础上，变量优先于代码块优先于构造函数（有的话））</p>
<p>方法区:</p>
<ol>
<li>又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。</li>
<li>方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</li>
</ol>
<p>静态变量是所有线程共享的，所以不会消失。所以它具有那些特性。</p>
<p>一个小结：</p>
<ol>
<li>static是一个修饰符，用于修饰成员。（成员变量，成员函数）static修饰的成员变量 称之为静态变量或类变量。</li>
<li>static修饰的成员被所有的对象共享。</li>
<li>static优先于对象存在，因为static的成员随着类的加载就已经存在。</li>
<li>static修饰的成员多了一种调用方式，可以直接被类名所调用，（类名.静态成员）。</li>
<li>static修饰的数据是共享数据，对象中的存储的是特有的数据。</li>
</ol>
<p><a href="https://blog.csdn.net/Song_JiangTao/article/details/82023526?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">摘自</a></p>
<p><a href="https://baijiahao.baidu.com/s?id=1636927461989417537&wfr=spider&for=pc" target="_blank" rel="noopener">static</a></p>
<blockquote>
<p>Only action can relieve the uneasiness.            —2020/03/22</p>
</blockquote>
<h3 id="13-文件IO"><a href="#13-文件IO" class="headerlink" title="13 文件IO"></a>13 文件IO</h3><h4 id="File类的基本概念"><a href="#File类的基本概念" class="headerlink" title="File类的基本概念"></a>File类的基本概念</h4><ul>
<li>File是进行文件自身(目录)操作主要二点类</li>
<li>目录分隔符<br>  分隔符有三种形式,<code>//</code>,<code>\</code>,或者Separator</li>
<li>常用的方法<br><img src="/2020/03/18/Java%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9/j1.png" alt></li>
<li>补充:<ul>
<li>lastModified()</li>
<li>查看文件大小<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"文件大小："</span> + <span class="keyword">new</span> BigDecimal((<span class="keyword">double</span>)file.length()/<span class="number">1024</span>/<span class="number">1024</span>).divide(<span class="keyword">new</span> BigDecimal(<span class="number">1</span>),<span class="number">2</span>,BigDecimal.ROUND_HALF_UP) +<span class="string">"M"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4></li>
</ul>
</li>
<li>I/O流表示输入源或输出目的地。 流可以表示许多不同的来源和目的地，包括磁盘文件、设备、其他程序和内存数组.</li>
<li>流支持许多不同类型的数据，包括简单字节、原始数据类型、本地化字符和对象。 有些流只是传递数据；另一些流操纵和转换数据 以有用的方式提供数据。</li>
</ul>
<p>流的分类</p>
<ul>
<li><p>不同的方式</p>
<ul>
<li>InputStream/OutputStream</li>
<li>Byte Stream/Character Stream</li>
<li>节点流/处理流</li>
</ul>
</li>
<li><p>四种不同的流</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Byte Stream</th>
<th align="left">Character Stream</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Input</td>
<td align="left">InputStream</td>
<td align="left">Reader</td>
</tr>
<tr>
<td align="left">Output</td>
<td align="left">OutputStream</td>
<td align="left">Writer</td>
</tr>
<tr>
<td align="left">##### 字节流</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- Java字节流结构</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="/2020/03/18/Java%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9/j2.png" alt></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<pre><code>- OutputStream
    - close()
    - flush()
    - write(int b):输出单个字节
    - write(byte[] b): 输出全部字节数组
    - write(byte[] b, int off, int len): 输出部分字节数组
- FileOutputStream
- InputStream
    - read()
    - read(byte[] b)
    - read(byte[] b, int off, int len)</code></pre><ul>
<li>How to read date?<ol>
<li>Open a stream</li>
<li>While more information</li>
<li>Read information</li>
<li>Close the stream</li>
</ol>
</li>
<li>How to write data?<ol>
<li>Open a stream</li>
<li>While more information</li>
<li>Write information</li>
<li>Close the stream</li>
</ol>
</li>
</ul>
<h5 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h5><p><img src="/2020/03/18/Java%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9/j3.png" alt></p>
<ul>
<li><p>Write</p>
<pre><code>- write(char[] cbuf)
-  write(char[] cbuf, int off, int len)
- write(int c)
- write(String str)
-  write(String str, int off, int len)</code></pre></li>
<li><p>Reader</p>
<pre><code>- read()
- read(char[], cbuf)
- read(char[] cbuf,int off, int len)
- read(CharBuffer target)</code></pre></li>
<li><p>字节流和字符流的区别</p>
<ul>
<li>buffer</li>
<li>close()<ul>
<li>OutputStream,yes</li>
<li>writer, no<ul>
<li>flush</li>
</ul>
</li>
</ul>
</li>
<li>使用场景<ul>
<li>开发中字节数据比较多，图片、音乐、电影</li>
<li>字符最大的好处，中文的有效处理，如果处理中文，优先使用字符流，除此之外，以字节流为主。<h5 id="传输流"><a href="#传输流" class="headerlink" title="传输流"></a>传输流</h5></li>
</ul>
</li>
</ul>
</li>
<li><p>InputStreamReader</p>
<pre><code>An InputStreamReader is a bridge from byte streams to character streams: It
reads bytes and decodes them into characters using a specified charset.</code></pre></li>
<li><p>OutputStreamWriter</p>
<pre><code>An OutputStreamWriter is a bridge from character streams to byte streams:Characters written to it are encoded into bytes using a specified charset. Thecharset that it uses may be specified by name or may be given explicitly, or theplatform&apos;s default charset may be accepted.</code></pre><h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5></li>
<li><p>Encoding<br>  计算机中所有的信息组成都是二进制数据，那么所有能够描述出的中文文字都是经过处理后的结果。在计算机的世界里，所有的语言文字都会使用编码来进行描述，最常见的编码是ASCII码</p>
<ul>
<li>GDK:中文的国标编码，GBK包含有简体中文和繁体中文</li>
<li>GB2312: 常用的简体</li>
<li>iso8859-1</li>
<li>unicode:</li>
<li>utf编码(utf-8):融合了ISO8859-1和UNICODE编码的特点，在以后的所有开发里，使用的都是UTF-8编码</li>
</ul>
</li>
<li><p>乱码:编码与解码的字符集不统一.</p>
</li>
<li><p>utf8中 中文占多少字节<br>一般是3个字节，最常见的编码方式是1110xxxx 10xxxxxx 10xxxxxx。<br>但再超大字符集中的更多数汉字要占4个字节.<br><a href="https://www.cnblogs.com/web21/p/6090104.html" target="_blank" rel="noopener">click</a></p>
</li>
</ul>
<h5 id="Memory-Stream"><a href="#Memory-Stream" class="headerlink" title="Memory Stream"></a>Memory Stream</h5><ul>
<li>Byte Memory Stream： <ul>
<li>ByteArrayInputStream</li>
<li>ByteArrayOutputStream: toByteArray()</li>
</ul>
</li>
<li>Character Memory Stream:<ul>
<li>CharArrayReader</li>
<li>CharArrayWriter<h5 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h5></li>
</ul>
</li>
<li>输出流的问题<ul>
<li>所有的输出数据必须以字节类型的数据为主。</li>
<li>如果输出的数据是int(Integer)、double(Double)、java.util.Date等常用类型怎么办？都需要将其转换为字节后才能输出。</li>
<li>为了解决这个问题，在java.io包中又专门提供了一组打印流以方便用户的输出操作<ul>
<li>字节打印流：PrintStream<br>我们让用的 <code>System.out.Print</code> out就是PrintStream类型的</li>
<li>字符打印流：PrintWriter</li>
</ul>
</li>
</ul>
</li>
<li>常用的操作方法<br><img src="/2020/03/18/Java%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9/j4.png" alt></li>
<li>PrintStream类的格式化输出<br>  PrintStram类在最初设计时主要是为了弥补OutputStream输出类的功能不足，但是从JDK 1.5开始，为PrintStream增加了格式化输出的支持方法：<ul>
<li>public PrintStream printf(String format, Object… args)。</li>
<li>利用这些方法可以使用像C语言那样的数据标记实现内容填充，常见<br>的输出标记为：整数（%d）、字符串（%s）、小数（%m.nf）、字符<br>（%c）</li>
</ul>
</li>
</ul>
<h5 id="System类对IO的支持"><a href="#System类对IO的支持" class="headerlink" title="System类对IO的支持"></a>System类对IO的支持</h5><p>System类是现在为止使用最多的一个类，所有的信息输出都会使用到“System.out.println()”或“System.out.print()”两个方法完成，而实际上System类中也专门提供了与IO有关的三个常量</p>
<ul>
<li>系统输入:System.in<br>在许多的编程语言之中为了方便用户的交互操作，都会直接提供有一种键盘输入数据的操作功能，但遗憾的是在Java之中并没有提供这样可以直接使用的键盘输入操作，而要想实现此类操作必须采用IO处理的形式完成，而操作的核心就是利用System.in（此为InputStream类实例化对象）完成。<h5 id="缓冲输入流"><a href="#缓冲输入流" class="headerlink" title="缓冲输入流"></a>缓冲输入流</h5>在java.io包中如果要使用缓冲区进行数据操作，</li>
<li>字符缓冲区流：BufferedReader、BufferedWriter；</li>
<li>字节缓冲区流：BufferedInputStream、BufferedOutputStream；</li>
<li>以上给出的四个操作类中，最为重要的就是BufferedReader类，此类是Reader的子类，属于字符缓冲输入流，而如果要处理中文数据，字符流是最方便的，BufferedReader类的常用方法如表所示。</li>
</ul>
<p><img src="/2020/03/18/Java%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9/j5.png" alt></p>
<h5 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h5><ul>
<li>BufferedReader的问题：<br>  读取数据的时候只能按照字符串返回</li>
<li>Scanner</li>
<li>Constructor：Scanner(InputStream source) </li>
<li>Two methods： <ul>
<li>hasNext()<br>判断是否有指定类型的数据</li>
<li>next()<br>Get the data<h5 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h5></li>
</ul>
</li>
<li>Serializable（序列化）<ul>
<li>堆内存-&gt;二进制数据流进行传输</li>
<li>并非所有类的对象都是可以被序列化，必须要实现<code>Serializable</code>接口</li>
<li>ObjectOutputStream:</li>
</ul>
</li>
<li>反序列化<ul>
<li>ObjectInputStream：反序列化</li>
</ul>
</li>
</ul>
<blockquote>
<p>Only action can relieve the uneasiness.            —2020/03/23</p>
</blockquote>
<h3 id="14-Java序列化与反序列化"><a href="#14-Java序列化与反序列化" class="headerlink" title="14 Java序列化与反序列化"></a>14 Java序列化与反序列化</h3><blockquote>
<p>Only action can relieve the uneasiness.            —2020/03/24</p>
</blockquote>
<h3 id="15-OOP"><a href="#15-OOP" class="headerlink" title="15 OOP"></a>15 OOP</h3><h4 id="多态和继承"><a href="#多态和继承" class="headerlink" title="多态和继承"></a>多态和继承</h4><p>成员变量，静态方法看左边；非静态方法：编译看左边，运行看右边。<br><a href="https://blog.csdn.net/foreverhuylee/article/details/21278311/" target="_blank" rel="noopener">多态和继承</a></p>
<h4 id="java-委托"><a href="#java-委托" class="headerlink" title="java 委托"></a>java 委托</h4><h4 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h4><p>abstract </p>
<ul>
<li>抽象类不允许被实例化,只能被继承</li>
<li>它可以包含属性和方法.方法既可以包含代码实现,也可以不包含代码实现.不包含代码实现的方法叫做抽象方法.</li>
<li>子类(具体类)继承抽象类,必须实现抽象类中的所有抽象方法.</li>
</ul>
<p>interfere</p>
<ul>
<li>接口不能包含属性</li>
<li>接口只能声明方法,方法不能包含代码实现<ul>
<li>jdk8开始接口支持default 和static方法</li>
</ul>
</li>
<li>类实现接口的时候,必须实现接口中声明的所有方法.<h4 id><a href="#" class="headerlink" title></a></h4><blockquote>
<p>Only action can relieve the uneasiness.            —2020/03/25</p>
</blockquote>
</li>
</ul>
<h4 id="究竟何为面向对象？"><a href="#究竟何为面向对象？" class="headerlink" title="究竟何为面向对象？"></a>究竟何为面向对象？</h4><p>首先，面向对象是一种思想，它呢是基于面向过程而言的，这种思想是对数据的一种优化<font color="red">这种思想是对数据的一种优化</font><br>其次，理解对象概念</p>
<ul>
<li>什么是对象？<br>对象就是类的一个实例，</li>
<li>什么是类？<br>类就是对一类事物的抽象，这类事物的共同特性就是程序中的属性，共同的行为就是方法。</li>
</ul>
<p>例如：动物这个类。有属性name，有方法eat()。动物类的对象：狗，狗呢就具有name的属性和吃的行为。</p>
<p><font color="red">面向对象的三大特征：封装、继承、多态。</font></p>
<ul>
<li>封装：隐藏了对象的具体细节。提高了复用性和安全性</li>
<li>继承：两个类之间有一些的属性和方法的重复。就使用继承，这样既简化了代码，也提高了代码的复用性</li>
<li>多态：继承是多态的前提。体现在：父类对象的引用可以指向子类对象，这样提高了程序的扩展性<h3 id="Collection-容器"><a href="#Collection-容器" class="headerlink" title="Collection 容器"></a>Collection 容器</h3><img src="/2020/03/18/Java%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B8%80%E7%82%B9/j6.png" alt></li>
</ul>
<h4 id="java容器体系结构"><a href="#java容器体系结构" class="headerlink" title="java容器体系结构"></a>java容器体系结构</h4><ul>
<li><code>==</code> vs equals<ul>
<li><code>==</code><ul>
<li>原始类型 <code>==</code>用来表示两个变量的数值</li>
<li>引用类型 <code>==</code>用来地址的比较</li>
</ul>
</li>
<li>equals<ul>
<li>在Object类中<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>我们可以重写equals方法<br>例如 String类中就重写了equals<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String aString = (String)anObject;</span><br><span class="line">        <span class="keyword">if</span> (coder() == aString.coder()) &#123;</span><br><span class="line">            <span class="keyword">return</span> isLatin1() ? StringLatin1.equals(value, aString.value)</span><br><span class="line">                              : StringUTF16.equals(value, aString.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>Collection<br>  Methods of Collection<ul>
<li>boolean add(E e) </li>
<li>boolean addAll(Collection&lt;? extends E&gt; c) </li>
<li>void clear() </li>
<li>boolean contains(Object o) </li>
<li>boolean containsAll(Collection&lt;?&gt; c) </li>
<li>boolean equals(Object o) </li>
<li>int hashCode() </li>
<li>boolean isEmpty() </li>
<li>Iterator<code>&lt;E&gt;</code> iterator() </li>
<li>boolean remove(Object o) </li>
<li>boolean removeAll(Collection&lt;?&gt; c) </li>
<li>boolean retainAll(Collection&lt;?&gt; c) </li>
<li>int size() </li>
<li>Object[] toArray() </li>
<li>default Stream<code>&lt;E&gt;</code> stream()</li>
<li>Iterator</li>
</ul>
</li>
<li>Iterator and ListIterator<br>  迭代器，用以方便的实现对容器内元素的遍历操作。<ul>
<li>Methods of Iterator:<ul>
<li>hasNext</li>
<li>next()</li>
<li>default void remove() 好像是新增的不怎么使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List包含ArrayList,LinkedList,一般ArrayList比较常用且效率更好</p>
<ul>
<li>List的重要方法<ul>
<li>Object get(int index)</li>
<li>Object set(int index, Object element)</li>
<li>Void add(int index, Object element)</li>
<li>Object remove(int index)</li>
<li>Int indexOf(Object o)</li>
<li>Int lastIndexOf(Object o)<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4></li>
</ul>
</li>
<li>HashSet<ul>
<li>unsorted</li>
<li>including null</li>
</ul>
</li>
<li>TreeSet<ul>
<li>Implementation of SortedSet</li>
<li>sorted</li>
<li>not including null</li>
</ul>
</li>
</ul>
<p><a href="https://blog.csdn.net/zfliu96/article/details/83476493" target="_blank" rel="noopener">不详细列出了</a></p>
<h4 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h4><ul>
<li><p>如何对不同的对象进行排序<br>  java.lang.Comparable接口对实现它的每个类的对象强制排序。</p>
</li>
<li><p>这个接口只有一个方法</p>
<ul>
<li>public int compareTo(Object obj)<ul>
<li>return 0 : this == obj</li>
<li>Return positive number：this &gt; obj</li>
<li>Return negative number：this &lt; </li>
</ul>
</li>
</ul>
</li>
<li><p>实现此接口的所有对象都可以通过实现compareTo方法自动排序。<br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html" target="_blank" rel="noopener">look here</a></p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>将键映射到值的对象。 映射不能包含重复的键；每个键最多可以映射到一个值。</p>
</li>
<li><p>Three main implementing classes</p>
<ul>
<li>HashMap :unsorted</li>
<li>TreeMap: sorted</li>
<li>HashTable : thread safe</li>
</ul>
</li>
<li><p>常用的方法</p>
<ul>
<li>int size() </li>
<li>boolean isEmpty() </li>
<li>Object get(Object key) </li>
<li>Object put(Object key, Object value)/putAll()</li>
<li>Object remove(Object key)</li>
<li>replace(K key, V oldValue, V newValue) </li>
</ul>
</li>
<li><p>遍历方式</p>
<ul>
<li>Map.Entryset<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Map&lt;String,Integer&gt; map = <span class="keyword">new</span> Hashtable&lt;String,Integer&gt;();</span><br><span class="line">	map.put(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">	map.put(<span class="string">"two"</span>, <span class="number">2</span>);</span><br><span class="line">	map.put(<span class="string">"three"</span>, <span class="number">3</span>);</span><br><span class="line">	</span><br><span class="line">	Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set = map.entrySet();</span><br><span class="line">	Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; iter = set.iterator();</span><br><span class="line">	<span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">		Map.Entry&lt;String, Integer&gt; ele = iter.next();</span><br><span class="line">		System.out.println(ele.getKey() + <span class="string">"="</span> + ele.getValue());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>iterator </li>
<li>for </li>
<li>foreach </li>
<li>listiterator</li>
<li>enumeration</li>
</ul>
</li>
</ul>
<h3 id="final-和-static-关键字"><a href="#final-和-static-关键字" class="headerlink" title="final 和 static 关键字"></a>final 和 static 关键字</h3><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>jdk8新特性<br>‘-&gt;’</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>java 多线程</p>
<h3 id="Java-正则表达式"><a href="#Java-正则表达式" class="headerlink" title="Java 正则表达式"></a>Java 正则表达式</h3><p><a href="https://www.cnblogs.com/xyou/p/7427779.html" target="_blank" rel="noopener">https://www.cnblogs.com/xyou/p/7427779.html</a></p>
<h3 id="java面试题"><a href="#java面试题" class="headerlink" title="java面试题"></a>java面试题</h3><p><a href="https://www.cnblogs.com/weirdo-lenovo/p/11418871.html" target="_blank" rel="noopener">java面试问题</a><br><a href="https://blog.csdn.net/u014042066/article/details/77584668?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">面试</a><br><a href="https://blog.csdn.net/jackfrued/article/details/44921941?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">java面试</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Comparator</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Iterator模式</title>
    <url>/2020/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BIterator%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/it2.png" alt></p>
<a id="more"></a>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>意图: 提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</li>
<li>关键实现: 定义接口Iterator:hasNext,next.</li>
<li>优点<ul>
<li>它支持以不同的方式遍历一个聚合对象。 </li>
<li>迭代器简化了聚合类</li>
<li>在同一个聚合上可以有多个遍历</li>
<li>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码</li>
</ul>
</li>
<li>缺点:<ul>
<li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</li>
</ul>
</li>
<li>使用场景:<ul>
<li>访问一个聚合对象的内容而无须暴露它的内部表示</li>
<li>需要为聚合对象提供多种遍历方式</li>
<li>为遍历不同的聚合结构提供一个统一的接口。</li>
</ul>
</li>
<li>注意事项:<ul>
<li>迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/iter.png" alt>VV</li>
</ul>
</li>
</ul>
<p>拿书架类举例:</p>
<table>
<thead>
<tr>
<th align="left">名字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Aggregate</td>
<td align="left">表示集合的接口</td>
</tr>
<tr>
<td align="left">Iterator</td>
<td align="left">遍历集合的接口</td>
</tr>
<tr>
<td align="left">Book</td>
<td align="left">表示书的类</td>
</tr>
<tr>
<td align="left">BookShelf</td>
<td align="left">表示书架的类</td>
</tr>
<tr>
<td align="left">BookShelfIterator</td>
<td align="left">遍历书架的类</td>
</tr>
<tr>
<td align="left">Main</td>
<td align="left">测试程序行为的类</td>
</tr>
</tbody></table>
<p>Aggregate.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Iterator.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Book.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookShelf.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Book[] books;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BookShelf</span><span class="params">(<span class="keyword">int</span> maxsize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.books = <span class="keyword">new</span> Book[maxsize];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Book <span class="title">getBookAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> books[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.books[last] = book;</span><br><span class="line">		last++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> last;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> BookShelfIterator(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookShelfIterator.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelfIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> BookShelf bookShelf;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BookShelfIterator</span><span class="params">(BookShelf bookShelf)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.bookShelf = bookShelf;</span><br><span class="line">		<span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (index &lt; bookShelf.getLength()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Book book = bookShelf.getBookAt(index);</span><br><span class="line">		index++;</span><br><span class="line">		<span class="keyword">return</span> book;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.tju.GOF.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		BookShelf bookShelf = <span class="keyword">new</span> BookShelf(<span class="number">4</span>);</span><br><span class="line">		bookShelf.appendBook(<span class="keyword">new</span> Book(<span class="string">"Around the World in 80 Days"</span>));</span><br><span class="line">		bookShelf.appendBook(<span class="keyword">new</span> Book(<span class="string">"Bible"</span>));</span><br><span class="line">		bookShelf.appendBook(<span class="keyword">new</span> Book(<span class="string">"Cinderella"</span>));</span><br><span class="line">		bookShelf.appendBook(<span class="keyword">new</span> Book(<span class="string">"Daddy-Long-Legs"</span>));</span><br><span class="line">		Iterator it =  bookShelf.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Book book = (Book) it.next();</span><br><span class="line">			System.out.println(book.getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="登场角色"><a href="#登场角色" class="headerlink" title="登场角色"></a>登场角色</h4><ul>
<li><strong>Iterator (迭代器)</strong><br>  该角色负责定义顺序逐个遍历元素的接口(API).在示例程序中,由Iterator接口扮演这个角色,它定义了hasNext 和 next两个方法.其中,hasNext方法用于判断是否存在下一个元素,next方法则用于获取该元素.</li>
<li><strong>ConcreteIterator(具体的迭代器)</strong><br>  该角色负责实现Iterator角色所定义的接口(API).在示例程序中,由BookShelfIterator类扮演这个角色.该角色中包含了遍历集合所需的信息.在示例程序中,BookShelf类的实例保存在bookShelf字段中,被指向的书的下标保存在index字段中.</li>
<li><strong>Aggregate(集合)</strong><br>  该角色负责创建Iterator角色的接口.这个接口是一个方法,会创建出”按顺序访问保存在我内部元素的人”.在实例程序中,由Aggregate接口扮演这个角色,它里面定义了iterator方法.</li>
<li><strong>ConcreteAggregate(具体的集合)</strong><br>  该角色负责实现Aggregate角色所定义的接口,它会创建出具体的Iterator角色.即ConcreteIterator角色,在实例程序中,由BookShelf类扮演这个角色.它实现了iterator方法.</li>
<li>Iterator模式的类图</li>
</ul>
<p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Iterator.png" alt></p>
<h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><ol>
<li><p>python中的Iterator<br><a href="https://blog.csdn.net/BF02jgtRS00XKtCx/article/details/86064960" target="_blank" rel="noopener">python中的Iterator模式</a></p>
</li>
<li><p>难以理解抽象类和接口<br> 难以理解抽象类和接口的人常常使用ConcreteAggregate角色和ConcreteIterator角色编程,而不使用Aggregate接口和Iterator接口,他们总想使用具体的类来解决所有的问题.<br> 但是如果只是用具体的类来解决问题,很容易导致类之间的<strong>强耦合</strong>,这些类也难以作为组件被再次利用.为了弱化类之间的<strong>耦合</strong>,进而使得类更加容易作为组件被再次利用,我们需要引入抽象类和接口.</p>
</li>
</ol>
<p><strong>不要只是用具体类来编程,要有先使用抽象类和接口来编程</strong></p>
<ol start="3">
<li>迭代器的种类多种多样</li>
</ol>
<ul>
<li>从最后开始向前遍历</li>
<li>姐可以从前向后遍历,也可以从后向前遍历(既有next方法,也有previous方法)</li>
<li>指定下标进行”跳跃式”遍历</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>English</title>
    <url>/2020/02/28/English/</url>
    <content><![CDATA[<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E8%A7%86%E9%A2%91/%E6%9C%80%E5%8A%B1%E5%BF%97%E6%BC%94%E8%AE%B2DREAM%20%E8%B6%85%E6%B8%85(720P).mp4","pic":"https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/love/1.jpg"},"danmaku":{"id":"9E2E3368B56CDBB4","api":"http://dplayer.daoapp.io","token":"tokendemo"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>
]]></content>
  </entry>
  <entry>
    <title>python学习 100例</title>
    <url>/2020/02/28/python%E5%AD%A6%E4%B9%A0100%E4%BE%8B/</url>
    <content><![CDATA[<h3 id="Python3-100例"><a href="#Python3-100例" class="headerlink" title="Python3 100例"></a>Python3 100例</h3><blockquote>
<p>原题地址:<br><a href="http://www.runoob.com/python/python-100-examples.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-100-examples.html</a><br>原例子未Python2.7版本<br>本文章采用Python3.7版本</p>
</blockquote>
<p>这是多无聊的人才会做这个啊.感觉好蠢.</p>
<a id="more"></a>
<h4 id="实例001-数字组合"><a href="#实例001-数字组合" class="headerlink" title="实例001:数字组合"></a>实例001:数字组合</h4><blockquote>
<p>有四个数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数？各是多少？</p>
</blockquote>
<p>程序分析 遍历全部可能，把有重复的剃掉。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">if</span>((i!=j)<span class="keyword">and</span> (j!=k)<span class="keyword">and</span>(i!=k)):</span><br><span class="line">                print(i,j,k)</span><br><span class="line">                total +=<span class="number">1</span></span><br><span class="line">print(total) <span class="comment">#24</span></span><br></pre></td></tr></table></figure>
<p>上述是暴力解决,python提供的itertools中的permutations 可以简化本题<br><code>itertools</code>模块我在<a href>常用内建模块中</a>有介绍</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.permutations(range(<span class="number">1</span>,<span class="number">5</span>),<span class="number">3</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    total +=<span class="number">1</span></span><br><span class="line">print(total)</span><br></pre></td></tr></table></figure>

<h4 id="实例002-”个税计算”"><a href="#实例002-”个税计算”" class="headerlink" title="实例002:”个税计算”"></a>实例002:”个税计算”</h4><blockquote>
<p>企业发放的奖金根据利润提成。利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润I，求应发放奖金总数？</p>
</blockquote>
<p>程序分析 分区间计算即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">profit=int(input(<span class="string">'Show me the money: '</span>))</span><br><span class="line">money = [<span class="number">100000</span>,<span class="number">100000</span>,<span class="number">200000</span>,<span class="number">200000</span>,<span class="number">400000</span>]</span><br><span class="line">rates = [<span class="number">0.1</span>,<span class="number">0.075</span>,<span class="number">0.05</span>,<span class="number">0.03</span>,<span class="number">0.015</span>,<span class="number">0.01</span>]</span><br><span class="line">bonus=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(money)):</span><br><span class="line">    <span class="keyword">if</span> profit &lt;= money[i]:</span><br><span class="line">        bonus += profit*rates[i]</span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        bonus += money[i]*rates[i]</span><br><span class="line">        profit -= money[i]</span><br><span class="line">bonus += profit*rates[<span class="number">-1</span>]</span><br><span class="line">print(bonus)</span><br><span class="line">``` </span><br><span class="line">解法<span class="number">2</span>:</span><br><span class="line">```py</span><br><span class="line">profit=int(input(<span class="string">'Show me the money: '</span>))</span><br><span class="line">arr = [<span class="number">1000000</span>,<span class="number">600000</span>,<span class="number">400000</span>,<span class="number">200000</span>,<span class="number">100000</span>,<span class="number">0</span>]</span><br><span class="line">rat = [<span class="number">0.01</span>,<span class="number">0.015</span>,<span class="number">0.03</span>,<span class="number">0.05</span>,<span class="number">0.075</span>,<span class="number">0.1</span>]</span><br><span class="line">r = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span> profit&gt;arr[idx]:</span><br><span class="line">        r+=(profit-arr[idx])*rat[idx]</span><br><span class="line">        profit=arr[idx]</span><br><span class="line"><span class="keyword">print</span> (r)</span><br></pre></td></tr></table></figure>

<h4 id="实例-完全平方数"><a href="#实例-完全平方数" class="headerlink" title="实例: 完全平方数:"></a>实例: 完全平方数:</h4><blockquote>
<p>一个整数，它加上100后是一个完全平方数，再加上168又是一个完<br>全平方数，请问该数是多少？</p>
</blockquote>
<p>程序分析：</p>
<p>假设该数为 x。<br>1、则：x + 100 = n2, x + 100 + 168 = m2<br>2、计算等式：m2 - n2 = (m + n)(m - n) = 168<br>3、设置： m + n = i，m - n = j，i * j =168，i 和 j 至少一个是偶数<br>4、可得： m = (i + j) / 2， n = (i - j) / 2，i 和 j 要么都是偶数，要么都是奇数。<br>5、从 3 和 4 推导可知道，i 与 j 均是大于等于 2 的偶数。<br>6、由于 i * j = 168， j&gt;=2，则 1 &lt; i &lt; 168 / 2 + 1。<br>7、下来将 i 的所有数字循环计算即可。</p>
<p>当然直接用最朴素的方法即可解决本问题</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i = <span class="number">-99</span> <span class="comment"># 1是最小的平方数</span></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">10000</span>:</span><br><span class="line">    iif (i+<span class="number">100</span>)**<span class="number">0.5</span>==int((i+<span class="number">100</span>)**<span class="number">0.5</span>)<span class="keyword">and</span> (i+<span class="number">100</span>+<span class="number">168</span>)**<span class="number">0.5</span>==int((i+<span class="number">100</span>+<span class="number">168</span>)**<span class="number">0.5</span>):</span><br><span class="line">        <span class="keyword">print</span> (i)</span><br><span class="line">    i=i+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>修订版:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这一步是找到相邻两个数的平方差大于等于168的数n</span></span><br><span class="line">n=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (n+<span class="number">1</span>)**<span class="number">2</span>-n*n&lt;=<span class="number">168</span>:</span><br><span class="line">    n+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range((n+<span class="number">1</span>)**<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">if</span> i**<span class="number">0.5</span>==int(i**<span class="number">0.5</span>)<span class="keyword">and</span> (i+<span class="number">168</span>)**<span class="number">0.5</span>==int((i+<span class="number">168</span>)**<span class="number">0.5</span>):</span><br><span class="line">        print(i<span class="number">-100</span>)</span><br><span class="line"><span class="comment">## 源代码    </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">    <span class="keyword">if</span> <span class="number">168</span> % i == <span class="number">0</span>:</span><br><span class="line">        j = <span class="number">168</span> / i</span><br><span class="line">        <span class="keyword">if</span>  i &gt; j <span class="keyword">and</span> (i + j) % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> (i - j) % <span class="number">2</span> == <span class="number">0</span> :</span><br><span class="line">            m = (i + j) / <span class="number">2</span></span><br><span class="line">            n = (i - j) / <span class="number">2</span></span><br><span class="line">            x = n * n - <span class="number">100</span></span><br><span class="line">            print(int(x))</span><br></pre></td></tr></table></figure>

<h4 id="实例004-这天第几天"><a href="#实例004-这天第几天" class="headerlink" title="实例004: 这天第几天"></a>实例004: 这天第几天</h4><blockquote>
<p>输入某年某月某日，判断这一天是这一年的第几天？</p>
</blockquote>
<p>程序分析 特殊情况，闰年时需考虑二月多加一天：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isLeapYear</span><span class="params">(y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (y%<span class="number">400</span>==<span class="number">0</span> <span class="keyword">or</span> (y%<span class="number">4</span>==<span class="number">0</span> <span class="keyword">and</span> y%<span class="number">100</span>!=<span class="number">0</span>))</span><br><span class="line">DayOfMonth=[<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>]</span><br><span class="line">res=<span class="number">0</span></span><br><span class="line">year=int(input(<span class="string">'Year:'</span>))</span><br><span class="line">month=int(input(<span class="string">'Month:'</span>))</span><br><span class="line">day=int(input(<span class="string">'day:'</span>))</span><br><span class="line"><span class="keyword">if</span> isLeapYear(year):</span><br><span class="line">    DayOfMonth[<span class="number">2</span>]+=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,month):</span><br><span class="line">    res+=DayOfMonth[i]</span><br><span class="line">print(res+day)</span><br></pre></td></tr></table></figure>

<h4 id="实例005：三数排序"><a href="#实例005：三数排序" class="headerlink" title="实例005：三数排序"></a>实例005：三数排序</h4><blockquote>
<p>输入三个整数x,y,z，请把这三个数由小到大输出。</p>
</blockquote>
<p>练练手可以自己写一个排序算法,偷懒就直接调用函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">num = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    x = int (input(<span class="string">'the %d is : '</span>%(i+<span class="number">1</span>)))</span><br><span class="line">    num.append(x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort1</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i,len(num)):</span><br><span class="line">            <span class="keyword">if</span>(num[i]&gt;num[j]):</span><br><span class="line">                num[i],num[j]=num[j],num[i]</span><br><span class="line">    <span class="keyword">return</span> num          </span><br><span class="line">print(sort1(num))</span><br></pre></td></tr></table></figure>
<h4 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h4><p>python的排序算法</p>
<h4 id="实例006：斐波那契数列"><a href="#实例006：斐波那契数列" class="headerlink" title="实例006：斐波那契数列"></a>实例006：斐波那契数列</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_1</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">return</span> fib_1(n<span class="number">-1</span>)+fib_1(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#迭代</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_2</span><span class="params">(n)</span>:</span></span><br><span class="line">    a,b=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        a,b=b,a+b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"><span class="keyword">print</span> (fib_2(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出指定个数的斐波那契数列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_list</span><span class="params">(n)</span>:</span></span><br><span class="line">    fibs=[]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        fibs = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        fibs = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>):</span><br><span class="line">        fibs.append[fibs[<span class="number">-1</span>]+fibs[<span class="number">-2</span>]]</span><br><span class="line">    <span class="keyword">return</span> fibs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_yield</span><span class="params">(x)</span>:</span></span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line">    last=<span class="number">1</span></span><br><span class="line">    sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n&lt;x:</span><br><span class="line">        <span class="keyword">yield</span> last </span><br><span class="line">        sum,last=last,sum+last</span><br><span class="line">        n=n+<span class="number">1</span></span><br><span class="line">f = fib_yield(<span class="number">6</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    print(i,end=<span class="string">','</span>)</span><br></pre></td></tr></table></figure>

<h4 id="实例007：copy"><a href="#实例007：copy" class="headerlink" title="实例007：copy"></a>实例007：copy</h4><blockquote>
<p>将一个列表的数据复制到另一个列表中。</p>
</blockquote>
<p>程序分析 使用列表<code>[:]</code>，拿不准可以调用copy模块。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,[<span class="string">'a'</span>,<span class="string">'b'</span>]]</span><br><span class="line"></span><br><span class="line">b = a					<span class="comment"># 赋值</span></span><br><span class="line">c = a[:]				<span class="comment"># 浅拷贝</span></span><br><span class="line">d = copy.copy(a)		<span class="comment"># 浅拷贝</span></span><br><span class="line">e = copy.deepcopy(a)	<span class="comment"># 深拷贝</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">5</span>)</span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">'c'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'a='</span>,a)</span><br><span class="line">print(<span class="string">'b='</span>,b)</span><br><span class="line">print(<span class="string">'c='</span>,c)</span><br><span class="line">print(<span class="string">'d='</span>,d)</span><br><span class="line">print(<span class="string">'e='</span>,e)</span><br></pre></td></tr></table></figure>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">a</span>= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line"><span class="attr">b</span>= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line"><span class="attr">c</span>= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]</span><br><span class="line"><span class="attr">d</span>= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]</span><br><span class="line"><span class="attr">e</span>= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br></pre></td></tr></table></figure>

<h4 id="实例008：九九乘法表"><a href="#实例008：九九乘法表" class="headerlink" title="实例008：九九乘法表"></a>实例008：九九乘法表</h4><blockquote>
<p>输出 9*9 乘法口诀表。</p>
</blockquote>
<p>程序分析 分行与列考虑，共9行9列，i控制行，j控制列</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">        print(<span class="string">'%d*%d=%2d '</span>%(i,j,i*j),end=<span class="string">''</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>

<h4 id="实例009：暂停一秒输出"><a href="#实例009：暂停一秒输出" class="headerlink" title="实例009：暂停一秒输出"></a>实例009：暂停一秒输出</h4><blockquote>
<p>暂停一秒输出。</p>
</blockquote>
<p>程序分析 使用 time 模块的 sleep() 函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span>  itertools.count():</span><br><span class="line">    print(str(int(time.time()))[<span class="number">-2</span>:])</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="实例010：给人看的时间"><a href="#实例010：给人看的时间" class="headerlink" title="实例010：给人看的时间"></a>实例010：给人看的时间</h4><blockquote>
<p>暂停一秒输出，并格式化当前时间。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span>  itertools.count():</span><br><span class="line">    print(time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>,time.localtime(time.time())))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="实例011：养兔子"><a href="#实例011：养兔子" class="headerlink" title="实例011：养兔子"></a>实例011：养兔子</h4><blockquote>
<p>有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？</p>
</blockquote>
<p>程序分析：兔子的规律为数列1,1,2,3,5,8,13,21….<br>其实就是斐波那契</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">month=int(input(<span class="string">'繁殖几个月？： '</span>))</span><br><span class="line">month_1=<span class="number">1</span> </span><br><span class="line">month_2=<span class="number">0</span></span><br><span class="line">month_elder=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,month):</span><br><span class="line">    month_1,month_2,month_elder=month_elder+month_2,month_1,month_elder+month_2</span><br><span class="line">    print(<span class="string">'第%d个月共'</span>%(i+<span class="number">1</span>),month_1+month_2+month_elder,<span class="string">'对兔子'</span>)</span><br><span class="line">    print(<span class="string">'其中1月兔：'</span>,month_1)</span><br><span class="line">    print(<span class="string">'其中2月兔：'</span>,month_2)</span><br><span class="line">    print(<span class="string">'其中成年兔：'</span>,month_elder)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rabbit</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">return</span> rabbit(n<span class="number">-1</span>)+rabbit(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line">print(rabbit(month))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rabbit</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">return</span> rabbit(n<span class="number">-1</span>)+rabbit(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line">print(rabbit(month))</span><br></pre></td></tr></table></figure>

<h4 id="实例012：100到200的素数"><a href="#实例012：100到200的素数" class="headerlink" title="实例012：100到200的素数"></a>实例012：100到200的素数</h4><blockquote>
<p>判断101-200之间有多少个素数，并输出所有素数。</p>
</blockquote>
<p>程序分析 判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，则表明此数不是素数，反之是素数。 用else可以进一步简化代码.</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>,<span class="number">200</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>,math.ceil(math.sqrt(i))):</span><br><span class="line">        <span class="keyword">if</span> i % j ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:<span class="comment"># python中可以使用for-else</span></span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure>
<h4 id="实例013：所有水仙花数"><a href="#实例013：所有水仙花数" class="headerlink" title="实例013：所有水仙花数"></a>实例013：所有水仙花数</h4><blockquote>
<p>打印出所有的”水仙花数”，所谓”水仙花数”是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个”水仙花数”，因为153=1的三次方＋5的三次方＋3的三次方。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>,<span class="number">1000</span>):</span><br><span class="line">    a = i % <span class="number">10</span></span><br><span class="line">    b = i//<span class="number">10</span> %<span class="number">10</span></span><br><span class="line">    c = i // <span class="number">100</span></span><br><span class="line">    <span class="keyword">if</span> i == a**<span class="number">3</span>+b**<span class="number">3</span>+c**<span class="number">3</span>:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure>

<h4 id="实例014：分解质因数"><a href="#实例014：分解质因数" class="headerlink" title="实例014：分解质因数"></a>实例014：分解质因数</h4><blockquote>
<p>一个整数分解质因数。例如：输入90,打印出90=233*5。</p>
</blockquote>
<p>程序分析: 根本不需要判断是否是质数，从2开始向数本身遍历，能整除的肯定是最小的质数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">target = int(input(<span class="string">'请输入一个整数:'</span>))</span><br><span class="line">print(target, <span class="string">'= '</span>, end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> target == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, target+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> target % i == <span class="number">0</span>:</span><br><span class="line">            print(i, end=<span class="string">''</span>)</span><br><span class="line">            <span class="keyword">if</span> target != i:</span><br><span class="line">                print(<span class="string">"*"</span>, end=<span class="string">''</span>)</span><br><span class="line">            target = int(target/i)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h4 id="实例015：分数归档"><a href="#实例015：分数归档" class="headerlink" title="实例015：分数归档"></a>实例015：分数归档</h4><blockquote>
<p>利用条件运算符的嵌套来完成此题：学习成绩&gt;=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。</p>
</blockquote>
<p>程序分析 用条件判断即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">points=int(input(<span class="string">'输入分数：'</span>))</span><br><span class="line"><span class="keyword">if</span> points&gt;=<span class="number">90</span>:</span><br><span class="line">    grade=<span class="string">'A'</span></span><br><span class="line"><span class="keyword">elif</span> points&lt;<span class="number">60</span>:</span><br><span class="line">    grade=<span class="string">'C'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    grade=<span class="string">'B'</span></span><br><span class="line">print(grade)</span><br></pre></td></tr></table></figure>

<h4 id="实例016：输出日期"><a href="#实例016：输出日期" class="headerlink" title="实例016：输出日期"></a>实例016：输出日期</h4><blockquote>
<p>输出指定格式的日期。</p>
</blockquote>
<p>程序分析 使用 datetime 模块。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 输出今日日期，格式为 dd/mm/yyyy。更多选项可以查看 strftime() 方法</span></span><br><span class="line">    print(datetime.date.today().strftime(<span class="string">'%d/%m/%Y'</span>))</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 创建日期对象</span></span><br><span class="line">    miyazakiBirthDate = datetime.date(<span class="number">1941</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line">    print(miyazakiBirthDate.strftime(<span class="string">'%d/%m/%Y'</span>))</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 日期算术运算</span></span><br><span class="line">    miyazakiBirthNextDay = miyazakiBirthDate + datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    print(miyazakiBirthNextDay.strftime(<span class="string">'%d/%m/%Y'</span>))</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 日期替换</span></span><br><span class="line">    miyazakiFirstBirthday = miyazakiBirthDate.replace(year=miyazakiBirthDate.year + <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    print(miyazakiFirstBirthday.strftime(<span class="string">'%d/%m/%Y'</span>))</span><br></pre></td></tr></table></figure>

<h4 id="实例017：字符串构成"><a href="#实例017：字符串构成" class="headerlink" title="实例017：字符串构成"></a>实例017：字符串构成</h4><blockquote>
<p>输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。</p>
</blockquote>
<p>程序分析 利用 while 或 for 语句,条件为输入的字符不为 ‘\n’。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">string=input(<span class="string">"输入字符串："</span>)</span><br><span class="line">alp=<span class="number">0</span></span><br><span class="line">num=<span class="number">0</span></span><br><span class="line">spa=<span class="number">0</span></span><br><span class="line">oth=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(string)):</span><br><span class="line">    <span class="keyword">if</span> string[i].isspace():</span><br><span class="line">        spa+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> string[i].isdigit():</span><br><span class="line">        num+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> string[i].isalpha():</span><br><span class="line">        alp+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        oth+=<span class="number">1</span></span><br><span class="line">print(<span class="string">'space: '</span>,spa)</span><br><span class="line">print(<span class="string">'digit: '</span>,num)</span><br><span class="line">print(<span class="string">'alpha: '</span>,alp)</span><br><span class="line">print(<span class="string">'other: '</span>,oth)</span><br></pre></td></tr></table></figure>

<h4 id="实例018：复读机相加"><a href="#实例018：复读机相加" class="headerlink" title="实例018：复读机相加"></a>实例018：复读机相加</h4><p>题目 求s=a+aa+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加由键盘控制。</p>
<p>程序分析 用字符串解决。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=input(<span class="string">'被加数字：'</span>)</span><br><span class="line">n=int(input(<span class="string">'加几次？：'</span>))</span><br><span class="line">res=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    res+=int(a)</span><br><span class="line">    a+=a[<span class="number">0</span>]</span><br><span class="line">print(<span class="string">'结果是：'</span>,res)</span><br></pre></td></tr></table></figure>

<h4 id="实例019：完数"><a href="#实例019：完数" class="headerlink" title="实例019：完数"></a>实例019：完数</h4><blockquote>
<p>一个数如果恰好等于它的因子之和，这个数就称为”完数”。例如6=1＋2＋3.编程找出1000以内的所有完数。</p>
</blockquote>
<p>程序分析 将每一对因子加进集合，在这个过程中已经自动去重。最后的结果要求不计算其本身。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#找到所有的因子</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">1001</span>):</span><br><span class="line">    num = i</span><br><span class="line">    k = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i):</span><br><span class="line">        <span class="keyword">if</span> i % j == <span class="number">0</span> :</span><br><span class="line">            k.append(j)</span><br><span class="line">    <span class="keyword">if</span> (sum(k)==i):</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure>
<h4 id="实例020：高空抛物"><a href="#实例020：高空抛物" class="headerlink" title="实例020：高空抛物"></a>实例020：高空抛物</h4><blockquote>
<p>一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">high = <span class="number">100.0</span></span><br><span class="line">tim = <span class="number">10</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(tim):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        total += high</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        total += high *<span class="number">2</span></span><br><span class="line">    high /= <span class="number">2</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"high= &#123;&#125;,total = &#123;&#125;"</span>.format(high,total))</span><br></pre></td></tr></table></figure>
<h4 id="实例021：猴子偷桃"><a href="#实例021：猴子偷桃" class="headerlink" title="实例021：猴子偷桃"></a>实例021：猴子偷桃</h4><blockquote>
<p>猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。</p>
</blockquote>
<p>程序分析 按规则反向推断：猴子有一个桃子，他偷来一个桃子，觉得不够又偷来了与手上等量的桃子，一共偷了9天。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">peach=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">    peach=(peach+<span class="number">1</span>)*<span class="number">2</span></span><br><span class="line">print(peach)</span><br></pre></td></tr></table></figure>
<h4 id="实例022：比赛对手"><a href="#实例022：比赛对手" class="headerlink" title="实例022：比赛对手"></a>实例022：比赛对手</h4><blockquote>
<p>两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。</p>
</blockquote>
<p>程序分析 找到条件下不重复的三个对手即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=set([<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>])</span><br><span class="line">b=set([<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>])</span><br><span class="line">c=set([<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>])</span><br><span class="line">c-=set((<span class="string">'x'</span>,<span class="string">'z'</span>))</span><br><span class="line">a-=set(<span class="string">'x'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> b:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> c:</span><br><span class="line">            <span class="keyword">if</span> len(set((i,j,k)))==<span class="number">3</span>:</span><br><span class="line">                print(<span class="string">'a:%s,b:%s,c:%s'</span>%(i,j,k))</span><br></pre></td></tr></table></figure>
<h4 id="画菱形"><a href="#画菱形" class="headerlink" title="画菱形"></a>画菱形</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">打印出如下图案</span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">   ***</span></span><br><span class="line"><span class="comment">  *****</span></span><br><span class="line"><span class="comment"> *******</span></span><br><span class="line"><span class="comment">  *****</span></span><br><span class="line"><span class="comment">   ***</span></span><br><span class="line"><span class="comment">    *</span></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> stdout</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n-i):</span><br><span class="line">            stdout.write(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>*i+<span class="number">1</span>):</span><br><span class="line">            stdout.write(<span class="string">'*'</span>)</span><br><span class="line">        stdout.write(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>-i):</span><br><span class="line">            stdout.write(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>*i<span class="number">-1</span>):</span><br><span class="line">            stdout.write(<span class="string">'*'</span>)</span><br><span class="line">        stdout.write(<span class="string">'\n'</span>)</span><br><span class="line">draw(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#递归做法,类似二叉树的中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw2</span><span class="params">(num)</span>:</span></span><br><span class="line">    a=<span class="string">"*"</span>*(<span class="number">2</span>*(<span class="number">4</span>-num)+<span class="number">1</span>)</span><br><span class="line">    print(a.center(<span class="number">9</span>,<span class="string">' '</span>))</span><br><span class="line">    <span class="keyword">if</span> num!=<span class="number">1</span>:</span><br><span class="line">        draw2(num<span class="number">-1</span>)</span><br><span class="line">        print(a.center(<span class="number">9</span>,<span class="string">' '</span>))</span><br><span class="line">draw2(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/he_and/article/details/80675070" target="_blank" rel="noopener">stdout与 print 的关系</a></p>
<h4 id="实例024：斐波那契数列II"><a href="#实例024：斐波那契数列II" class="headerlink" title="实例024：斐波那契数列II"></a>实例024：斐波那契数列II</h4><blockquote>
<p>有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前20项之和。</p>
</blockquote>
<p>程序分析 就是斐波那契数列的后一项除以前一项。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    a,b=<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    sum = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        a,b=b,a+b</span><br><span class="line">        sum += b / a</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"><span class="keyword">print</span> (sum_fib(<span class="number">20</span>))</span><br></pre></td></tr></table></figure>

<h4 id="实例025：-阶乘求和"><a href="#实例025：-阶乘求和" class="headerlink" title="实例025： 阶乘求和"></a>实例025： 阶乘求和</h4><blockquote>
<p>求1+2!+3!+…+20!的和。</p>
</blockquote>
<p>程序分析 1+2!+3!+…+20!=1+2(1+3(1+4(…20(1))))</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1+2!+3!+…+20!=1+2(1+3(1+4(…20(1))))</span></span><br><span class="line">res=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>,<span class="number">1</span>,<span class="number">-1</span>):</span><br><span class="line">    res=i*res+<span class="number">1</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<h4 id="实例026：递归求阶乘"><a href="#实例026：递归求阶乘" class="headerlink" title="实例026：递归求阶乘"></a>实例026：递归求阶乘</h4><blockquote>
<p>利用递归方法求5!。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n*factorial(n<span class="number">-1</span>) <span class="keyword">if</span> n&gt;<span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">print(factorial(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<h4 id="实例027：递归输出"><a href="#实例027：递归输出" class="headerlink" title="实例027：递归输出"></a>实例027：递归输出</h4><p>利用递归函数调用方式，将所输入的5个字符，以相反顺序打印出来。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rec</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(string)!=<span class="number">1</span>:</span><br><span class="line">        rec(string[<span class="number">1</span>:])</span><br><span class="line">    print(string[<span class="number">0</span>],end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">rec(input(<span class="string">'string here:'</span>))</span><br></pre></td></tr></table></figure>
<p>非递归</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">input(<span class="string">'string here:'</span>)</span><br><span class="line"><span class="keyword">print</span> ((input(<span class="string">'string here:'</span>))[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h4 id="示例028-递归求等差数列"><a href="#示例028-递归求等差数列" class="headerlink" title="示例028:递归求等差数列"></a>示例028:递归求等差数列</h4><blockquote>
<p>有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> <span class="keyword">if</span> n==<span class="number">1</span> <span class="keyword">else</span> <span class="number">2</span>+age(n<span class="number">-1</span>)</span><br><span class="line">print(age(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<h4 id="实例029：反向输出"><a href="#实例029：反向输出" class="headerlink" title="实例029：反向输出"></a>实例029：反向输出</h4><blockquote>
<p>给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。</p>
</blockquote>
<p>程序分析 学会分解出每一位数,用字符串的方法总是比较省事。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x = int(input(<span class="string">"请输入一个数:\n"</span>))</span><br><span class="line">a = x // <span class="number">10000</span></span><br><span class="line">b = x % <span class="number">10000</span> // <span class="number">1000</span></span><br><span class="line">c = x % <span class="number">1000</span> // <span class="number">100</span></span><br><span class="line">d = x % <span class="number">100</span> // <span class="number">10</span></span><br><span class="line">e = x % <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> a != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"5 位数："</span>,e,d,c,b,a)</span><br><span class="line"><span class="keyword">elif</span> b != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"4 位数："</span>,e,d,c,b,)</span><br><span class="line"><span class="keyword">elif</span> c != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"3 位数："</span>,e,d,c)</span><br><span class="line"><span class="keyword">elif</span> d != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"2 位数："</span>,e,d)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"1 位数："</span>,e)</span><br><span class="line"><span class="comment"># 还是字符串比较简单</span></span><br><span class="line">s = str(x)</span><br><span class="line">n = len(s)</span><br><span class="line">print(str(n)+<span class="string">" 位数 逆序为:"</span>+ s[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>

<h4 id="实例030：回文数"><a href="#实例030：回文数" class="headerlink" title="实例030：回文数"></a>实例030：回文数</h4><p>一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">n=input(<span class="string">"随便你输入啥啦："</span>)</span><br><span class="line"><span class="keyword">if</span> n == (n[::<span class="number">-1</span>]):</span><br><span class="line">    <span class="keyword">print</span> (n+<span class="string">"是回文数"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (n+<span class="string">"不是回文数"</span>)</span><br></pre></td></tr></table></figure>
<h4 id="实例031：字母识词"><a href="#实例031：字母识词" class="headerlink" title="实例031：字母识词"></a>实例031：字母识词</h4><blockquote>
<p>请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。</p>
</blockquote>
<p>可以用条件语句或者switch解决.本题尝试用字典来写一下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">weekT=&#123;<span class="string">'h'</span>:<span class="string">'Thursday'</span>,</span><br><span class="line">       <span class="string">'u'</span>:<span class="string">'Tuesday'</span>&#125;</span><br><span class="line">weekS=&#123;<span class="string">'a'</span>:<span class="string">'Saturday'</span>,</span><br><span class="line">       <span class="string">'u'</span>:<span class="string">'Sunday'</span>&#125;</span><br><span class="line">week=&#123;<span class="string">'t'</span>:weekT,</span><br><span class="line">      <span class="string">'s'</span>:weekS,</span><br><span class="line">      <span class="string">'m'</span>:<span class="string">'Monday'</span>,</span><br><span class="line">      <span class="string">'w'</span>:<span class="string">'Wensday'</span>,</span><br><span class="line">      <span class="string">'f'</span>:<span class="string">'Friday'</span>&#125;</span><br><span class="line">a=week[input(<span class="string">'请输入第一位字母:'</span>).lower()]</span><br><span class="line"><span class="keyword">if</span> a==weekT <span class="keyword">or</span> a==weekS:</span><br><span class="line">    print(a[input(<span class="string">'请输入第二位字母:'</span>).lower()])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h4 id="实例032：反向输出II"><a href="#实例032：反向输出II" class="headerlink" title="实例032：反向输出II"></a>实例032：反向输出II</h4><blockquote>
<p>按相反的顺序输出列表的值。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line">print(a[::<span class="number">-1</span>])</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    a[i]=a[i][::<span class="number">-1</span>]</span><br><span class="line">print(a[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h4 id="实例033：列表转字符串"><a href="#实例033：列表转字符串" class="headerlink" title="实例033：列表转字符串"></a>实例033：列表转字符串</h4><blockquote>
<p>按逗号分隔列表。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">print(<span class="string">','</span>.join(str(n) <span class="keyword">for</span> n <span class="keyword">in</span> L))</span><br></pre></td></tr></table></figure>
<h4 id="实例034：调用函数"><a href="#实例034：调用函数" class="headerlink" title="实例034：调用函数"></a>实例034：调用函数</h4><blockquote>
<p>练习函数调用。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello World!'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helloAgain</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        hello()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    helloAgain()</span><br></pre></td></tr></table></figure>
<h4 id="实例035：设置输出颜色"><a href="#实例035：设置输出颜色" class="headerlink" title="实例035：设置输出颜色"></a>实例035：设置输出颜色</h4><blockquote>
<p>文本颜色设置。</p>
</blockquote>
<p>这个还是很有趣的</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bcolors</span>:</span></span><br><span class="line">    HEADER = <span class="string">'\033[95m'</span></span><br><span class="line">    OKBLUE = <span class="string">'\033[94m'</span></span><br><span class="line">    OKGREEN = <span class="string">'\033[92m'</span></span><br><span class="line">    WARNING = <span class="string">'\033[93m'</span></span><br><span class="line">    FAIL = <span class="string">'\033[91m'</span></span><br><span class="line">    ENDC = <span class="string">'\033[0m'</span></span><br><span class="line">    BOLD = <span class="string">'\033[1m'</span></span><br><span class="line">    UNDERLINE = <span class="string">'\033[4m'</span></span><br><span class="line">print(bcolors.WARNING + <span class="string">"警告的颜色字体?"</span> + bcolors.OKGREEN)</span><br></pre></td></tr></table></figure>
<h4 id="实例036：算素数"><a href="#实例036：算素数" class="headerlink" title="实例036：算素数"></a>实例036：算素数</h4><blockquote>
<p>求100之内的素数。</p>
</blockquote>
<p>程序分析 用else执行for循环的奖励代码（如果for是正常完结，非break）。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">lo=int(input(<span class="string">'下限：'</span>))</span><br><span class="line">hi=int(input(<span class="string">'上限：'</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(lo,hi+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>,i):</span><br><span class="line">            <span class="keyword">if</span> (i % j) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(i)</span><br></pre></td></tr></table></figure>

<h4 id="示例037-排序"><a href="#示例037-排序" class="headerlink" title="示例037:排序"></a>示例037:排序</h4><blockquote>
<p>对10个数进行排序。</p>
</blockquote>
<p>跟第五题一样</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">num = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    x = int (input(<span class="string">'the %d is : '</span>%(i+<span class="number">1</span>)))</span><br><span class="line">    num.append(x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort1</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i,len(num)):</span><br><span class="line">            <span class="keyword">if</span>(num[i]&gt;num[j]):</span><br><span class="line">                num[i],num[j]=num[j],num[i]</span><br><span class="line">    <span class="keyword">return</span> num          </span><br><span class="line">print(sort1(num))</span><br></pre></td></tr></table></figure>
<h4 id="实例038：-矩阵对角线之和"><a href="#实例038：-矩阵对角线之和" class="headerlink" title="实例038： 矩阵对角线之和"></a>实例038： 矩阵对角线之和</h4><blockquote>
<p>一个3*3矩阵主对角线元素之和。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">mat=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">     [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">     [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">    ]</span><br><span class="line">res=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(mat)):</span><br><span class="line">    res+=mat[i][i]</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<h4 id="实例039：有序列表插入元素"><a href="#实例039：有序列表插入元素" class="headerlink" title="实例039：有序列表插入元素"></a>实例039：有序列表插入元素</h4><blockquote>
<p>有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。</p>
</blockquote>
<p>程序分析:先加在最后,然后判断是否比前一个大</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ls = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>,<span class="number">10000</span>,<span class="number">20000</span>]</span><br><span class="line">ln = len(ls)</span><br><span class="line"><span class="keyword">print</span> (ls)</span><br><span class="line">n = int(input(<span class="string">'insert a number:'</span>))</span><br><span class="line">ls.append(n)</span><br><span class="line"><span class="keyword">while</span> ln:</span><br><span class="line">    <span class="keyword">if</span> ls[ln] &lt; ls[ln<span class="number">-1</span>]:</span><br><span class="line">        ls [ln<span class="number">-1</span>],ls[ln] = ls[ln],ls[ln<span class="number">-1</span>]</span><br><span class="line">        ln-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> : <span class="keyword">break</span>    </span><br><span class="line">print(ls)</span><br></pre></td></tr></table></figure>

<h4 id="实例040：逆序列表"><a href="#实例040：逆序列表" class="headerlink" title="实例040：逆序列表"></a>实例040：逆序列表</h4><blockquote>
<p>将一个数组逆序输出。</p>
</blockquote>
<p>程序分析 依次交换位置，或者直接调用reverse方法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">lis=[<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>,<span class="number">10000</span>,<span class="number">100000</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(int(len(lis)/<span class="number">2</span>)):</span><br><span class="line">    lis[i],lis[len(lis)<span class="number">-1</span>-i]=lis[len(lis)<span class="number">-1</span>-i],lis[i]</span><br><span class="line">print(<span class="string">'第一种实现：'</span>)</span><br><span class="line">print(lis)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lis=[<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>,<span class="number">10000</span>,<span class="number">100000</span>]</span><br><span class="line">print(<span class="string">'第二种实现：'</span>)</span><br><span class="line">lis.reverse()</span><br><span class="line">print(lis)</span><br></pre></td></tr></table></figure>

<h4 id="实例041：类的方法与变量"><a href="#实例041：类的方法与变量" class="headerlink" title="实例041：类的方法与变量"></a>实例041：类的方法与变量</h4><blockquote>
<p>模仿静态变量的用法。</p>
</blockquote>
<p>程序分析 构造类，了解类的方法与变量。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dummy</span><span class="params">()</span>:</span></span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    print(i)</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cls</span>:</span></span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dummy</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.i)</span><br><span class="line">        self.i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">a=cls()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    dummy()</span><br><span class="line">    a.dummy()</span><br></pre></td></tr></table></figure>

<h4 id="实例042：变量作用域"><a href="#实例042：变量作用域" class="headerlink" title="实例042：变量作用域"></a>实例042：变量作用域</h4><blockquote>
<p>学习使用auto定义变量的用法。</p>
</blockquote>
<p>程序分析 python中的变量作用域</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i=<span class="number">0</span></span><br><span class="line">n=<span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dummy</span><span class="params">()</span>:</span></span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    print(i)</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dummy2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    print(n)</span><br><span class="line">    n+=<span class="number">1</span></span><br><span class="line">print(<span class="string">'函数内部的同名变量'</span>)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    dummy()</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line">print(<span class="string">'global声明同名变量'</span>)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    print(n)</span><br><span class="line">    dummy2()</span><br><span class="line">    n+=<span class="number">10</span></span><br></pre></td></tr></table></figure>
<h4 id="实例043：作用域、类的方法与变量"><a href="#实例043：作用域、类的方法与变量" class="headerlink" title="实例043：作用域、类的方法与变量"></a>实例043：作用域、类的方法与变量</h4><blockquote>
<p>模仿静态变量(static)另一案例。</p>
</blockquote>
<p>程序分析 综合实例041和实例042。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dumy</span>:</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Num</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'class dumy num:'</span>,self.num)</span><br><span class="line">        print(<span class="string">'global num:'</span>,num)</span><br><span class="line">        self.num+=<span class="number">1</span></span><br><span class="line">n = dumy()</span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    num*=<span class="number">10</span></span><br><span class="line">    n.Num()</span><br></pre></td></tr></table></figure>
<h4 id="实例044：矩阵相加"><a href="#实例044：矩阵相加" class="headerlink" title="实例044：矩阵相加"></a>实例044：矩阵相加</h4><blockquote>
<p>计算两个矩阵相加。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">X = [[<span class="number">12</span>,<span class="number">7</span>,<span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span> ,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">    [<span class="number">7</span> ,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line"> </span><br><span class="line">Y = [[<span class="number">5</span>,<span class="number">8</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>]]</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(X,Y)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(X)==len(Y) <span class="keyword">and</span> len(X[<span class="number">0</span>])==len(Y[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(X[<span class="number">0</span>])):</span><br><span class="line">                X[i][j]+=Y[i][j]</span><br><span class="line">        print(X)</span><br><span class="line">        <span class="keyword">return</span> X</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        print(<span class="string">'wrong!!!'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><p>拓展:矩阵相乘</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实例045：求和"><a href="#实例045：求和" class="headerlink" title="实例045：求和"></a>实例045：求和</h4><blockquote>
<p>统计 1 到 100 之和。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">res=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">    res+=i</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<h4 id="实例046：打破循环"><a href="#实例046：打破循环" class="headerlink" title="实例046：打破循环"></a>实例046：打破循环</h4><blockquote>
<p>求输入数字的平方，如果平方运算后小于 50 则退出。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = float(input(<span class="string">'输入一个数字:'</span>))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'错误输入'</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    dn = n**<span class="number">2</span></span><br><span class="line">    <span class="keyword">print</span> (str(n)+<span class="string">'的平方是'</span>+dn)</span><br><span class="line">    <span class="keyword">if</span> dn&lt;<span class="number">50</span>:</span><br><span class="line">        print(<span class="string">"平方小于50,退出"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h4 id="实例047：函数交换变量"><a href="#实例047：函数交换变量" class="headerlink" title="实例047：函数交换变量"></a>实例047：函数交换变量</h4><blockquote>
<p>两个变量值用函数互换。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exc</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (b,a)</span><br><span class="line">a=<span class="number">0</span></span><br><span class="line">b=<span class="number">10</span></span><br><span class="line">a,b=exc(a,b)</span><br><span class="line">print(a,b)</span><br></pre></td></tr></table></figure>
<h4 id="实例048：数字比大小"><a href="#实例048：数字比大小" class="headerlink" title="实例048：数字比大小"></a>实例048：数字比大小</h4><blockquote>
<p>数字比较</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=int(input(<span class="string">'a='</span>))</span><br><span class="line">b=int(input(<span class="string">'b='</span>))</span><br><span class="line"><span class="keyword">if</span> a&lt;b:</span><br><span class="line">    print(<span class="string">'a&lt;b'</span>)</span><br><span class="line"><span class="keyword">elif</span> a&gt;b:</span><br><span class="line">    print(<span class="string">'a&gt;b'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'a=b'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="实例049：lambda"><a href="#实例049：lambda" class="headerlink" title="实例049：lambda"></a>实例049：lambda</h4><blockquote>
<p>使用lambda来创建匿名函数。<br>经常和python中的内置函数一起使用</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">foo = [<span class="number">2</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">22</span>, <span class="number">17</span>, <span class="number">24</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">27</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">        <span class="keyword">print</span> (i,end=<span class="string">' '</span>)</span><br><span class="line">    print()</span><br><span class="line">fi=filter(<span class="keyword">lambda</span> x:x%<span class="number">3</span>==<span class="number">0</span>,foo)</span><br><span class="line">p(fi)</span><br><span class="line">mp=map(<span class="keyword">lambda</span> x:x*<span class="number">2</span>+<span class="number">10</span>,foo)</span><br><span class="line">p(mp)</span><br><span class="line">rd = reduce(<span class="keyword">lambda</span> x,y:x+y,foo)</span><br><span class="line"><span class="keyword">print</span> (rd)</span><br></pre></td></tr></table></figure>
<h4 id="实例050：随机数"><a href="#实例050：随机数" class="headerlink" title="实例050：随机数"></a>实例050：随机数</h4><blockquote>
<p>输出一个随机数。</p>
</blockquote>
<p>程序分析 使用 <a href="https://blog.csdn.net/weixin_41084236/article/details/81457949" target="_blank" rel="noopener">random 模块</a>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">print(random.uniform(<span class="number">10</span>,<span class="number">20</span>))</span><br></pre></td></tr></table></figure>

<h2 id="random内置模块中的方法注解"><a href="#random内置模块中的方法注解" class="headerlink" title="random内置模块中的方法注解"></a>random内置模块中的方法注解</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">random.seed(a=<span class="literal">None</span>, version=<span class="number">2</span>)  <span class="comment"># 初始化伪随机数生成器，若种子a相同，则可以使生成的随机数相同。如果未提供a或者a=None，则使用系统时间为种子。</span></span><br><span class="line">random.random()  <span class="comment"># 返回一个介于左闭右开[0.0, 1.0)区间的浮点数。</span></span><br><span class="line">random.randint(a, b)  <span class="comment"># 返回range[a,b]之间的一个整数。</span></span><br><span class="line">random.uniform(a, b)  <span class="comment"># 返回一个介于a和b之间（含a,b）的浮点数。如果a&gt;b，则是b到a之间的浮点数。</span></span><br><span class="line">random.randrange(start, stop[, step])  <span class="comment"># 返回range[start,stop)之间的一个整数，可加步长step，跟range(0,10,2)类似。</span></span><br><span class="line">random.choice(seq)  <span class="comment"># 从非空序列seq中随机选取一个元素。如果seq为空则弹出 IndexError异常。</span></span><br><span class="line">random.choices(population, weights=<span class="literal">None</span>, *, cum_weights=<span class="literal">None</span>, k=<span class="number">1</span>)  <span class="comment"># 3.6版本新增！从population集群中随机抽取K个元素（可重复）。weights是相对权重列表，cum_weights是累计权重，两个参数不能同时存在。</span></span><br><span class="line">random.sample(population, k)  <span class="comment"># 从population样本或集合中随机抽取K个元素（不重复）形成新的序列。常用于不重复的随机抽样、打乱序列。</span></span><br><span class="line">random.shuffle(x[, random])  <span class="comment"># 随机打乱序列x内元素的排列顺序。只能针对可变的序列，对于不可变序列，请使用sample()方法。</span></span><br><span class="line"></span><br><span class="line">random.triangular(low, high, mode)  <span class="comment"># 返回一个N∈[low, high]的三角形分布的随机数。参数mode指明众数出现位置。</span></span><br><span class="line">random.betavariate(alpha, beta)  <span class="comment"># β分布。返回的结果在0~1之间。</span></span><br><span class="line">random.gammavariate(alpha, beta)  <span class="comment"># 伽玛分布。</span></span><br><span class="line">random.expovariate(lambd)  <span class="comment"># 指数分布。</span></span><br><span class="line">random.gauss(mu, sigma)  <span class="comment"># 高斯分布。</span></span><br><span class="line">random.normalvariate(mu, sigma)  <span class="comment"># 正态分布。</span></span><br><span class="line">random.lognormvariate(mu, sigma)  <span class="comment"># 对数正态分布。</span></span><br><span class="line">random.vonmisesvariate(mu, kappa)  <span class="comment"># 卡帕分布。</span></span><br><span class="line">random.paretovariate(alpha)  <span class="comment"># 帕累托分布。</span></span><br><span class="line">random.weibullvariate(alpha, beta)  <span class="comment"># 威布尔分布。</span></span><br><span class="line"></span><br><span class="line">random.getstate()  <span class="comment"># 返回一个当前生成器的内部状态的对象。</span></span><br><span class="line">random.setstate(state)  <span class="comment"># 传入一个先前利用getstate方法获得的状态对象，使得生成器恢复到这个状态。</span></span><br></pre></td></tr></table></figure>

<h4 id="实例051：按位与"><a href="#实例051：按位与" class="headerlink" title="实例051：按位与"></a>实例051：按位与</h4><blockquote>
<p>学习使用按位与 &amp; 。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=<span class="number">0o77</span></span><br><span class="line">print(bin(a))</span><br><span class="line">b=a&amp;<span class="number">3</span></span><br><span class="line">print(b)</span><br><span class="line">b=b&amp;<span class="number">7</span></span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>

<h4 id="实例052：按位或"><a href="#实例052：按位或" class="headerlink" title="实例052：按位或"></a>实例052：按位或</h4><blockquote>
<p>学习使用按位或 | 。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=<span class="number">0o70</span></span><br><span class="line">print(bin(a|<span class="number">3</span>))</span><br><span class="line">print(bin(a|<span class="number">3</span>|<span class="number">7</span>))</span><br></pre></td></tr></table></figure>
<h4 id="实例053：按位异或"><a href="#实例053：按位异或" class="headerlink" title="实例053：按位异或"></a>实例053：按位异或</h4><blockquote>
<p>学习使用按位异或 ^ 。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">0xFF</span></span><br><span class="line">print(bin(a^<span class="number">0</span>))</span><br><span class="line">print(bin(a^<span class="number">7</span>))</span><br></pre></td></tr></table></figure>

<h4 id="实例054：位取反、位移动"><a href="#实例054：位取反、位移动" class="headerlink" title="实例054：位取反、位移动"></a>实例054：位取反、位移动</h4><blockquote>
<p>取一个整数a从右端开始的4〜7位。</p>
</blockquote>
<p>程序分析:(1)先使a右移4位.<br>(2)设置一个低4位全为1,其余全为0的数 <del>(</del>0&lt;&lt;4)<br>(3)将上面二者进行&amp;运算</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = int(input(<span class="string">'input a number:\n'</span>))</span><br><span class="line">    b = a &gt;&gt; <span class="number">4</span></span><br><span class="line">    c = ~(~<span class="number">0</span>&lt;&lt;<span class="number">4</span>)</span><br><span class="line">    d = b&amp;c</span><br><span class="line">    print(bin(a),d)</span><br></pre></td></tr></table></figure>

<h4 id="实例055：按位取反"><a href="#实例055：按位取反" class="headerlink" title="实例055：按位取反"></a>实例055：按位取反</h4><blockquote>
<p>学习使用按位取反~。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(bin(<span class="number">234</span>))</span><br><span class="line">print((~<span class="number">234</span>))</span><br><span class="line">print(bin(~~<span class="number">234</span>))</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/strive_chuan/article/details/79242010" target="_blank" rel="noopener">关于python中的~（按位取反）运算的理解</a></p>
<h4 id="实例056：画圈"><a href="#实例056：画圈" class="headerlink" title="实例056：画圈"></a>实例056：画圈</h4><p>题目 画图，学用circle画圆形。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line">canvas=Canvas(width=<span class="number">800</span>,height=<span class="number">600</span>,bg=<span class="string">'yellow'</span>)</span><br><span class="line">canvas.pack(expand=YES,fill=BOTH)</span><br><span class="line">k=<span class="number">1</span></span><br><span class="line">j=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">    canvas.create_oval(<span class="number">310</span>-k,<span class="number">250</span>-k,<span class="number">310</span>+k,<span class="number">250</span>+k,width=<span class="number">1</span>)</span><br><span class="line">    k+=j</span><br><span class="line">    j+=<span class="number">0.3</span></span><br><span class="line">mainloop()</span><br></pre></td></tr></table></figure>
<h4 id="todo-tkinter"><a href="#todo-tkinter" class="headerlink" title="todo tkinter"></a>todo tkinter</h4><h4 id="实例057：画线"><a href="#实例057：画线" class="headerlink" title="实例057：画线"></a>实例057：画线</h4><blockquote>
<p>画图，学用line画直线。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">    canvas = Canvas(width=<span class="number">300</span>, height=<span class="number">300</span>, bg=<span class="string">'green'</span>)   </span><br><span class="line">    canvas.pack(expand=YES, fill=BOTH)                  </span><br><span class="line">    x0 = <span class="number">263</span></span><br><span class="line">    y0 = <span class="number">263</span></span><br><span class="line">    y1 = <span class="number">275</span></span><br><span class="line">    x1 = <span class="number">275</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">19</span>):</span><br><span class="line">        canvas.create_line(x0,y0,x0,y1, width=<span class="number">1</span>, fill=<span class="string">'red'</span>)</span><br><span class="line">        x0 = x0 - <span class="number">5</span></span><br><span class="line">        y0 = y0 - <span class="number">5</span></span><br><span class="line">        x1 = x1 + <span class="number">5</span></span><br><span class="line">        y1 = y1 + <span class="number">5</span></span><br><span class="line"> </span><br><span class="line">    x0 = <span class="number">263</span></span><br><span class="line">    y1 = <span class="number">275</span></span><br><span class="line">    y0 = <span class="number">263</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">21</span>):</span><br><span class="line">        canvas.create_line(x0,y0,x0,y1,fill = <span class="string">'red'</span>)</span><br><span class="line">        x0 += <span class="number">5</span></span><br><span class="line">        y0 += <span class="number">5</span></span><br><span class="line">        y1 += <span class="number">5</span></span><br><span class="line"> </span><br><span class="line">    mainloop()</span><br></pre></td></tr></table></figure>

<h4 id="实例058：画矩形"><a href="#实例058：画矩形" class="headerlink" title="实例058：画矩形"></a>实例058：画矩形</h4><p>.画图，学用rectangle画方形。　　　</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line">    root = Tk()</span><br><span class="line">    root.title(<span class="string">'Canvas'</span>)</span><br><span class="line">    canvas = Canvas(root,width = <span class="number">400</span>,height = <span class="number">400</span>,bg = <span class="string">'yellow'</span>)</span><br><span class="line">    x0 = <span class="number">263</span></span><br><span class="line">    y0 = <span class="number">263</span></span><br><span class="line">    y1 = <span class="number">275</span></span><br><span class="line">    x1 = <span class="number">275</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">19</span>):</span><br><span class="line">        canvas.create_rectangle(x0,y0,x1,y1)</span><br><span class="line">        x0 -= <span class="number">5</span></span><br><span class="line">        y0 -= <span class="number">5</span></span><br><span class="line">        x1 += <span class="number">5</span></span><br><span class="line">        y1 += <span class="number">5</span></span><br><span class="line">        </span><br><span class="line">    canvas.pack()</span><br><span class="line">    root.mainloop()</span><br></pre></td></tr></table></figure>

<h4 id="实例059：画图（丑）"><a href="#实例059：画图（丑）" class="headerlink" title="实例059：画图（丑）"></a>实例059：画图（丑）</h4><blockquote>
<p>画图，综合例子。　　</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__  == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line">    canvas = Canvas(width = <span class="number">300</span>,height = <span class="number">300</span>,bg = <span class="string">'green'</span>)</span><br><span class="line">    canvas.pack(expand = YES,fill = BOTH)</span><br><span class="line">    x0 = <span class="number">150</span></span><br><span class="line">    y0 = <span class="number">100</span></span><br><span class="line">    canvas.create_oval(x0 - <span class="number">10</span>,y0 - <span class="number">10</span>,x0 + <span class="number">10</span>,y0 + <span class="number">10</span>)</span><br><span class="line">    canvas.create_oval(x0 - <span class="number">20</span>,y0 - <span class="number">20</span>,x0 + <span class="number">20</span>,y0 + <span class="number">20</span>)</span><br><span class="line">    canvas.create_oval(x0 - <span class="number">50</span>,y0 - <span class="number">50</span>,x0 + <span class="number">50</span>,y0 + <span class="number">50</span>)</span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    B = <span class="number">0.809</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        a = <span class="number">2</span> * math.pi / <span class="number">16</span> * i</span><br><span class="line">        x = math.ceil(x0 + <span class="number">48</span> * math.cos(a))</span><br><span class="line">        y = math.ceil(y0 + <span class="number">48</span> * math.sin(a) * B)</span><br><span class="line">        canvas.create_line(x0,y0,x,y,fill = <span class="string">'red'</span>)</span><br><span class="line">    canvas.create_oval(x0 - <span class="number">60</span>,y0 - <span class="number">60</span>,x0 + <span class="number">60</span>,y0 + <span class="number">60</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">501</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">17</span>):</span><br><span class="line">            a = (<span class="number">2</span> * math.pi / <span class="number">16</span>) * i + (<span class="number">2</span> * math.pi / <span class="number">180</span>) * k</span><br><span class="line">            x = math.ceil(x0 + <span class="number">48</span> * math.cos(a))</span><br><span class="line">            y = math.ceil(y0 + <span class="number">48</span> + math.sin(a) * B)</span><br><span class="line">            canvas.create_line(x0,y0,x,y,fill = <span class="string">'red'</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">51</span>):</span><br><span class="line">            a = (<span class="number">2</span> * math.pi / <span class="number">16</span>) * i + (<span class="number">2</span>* math.pi / <span class="number">180</span>) * k - <span class="number">1</span></span><br><span class="line">            x = math.ceil(x0 + <span class="number">48</span> * math.cos(a))</span><br><span class="line">            y = math.ceil(y0 + <span class="number">48</span> * math.sin(a) * B)</span><br><span class="line">            canvas.create_line(x0,y0,x,y,fill = <span class="string">'red'</span>)</span><br><span class="line">    mainloop()</span><br></pre></td></tr></table></figure>

<h4 id="实例060：字符串长度"><a href="#实例060：字符串长度" class="headerlink" title="实例060：字符串长度"></a>实例060：字符串长度</h4><blockquote>
<p>计算字符串长度。　　</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s=<span class="string">'renlinjie101'</span></span><br><span class="line">print(len(s))</span><br></pre></td></tr></table></figure>

<h4 id="实例061：杨辉三角"><a href="#实例061：杨辉三角" class="headerlink" title="实例061：杨辉三角"></a>实例061：杨辉三角</h4><blockquote>
<p>打印出杨辉三角形前十行。　　</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(numRows)</span>:</span></span><br><span class="line">    r = [[<span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,numRows):</span><br><span class="line">        r.append(list(map(<span class="keyword">lambda</span> x,y:x+y, [<span class="number">0</span>]+r[<span class="number">-1</span>],r[<span class="number">-1</span>]+[<span class="number">0</span>])))</span><br><span class="line">    <span class="keyword">return</span> r[:numRows]</span><br><span class="line">a=generate(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<h4 id="实例062：查找字符串"><a href="#实例062：查找字符串" class="headerlink" title="实例062：查找字符串"></a>实例062：查找字符串</h4><blockquote>
<p>查找字符串。　　</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s1=<span class="string">'aabbxuebixuebi'</span></span><br><span class="line">s2=<span class="string">'ab'</span></span><br><span class="line">s3=<span class="string">'xue'</span></span><br><span class="line">print(s1.find(s2))</span><br><span class="line">print(s1.find(s3))</span><br></pre></td></tr></table></figure>

<h4 id="实例063：画椭圆"><a href="#实例063：画椭圆" class="headerlink" title="实例063：画椭圆"></a>实例063：画椭圆</h4><p>使用 tkinter。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line">    x = <span class="number">360</span></span><br><span class="line">    y = <span class="number">160</span></span><br><span class="line">    top = y - <span class="number">30</span></span><br><span class="line">    bottom = y - <span class="number">30</span></span><br><span class="line">    </span><br><span class="line">    canvas = Canvas(width = <span class="number">400</span>,height = <span class="number">600</span>,bg = <span class="string">'white'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        canvas.create_oval(<span class="number">250</span> - top,<span class="number">250</span> - bottom,<span class="number">250</span> + top,<span class="number">250</span> + bottom)</span><br><span class="line">        top -= <span class="number">5</span></span><br><span class="line">        bottom += <span class="number">5</span></span><br><span class="line">    canvas.pack()</span><br><span class="line">    mainloop()</span><br></pre></td></tr></table></figure>

<h4 id="实例64：画椭圆、矩形"><a href="#实例64：画椭圆、矩形" class="headerlink" title="实例64：画椭圆、矩形"></a>实例64：画椭圆、矩形</h4><p>利用ellipse 和 rectangle 画图。。　</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line">    canvas = Canvas(width = <span class="number">400</span>,height = <span class="number">600</span>,bg = <span class="string">'white'</span>)</span><br><span class="line">    left = <span class="number">20</span></span><br><span class="line">    right = <span class="number">50</span></span><br><span class="line">    top = <span class="number">50</span></span><br><span class="line">    num = <span class="number">15</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        canvas.create_oval(<span class="number">250</span> - right,<span class="number">250</span> - left,<span class="number">250</span> + right,<span class="number">250</span> + left)</span><br><span class="line">        canvas.create_oval(<span class="number">250</span> - <span class="number">20</span>,<span class="number">250</span> - top,<span class="number">250</span> + <span class="number">20</span>,<span class="number">250</span> + top)</span><br><span class="line">        canvas.create_rectangle(<span class="number">20</span> - <span class="number">2</span> * i,<span class="number">20</span> - <span class="number">2</span> * i,<span class="number">10</span> * (i + <span class="number">2</span>),<span class="number">10</span> * ( i + <span class="number">2</span>))</span><br><span class="line">        right += <span class="number">5</span></span><br><span class="line">        left += <span class="number">5</span></span><br><span class="line">        top += <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    canvas.pack()</span><br><span class="line">    mainloop()</span><br></pre></td></tr></table></figure>

<h4 id="实例065：画组合图形"><a href="#实例065：画组合图形" class="headerlink" title="实例065：画组合图形"></a>实例065：画组合图形</h4><p>一个最优美的图案。　　</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PTS</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="number">0</span></span><br><span class="line">        self.y = <span class="number">0</span></span><br><span class="line">points = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LineToDemo</span><span class="params">()</span>:</span></span><br><span class="line">    screenx = <span class="number">400</span></span><br><span class="line">    screeny = <span class="number">400</span></span><br><span class="line">    canvas = Canvas(width = screenx,height = screeny,bg = <span class="string">'white'</span>)</span><br><span class="line"></span><br><span class="line">    AspectRatio = <span class="number">0.85</span></span><br><span class="line">    MAXPTS = <span class="number">15</span></span><br><span class="line">    h = screeny</span><br><span class="line">    w = screenx</span><br><span class="line">    xcenter = w / <span class="number">2</span></span><br><span class="line">    ycenter = h / <span class="number">2</span></span><br><span class="line">    radius = (h - <span class="number">30</span>) / (AspectRatio * <span class="number">2</span>) - <span class="number">20</span></span><br><span class="line">    step = <span class="number">360</span> / MAXPTS</span><br><span class="line">    angle = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(MAXPTS):</span><br><span class="line">        rads = angle * math.pi / <span class="number">180.0</span></span><br><span class="line">        p = PTS()</span><br><span class="line">        p.x = xcenter + int(math.cos(rads) * radius)</span><br><span class="line">        p.y = ycenter - int(math.sin(rads) * radius * AspectRatio)</span><br><span class="line">        angle += step</span><br><span class="line">        points.append(p)</span><br><span class="line">    canvas.create_oval(xcenter - radius,ycenter - radius,</span><br><span class="line">                       xcenter + radius,ycenter + radius)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(MAXPTS):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i,MAXPTS):</span><br><span class="line">            canvas.create_line(points[i].x,points[i].y,points[j].x,points[j].y)</span><br><span class="line"></span><br><span class="line">    canvas.pack()</span><br><span class="line">    mainloop()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    LineToDemo()</span><br></pre></td></tr></table></figure>

<h4 id="实例066：三数排序"><a href="#实例066：三数排序" class="headerlink" title="实例066：三数排序"></a>实例066：三数排序</h4><blockquote>
<p>输入3个数a,b,c，按大小顺序输出。　　　</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">raw=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    x=int(input(<span class="string">'int%d: '</span>%(i)))</span><br><span class="line">    raw.append(x)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(raw)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i,len(raw)):</span><br><span class="line">        <span class="keyword">if</span> raw[i]&gt;raw[j]:</span><br><span class="line">            raw[i],raw[j]=raw[j],raw[i]</span><br><span class="line">print(raw)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">raw2=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    x=int(input(<span class="string">'int%d: '</span>%(i)))</span><br><span class="line">    raw2.append(x)</span><br><span class="line">print(sorted(raw2))</span><br></pre></td></tr></table></figure>

<h4 id="实例067：交换位置"><a href="#实例067：交换位置" class="headerlink" title="实例067：交换位置"></a>实例067：交换位置</h4><blockquote>
<p>输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">li=[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">li[<span class="number">-1</span>],li[li.index(min(li))]=li[li.index(min(li))],li[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">m=li[<span class="number">0</span>]</span><br><span class="line">ind=li.index(max(li))</span><br><span class="line">li[<span class="number">0</span>]=li[ind]</span><br><span class="line">li[ind]=m</span><br><span class="line"></span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>

<h4 id="实例068：旋转数列"><a href="#实例068：旋转数列" class="headerlink" title="实例068：旋转数列"></a>实例068：旋转数列</h4><blockquote>
<p>有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数</p>
</blockquote>
<p>使用了<a href>collections模块</a> </p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> *</span><br><span class="line">li=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">deq=deque(li,maxlen=len(li))</span><br><span class="line">print(li)</span><br><span class="line">deq.rotate(int(input(<span class="string">'rotate:'</span>)))</span><br><span class="line">print(list(deq))</span><br></pre></td></tr></table></figure>

<h4 id="实例069：报数"><a href="#实例069：报数" class="headerlink" title="实例069：报数"></a>实例069：报数</h4><blockquote>
<p>有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nmax = <span class="number">50</span></span><br><span class="line">    n = int(input(<span class="string">'请输入总人数:'</span>))</span><br><span class="line">    num = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        num.append(i + <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> m &lt; n - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> num[i] != <span class="number">0</span> : k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">3</span>:</span><br><span class="line">            num[i] = <span class="number">0</span></span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            m += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == n : i = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> num[i] == <span class="number">0</span>: i += <span class="number">1</span></span><br><span class="line">    print(num[i])</span><br></pre></td></tr></table></figure>


<h4 id="实例070：字符串长度II"><a href="#实例070：字符串长度II" class="headerlink" title="实例070：字符串长度II"></a>实例070：字符串长度II</h4><blockquote>
<p>写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lenofstr</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(s)</span><br><span class="line"></span><br><span class="line">print(lenofstr(<span class="string">'tanxiaofengsheng'</span>))</span><br></pre></td></tr></table></figure>

<h4 id="实例071：输入和输出"><a href="#实例071：输入和输出" class="headerlink" title="实例071：输入和输出"></a>实例071：输入和输出</h4><blockquote>
<p>编写input()和output()函数输入，输出5个学生的数据记录。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">N = <span class="number">3</span></span><br><span class="line"><span class="comment">#stu</span></span><br><span class="line"><span class="comment"># num : string</span></span><br><span class="line"><span class="comment"># name : string</span></span><br><span class="line"><span class="comment"># score[4]: list</span></span><br><span class="line">student = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    student.append([<span class="string">''</span>,<span class="string">''</span>,[]])</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_stu</span><span class="params">(stu)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        stu[i][<span class="number">0</span>] = input(<span class="string">'input student num:\n'</span>)</span><br><span class="line">        stu[i][<span class="number">1</span>] = input(<span class="string">'input student name:\n'</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            stu[i][<span class="number">2</span>].append(int(input(<span class="string">'score:\n'</span>)))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">output_stu</span><span class="params">(stu)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'%-6s%-10s'</span> % ( stu[i][<span class="number">0</span>],stu[i][<span class="number">1</span>] ))</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'%-8d'</span> % stu[i][<span class="number">2</span>][j])</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    input_stu(student)</span><br><span class="line">    <span class="keyword">print</span> (student)</span><br><span class="line">    output_stu(student)</span><br></pre></td></tr></table></figure>

<h4 id="实例072：创建链表"><a href="#实例072：创建链表" class="headerlink" title="实例072：创建链表"></a>实例072：创建链表</h4><blockquote>
<p>创建一个链表。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.data</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        self.head = head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> self.get_len() == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_len</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        temp = self.head</span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            temp = temp.next</span><br><span class="line">        <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        temp = self.head</span><br><span class="line">        <span class="keyword">while</span> temp.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            temp = temp.next</span><br><span class="line">        temp.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, index)</span>:</span> </span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">1</span> <span class="keyword">or</span> index &gt; self.get_len():</span><br><span class="line">            print(<span class="string">"给定位置不合理"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">1</span>:</span><br><span class="line">            self.head = self.head.next</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        temp = self.head</span><br><span class="line">        cur_pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cur_pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur_pos == index<span class="number">-1</span>:</span><br><span class="line">                temp.next = temp.next.next</span><br><span class="line">            temp = temp.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">1</span> <span class="keyword">or</span> pos &gt; self.get_len():</span><br><span class="line">            print(<span class="string">"插入结点位置不合理"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        temp = self.head</span><br><span class="line">        cur_pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> Node:</span><br><span class="line">            cur_pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur_pos == pos<span class="number">-1</span>:</span><br><span class="line">                node.next = temp.next</span><br><span class="line">                temp.next =node</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            temp = temp.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        pre = head</span><br><span class="line">        cur = head.next</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            temp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = temp</span><br><span class="line">        head.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_list</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        init_data = []</span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            init_data.append(head.get_data())</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> init_data</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    head=Node(<span class="string">'head'</span>)</span><br><span class="line">    link=List(head)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        node=Node(i)</span><br><span class="line">        link.append(node)</span><br><span class="line">    print(link.print_list(head))</span><br></pre></td></tr></table></figure>

<h4 id="实例073：反向输出链表"><a href="#实例073：反向输出链表" class="headerlink" title="实例073：反向输出链表"></a>实例073：反向输出链表</h4><blockquote>
<p>反向输出一个链表。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.data</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        self.head = head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> self.get_len() == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_len</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        temp = self.head</span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            temp = temp.next</span><br><span class="line">        <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        temp = self.head</span><br><span class="line">        <span class="keyword">while</span> temp.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            temp = temp.next</span><br><span class="line">        temp.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, index)</span>:</span> </span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">1</span> <span class="keyword">or</span> index &gt; self.get_len():</span><br><span class="line">            print(<span class="string">"给定位置不合理"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">1</span>:</span><br><span class="line">            self.head = self.head.next</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        temp = self.head</span><br><span class="line">        cur_pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cur_pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur_pos == index<span class="number">-1</span>:</span><br><span class="line">                temp.next = temp.next.next</span><br><span class="line">            temp = temp.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">1</span> <span class="keyword">or</span> pos &gt; self.get_len():</span><br><span class="line">            print(<span class="string">"插入结点位置不合理"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        temp = self.head</span><br><span class="line">        cur_pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> Node:</span><br><span class="line">            cur_pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur_pos == pos<span class="number">-1</span>:</span><br><span class="line">                node.next = temp.next</span><br><span class="line">                temp.next =node</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            temp = temp.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        pre = head</span><br><span class="line">        cur = head.next</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            temp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = temp</span><br><span class="line">        head.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_list</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        init_data = []</span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            init_data.append(head.get_data())</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> init_data</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    head=Node(<span class="string">'head'</span>)</span><br><span class="line">    link=List(head)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        node=Node(i)</span><br><span class="line">        link.append(node)</span><br><span class="line">    print(link.print_list(head))</span><br><span class="line">    print(link.print_list(link.reverse(head)))</span><br></pre></td></tr></table></figure>

<h4 id="实例074：列表排序、连接"><a href="#实例074：列表排序、连接" class="headerlink" title="实例074：列表排序、连接"></a>实例074：列表排序、连接</h4><blockquote>
<p>列表排序及连接。</p>
</blockquote>
<p><strong>程序分析：</strong>排序可使用 sort() 方法，连接可以使用 <code>+</code>号或 <code>extend()</code>方法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line">b=[<span class="number">7</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">a.extend(b)</span><br><span class="line">a.sort()</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<h4 id="实例075：不知所云"><a href="#实例075：不知所云" class="headerlink" title="实例075：不知所云"></a>实例075：不知所云</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">1</span>: n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">3</span>: n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">4</span>: n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">4</span>: n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">3</span>: <span class="keyword">print</span> (<span class="number">64</span> + i)</span><br></pre></td></tr></table></figure>

<h4 id="实例076：做函数"><a href="#实例076：做函数" class="headerlink" title="实例076：做函数"></a>实例076：做函数</h4><blockquote>
<p>编写一个函数，输入n为偶数时，调用函数求1/2+1/4+…+1/n,当输入n为奇数时，调用函数1/1+1/3+…+1/n</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">peven</span><span class="params">(n)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    s = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        s += <span class="number">1.0</span> / i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">podd</span><span class="params">(n)</span>:</span></span><br><span class="line">    s = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        s += <span class="number">1.0</span> / i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dcall</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        s = peven(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        s = podd(n)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = int(input(<span class="string">'input a number: '</span>))</span><br><span class="line">    sum = dcall(n)</span><br><span class="line">    print(sum)</span><br></pre></td></tr></table></figure>

<h4 id="实例077：循环遍历列表"><a href="#实例077：循环遍历列表" class="headerlink" title="实例077：循环遍历列表"></a>实例077：循环遍历列表</h4><blockquote>
<p>循环输出列表</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> cycle</span><br><span class="line">l=[<span class="string">'moyu'</span>,<span class="string">'niupi'</span>,<span class="string">'xuecaibichi'</span>,<span class="string">'shengfaji'</span>,<span class="string">'42'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cycle(l):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<h4 id="实例078：字典"><a href="#实例078：字典" class="headerlink" title="实例078：字典"></a>实例078：字典</h4><blockquote>
<p>找到年龄最大的人，并输出。请找出程序中有什么问题。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    person = &#123;<span class="string">"li"</span>:<span class="number">18</span>,<span class="string">"wang"</span>:<span class="number">50</span>,<span class="string">"zhang"</span>:<span class="number">20</span>,<span class="string">"sun"</span>:<span class="number">22</span>&#125;</span><br><span class="line">    m = <span class="string">'li'</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> person.keys():</span><br><span class="line">        <span class="keyword">if</span> person[m] &lt; person[key]:</span><br><span class="line">            m = key</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'%s,%d'</span> % (m,person[m]))</span><br></pre></td></tr></table></figure>

<h4 id="实例079：字符串排序"><a href="#实例079：字符串排序" class="headerlink" title="实例079：字符串排序"></a>实例079：字符串排序</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">l=[<span class="string">'baaa'</span>,<span class="string">'aaab'</span>,<span class="string">'aaba'</span>,<span class="string">'aaaa'</span>,<span class="string">'abaa'</span>]</span><br><span class="line">l.sort()</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure>

<h4 id="实例080：猴子分桃"><a href="#实例080：猴子分桃" class="headerlink" title="实例080：猴子分桃"></a>实例080：猴子分桃</h4><blockquote>
<p>海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子平均分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (m &lt; <span class="number">5</span>) :</span><br><span class="line">        x = <span class="number">4</span> * j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>) :</span><br><span class="line">            <span class="keyword">if</span>(x%<span class="number">4</span> != <span class="number">0</span>) :</span><br><span class="line">                m=<span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                m += <span class="number">1</span></span><br><span class="line">            x = (x/<span class="number">4</span>) * <span class="number">5</span> +<span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        x=(x<span class="number">-1</span>)/<span class="number">5</span>*<span class="number">4</span></span><br><span class="line">        print(x)</span><br></pre></td></tr></table></figure>

<h4 id="实例081：求未知数"><a href="#实例081：求未知数" class="headerlink" title="实例081：求未知数"></a>实例081：求未知数</h4><blockquote>
<p><code>809*??=800*??+9*??</code> 其中??代表的两位数, 809<em>??为四位数，8</em>??的结果为两位数，9<em>??的结果为3位数。求??代表的两位数，及809</em>??后的结果。</p>
</blockquote>
<p>什么垃圾题???</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">809</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>,<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="number">8</span>*i&gt;<span class="number">99</span> <span class="keyword">or</span> <span class="number">9</span>*i&lt;<span class="number">100</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(i)</span><br><span class="line">    print(a*i)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>


<h4 id="实例082：八进制转十进制"><a href="#实例082：八进制转十进制" class="headerlink" title="实例082：八进制转十进制"></a>实例082：八进制转十进制</h4><blockquote>
<p>八进制转换为十进制</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">n=eval(<span class="string">'0o'</span>+str(int(input(<span class="string">'八进制输入：'</span>))))</span><br><span class="line">print(n)</span><br><span class="line"><span class="comment">#十转⑧</span></span><br><span class="line">n = oct(int(input(<span class="string">'⑩进制输入：'</span>)))</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure>

<h4 id="实例083：制作奇数"><a href="#实例083：制作奇数" class="headerlink" title="实例083：制作奇数"></a>实例083：制作奇数</h4><blockquote>
<p>求0—7所能组成的奇数个数。(排列组合)</p>
</blockquote>
<p>组成1位数是<code>4</code>个。1,3,5,7结尾</p>
<p>组成2位数是<code>7*4</code>个。第一位不能为0</p>
<p>组成3位数是<code>7*8*4</code>个。中间随意</p>
<p>组成4位数是<code>7*8*8*4</code>个。<br>itertools模块类有组合的函数,感兴趣可以自己去了解</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sum = <span class="number">4</span></span><br><span class="line">    s = <span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">print</span> (sum)</span><br><span class="line">        <span class="keyword">if</span> j &lt;= <span class="number">2</span>:</span><br><span class="line">            s *= <span class="number">7</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s *= <span class="number">8</span></span><br><span class="line">        sum += s</span><br><span class="line">    print(<span class="string">'sum = %d'</span> % sum)</span><br></pre></td></tr></table></figure>

<h4 id="实例084：连接字符串"><a href="#实例084：连接字符串" class="headerlink" title="实例084：连接字符串"></a>实例084：连接字符串</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">delimiter = <span class="string">','</span></span><br><span class="line">mylist = [<span class="string">'Brazil'</span>, <span class="string">'Russia'</span>, <span class="string">'India'</span>, <span class="string">'China'</span>]</span><br><span class="line">print(delimiter.join(mylist))</span><br></pre></td></tr></table></figure>

<h4 id="实例085：整除"><a href="#实例085：整除" class="headerlink" title="实例085：整除"></a>实例085：整除</h4><blockquote>
<p>输入一个奇数，然后判断最少几个 9 除于该数的结果为整数。</p>
</blockquote>
<p><strong>程序分析：</strong> 999999 / 13 = 76923。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    zi = int(input(<span class="string">'输入一个数字:'</span>))</span><br><span class="line">    n1 = <span class="number">1</span></span><br><span class="line">    c9 = <span class="number">1</span></span><br><span class="line">    m9 = <span class="number">9</span></span><br><span class="line">    sum = <span class="number">9</span></span><br><span class="line">    <span class="keyword">while</span> sum % zi != <span class="number">0</span>:</span><br><span class="line">        m9 *= <span class="number">10</span></span><br><span class="line">        sum += m9</span><br><span class="line">        c9 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'%d 个 9 可以被 %d 整除 : %d'</span> % (c9, zi, sum))</span><br><span class="line">        r = sum / zi</span><br><span class="line">        print(<span class="string">'%d / %d = %d'</span> % (sum, zi, r))</span><br></pre></td></tr></table></figure>

<h4 id="实例086：连接字符串II"><a href="#实例086：连接字符串II" class="headerlink" title="实例086：连接字符串II"></a>实例086：连接字符串II</h4><blockquote>
<p>两个字符串连接程序。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=<span class="string">'rlj'</span></span><br><span class="line">b=<span class="string">'love '</span></span><br><span class="line">print(b+a)</span><br></pre></td></tr></table></figure>

<h4 id="实例087：访问类成员"><a href="#实例087：访问类成员" class="headerlink" title="实例087：访问类成员"></a>实例087：访问类成员</h4><blockquote>
<p>回答结果（结构体变量传递）。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">student</span>:</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(stu)</span>:</span></span><br><span class="line">        stu.x = <span class="number">20</span></span><br><span class="line">        stu.c = <span class="string">'c'</span></span><br><span class="line">    a= student()</span><br><span class="line">    a.x = <span class="number">3</span></span><br><span class="line">    a.c = <span class="string">'a'</span></span><br><span class="line">    f(a)</span><br><span class="line">    print(a.x,a.c)</span><br></pre></td></tr></table></figure>

<h4 id="实例088：打印星号"><a href="#实例088：打印星号" class="headerlink" title="实例088：打印星号"></a>实例088：打印星号</h4><blockquote>
<p>a读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的＊。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    print(<span class="string">'*'</span>*int(input(<span class="string">'input a number: '</span>)))</span><br></pre></td></tr></table></figure>

<h4 id="实例089：解码"><a href="#实例089：解码" class="headerlink" title="实例089：解码"></a>实例089：解码</h4><blockquote>
<p>某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5,然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">n=input()</span><br><span class="line">n = str(n)</span><br><span class="line">a=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    a.append((int(n[i])+<span class="number">5</span>)%<span class="number">10</span>)</span><br><span class="line">a[<span class="number">0</span>],a[<span class="number">3</span>]=a[<span class="number">3</span>],a[<span class="number">0</span>]</span><br><span class="line">a[<span class="number">1</span>],a[<span class="number">2</span>]=a[<span class="number">2</span>],a[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> (<span class="string">""</span>.join(<span class="string">'%s'</span> %s <span class="keyword">for</span> s <span class="keyword">in</span> a))</span><br></pre></td></tr></table></figure>


<h4 id="实例090：列表详解"><a href="#实例090：列表详解" class="headerlink" title="实例090：列表详解"></a>实例090：列表详解</h4><blockquote>
<p>列表使用实例</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list_1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">list_2 = [<span class="string">'hello'</span>,<span class="string">'world'</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="literal">True</span>,<span class="literal">False</span>]</span><br><span class="line">list_3 = (range(<span class="number">10</span>,<span class="number">20</span>,<span class="number">2</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_1</span><span class="params">(list_1)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list_1:</span><br><span class="line">        print(item)</span><br><span class="line"><span class="comment"># 2 使用for循环和 enumerate()函数实现</span></span><br><span class="line"><span class="keyword">for</span> index,item <span class="keyword">in</span> enumerate(list_2):</span><br><span class="line">    print(str(index+<span class="number">1</span>)+<span class="string">','</span>+str(item))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">list_1.append(<span class="number">7</span>)</span><br><span class="line">list_1.extend(list_2)</span><br><span class="line"><span class="comment"># list_1.insert() #可在指定位置插入元素,但是效率没有append高</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改元素</span></span><br><span class="line"></span><br><span class="line">list_1[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除元素</span></span><br><span class="line"><span class="keyword">del</span> list_1[<span class="number">-1</span>] <span class="comment"># 删除最后一个</span></span><br><span class="line">list_1.remove(<span class="number">5</span>) <span class="comment">#如果删除的元素不存在 则会抛出异常</span></span><br><span class="line"></span><br><span class="line">list_1.count(<span class="number">1</span>) <span class="comment">#判断元素值为1的个数</span></span><br><span class="line">list_2.index(<span class="string">'hello'</span>) <span class="comment"># 获取指定元素首次出现的下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sum(iterable[,start]) 统计数值列表的元素和</span></span><br><span class="line">sum_1 = sum(list_3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对列表进行排序</span></span><br><span class="line"><span class="comment"># 列表对象的sort()</span></span><br><span class="line"><span class="comment"># listname.sort(key = None,reverse = False)</span></span><br><span class="line"><span class="comment"># 升序或者降序 可通过调节 reverse 的值</span></span><br><span class="line">grade = [<span class="number">98</span>,<span class="number">99</span>,<span class="number">97</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">96</span>,<span class="number">22</span>,<span class="number">88</span>,<span class="number">94</span>,<span class="number">92</span>]</span><br><span class="line">grade.sort()</span><br><span class="line">print(<span class="string">"升序:"</span>,grade)</span><br><span class="line">grade.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">print(<span class="string">"降序:"</span>,grade)</span><br><span class="line"><span class="comment"># 内置的sorted()函数</span></span><br><span class="line"><span class="comment"># sorted(iterable,key=None,reverse=False)</span></span><br><span class="line">grade_as = sorted(grade)</span><br><span class="line">grade_des = sorted(grade,reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h4 id="实例091：time模块"><a href="#实例091：time模块" class="headerlink" title="实例091：time模块"></a>实例091：time模块</h4><blockquote>
<p>时间函数举例1。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    <span class="keyword">print</span> (time.ctime(time.time()))</span><br><span class="line">    <span class="keyword">print</span> (time.asctime(time.localtime(time.time())))</span><br><span class="line">    <span class="keyword">print</span> (time.asctime(time.gmtime(time.time())))</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/itanders/article/details/88720573" target="_blank" rel="noopener">python time模块</a></p>
<h4 id="实例092：time模块II"><a href="#实例092：time模块II" class="headerlink" title="实例092：time模块II"></a>实例092：time模块II</h4><blockquote>
<p>时间函数举例</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3000</span>):</span><br><span class="line">        print(i)</span><br><span class="line">    end = time.time()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> (end - start)</span><br></pre></td></tr></table></figure>
<h4 id="实例093-time模块Ⅲ"><a href="#实例093-time模块Ⅲ" class="headerlink" title="实例093: time模块Ⅲ"></a>实例093: time模块Ⅲ</h4><blockquote>
<p>疑惑???</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    start = time.clock()</span><br><span class="line">    <span class="keyword">print</span> (start)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3000</span>):</span><br><span class="line">       print(i)</span><br><span class="line">    end = time.clock()</span><br><span class="line">    <span class="keyword">print</span> (end)</span><br><span class="line">    print(<span class="string">'different is %6.3f'</span> % (end - start))</span><br></pre></td></tr></table></figure>
<h4 id="实例094-time模块IV"><a href="#实例094-time模块IV" class="headerlink" title="实例094:time模块IV"></a>实例094:time模块IV</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    </span><br><span class="line">    play_it = input(<span class="string">'do you want to play it.(\'y\' or \'n\')'</span>)</span><br><span class="line">    <span class="keyword">while</span> play_it == <span class="string">'y'</span>:</span><br><span class="line">        c = input(<span class="string">'input a character:\n'</span>)</span><br><span class="line">        i = random.randint(<span class="number">0</span>,<span class="number">2</span>**<span class="number">32</span>) % <span class="number">100</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'please input number you guess:\n'</span>)</span><br><span class="line">        start = time.clock()</span><br><span class="line">        a = time.time()</span><br><span class="line">        guess = int(input(<span class="string">'input your guess:\n'</span>))</span><br><span class="line">        <span class="keyword">while</span> guess != i:</span><br><span class="line">            <span class="keyword">if</span> guess &gt; i:</span><br><span class="line">                print(<span class="string">'please input a little smaller'</span>)</span><br><span class="line">                guess = int(input(<span class="string">'input your guess:\n'</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'please input a little bigger'</span>)</span><br><span class="line">                guess = int(input(<span class="string">'input your guess:\n'</span>))</span><br><span class="line">        end = time.clock()</span><br><span class="line">        b = time.time()</span><br><span class="line">        var = (end - start) / <span class="number">18.2</span></span><br><span class="line">        <span class="keyword">print</span> (var)</span><br><span class="line">        <span class="comment"># print 'It took you %6.3 seconds' % time.difftime(b,a))</span></span><br><span class="line">        <span class="keyword">if</span> var &lt; <span class="number">15</span>:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'you are very clever!'</span>)</span><br><span class="line">        <span class="keyword">elif</span> var &lt; <span class="number">25</span>:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'you are normal!'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'you are stupid!'</span>)</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'Congradulations'</span>)</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'The number you guess is %d'</span> % i)</span><br><span class="line">        play_it = input(<span class="string">'do you want to play it. y or n?'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="实例095：转换时间格式"><a href="#实例095：转换时间格式" class="headerlink" title="实例095：转换时间格式"></a>实例095：转换时间格式</h4><blockquote>
<p>字符串日期转换为易读的日期格式。</p>
</blockquote>
<p>程序分析 看看就得了，dateutil是个第三方库。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dateutil <span class="keyword">import</span> parser</span><br><span class="line">dt = parser.parse(<span class="string">"Aug 28 2015 12:00AM"</span>)</span><br><span class="line"><span class="keyword">print</span> (dt)</span><br></pre></td></tr></table></figure>
<h4 id="实例096：计算复读次数"><a href="#实例096：计算复读次数" class="headerlink" title="实例096：计算复读次数"></a>实例096：计算复读次数</h4><blockquote>
<p>计算字符串中子串出现的次数。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s1 = <span class="string">'rljrljrljrljlove'</span></span><br><span class="line">s2 = <span class="string">'rlj'</span></span><br><span class="line">print(s1.count(s2))</span><br></pre></td></tr></table></figure>
<h4 id="实例097：磁盘写入"><a href="#实例097：磁盘写入" class="headerlink" title="实例097：磁盘写入"></a>实例097：磁盘写入</h4><blockquote>
<p>从键盘输入一些字符，逐个把它们写到磁盘文件上，直到输入一个 # 为止。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> stdout</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    filename = input(<span class="string">'输入文件名:\n'</span>)</span><br><span class="line">    fp = open(filename, <span class="string">"w"</span>)</span><br><span class="line">    ch = input(<span class="string">'输入字符串:\n'</span>)</span><br><span class="line">    <span class="keyword">while</span> ch != <span class="string">'#'</span>:</span><br><span class="line">        fp.write(ch)</span><br><span class="line">        stdout.write(ch)</span><br><span class="line">        ch = input(<span class="string">''</span>)</span><br><span class="line">    fp.close()</span><br></pre></td></tr></table></figure>
<h4 id="实例098：磁盘写入Ⅱ"><a href="#实例098：磁盘写入Ⅱ" class="headerlink" title="实例098：磁盘写入Ⅱ"></a>实例098：磁盘写入Ⅱ</h4><blockquote>
<p>从键盘输入一个字符串，将小写字母全部转换成大写字母，然后输出到一个磁盘文件”test”中保存。</p>
</blockquote>
<p>使用with…as..更简洁</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'./test.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        string = input(<span class="string">'please input a string:\n'</span>)</span><br><span class="line">        string = string.upper()</span><br><span class="line">        f.write(string)</span><br><span class="line">    <span class="keyword">with</span> open (<span class="string">'./test.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f2:</span><br><span class="line">        print(f2.read())</span><br></pre></td></tr></table></figure>
<h4 id="实例099：磁盘读写"><a href="#实例099：磁盘读写" class="headerlink" title="实例099：磁盘读写"></a>实例099：磁盘读写</h4><blockquote>
<p>有两个磁盘文件A和B,各存放一行字母,要求把这两个文件中的信息合并(按字母顺序排列), 输出到一个新文件C中。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'test1.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f1:</span><br><span class="line">        str1=f1.read()</span><br><span class="line">    <span class="keyword">with</span> open (<span class="string">'test2.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f2:</span><br><span class="line">        str2=f2.read()</span><br><span class="line">    <span class="keyword">with</span> open (<span class="string">'test3.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f3:</span><br><span class="line">        l = list(str1+str2)</span><br><span class="line">        l.sort()</span><br><span class="line">        s = <span class="string">''</span></span><br><span class="line">        s = s.join(l)</span><br><span class="line">        f3.write(s)</span><br></pre></td></tr></table></figure>
<h4 id="实例100-列表转字典"><a href="#实例100-列表转字典" class="headerlink" title="实例100:列表转字典"></a>实例100:列表转字典</h4><p>列表转换为字典。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i = [<span class="string">'A'</span>,<span class="string">'B'</span>]</span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="comment"># i = ['A','B','A']</span></span><br><span class="line"><span class="comment"># l=[1,2,3]</span></span><br><span class="line"><span class="keyword">print</span> (dict(zip(i,l)))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>123</category>
      </categories>
      <tags>
        <tag>123</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode支持的markdown语法参考</title>
    <url>/2020/01/02/VsCode%E6%94%AF%E6%8C%81%E7%9A%84markdown%E8%AF%AD%E6%B3%95%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<div align="center" style="color:red">VS Code 使用 Markdown 编写文档</div>

<h2 id="1-文本部分"><a href="#1-文本部分" class="headerlink" title="1. 文本部分"></a>1. 文本部分</h2><a id="more"></a>
<h3 id="1-1-斜体和粗体，删除线"><a href="#1-1-斜体和粗体，删除线" class="headerlink" title="1.1 斜体和粗体，删除线"></a>1.1 斜体和粗体，删除线</h3><p>使用 * 和 ** 表示斜体和粗体。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">示例：这是<span class="strong">*斜体*</span>，这是*<span class="strong">*粗体*</span><span class="strong">*。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这是<em>斜体</em>，这是<strong>粗体</strong>。<br>使用 ~~ 表示删除线。<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">~~这是一段错误的文本。</span><br></pre></td></tr></table></figure></li>
<li><del>这是一段错误的文本。</del></li>
</ul>
<h3 id="1-2-分级标题"><a href="#1-2-分级标题" class="headerlink" title="1.2 分级标题"></a>1.2 分级标题</h3><p>使用 === 表示一级标题，使用 — 表示二级标题。<br><img src="https://upload-images.jianshu.io/upload_images/1414656-4697bde7bd330473.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/654/format/webp" alt><br>你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。<br><img src="https://upload-images.jianshu.io/upload_images/1414656-4e1275ac4a64ba20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/527/format/webp" alt></p>
<h3 id="1-3-常用-Emoji-amp-Font-Awesome"><a href="#1-3-常用-Emoji-amp-Font-Awesome" class="headerlink" title="1.3 常用 Emoji &amp; Font-Awesome"></a>1.3 常用 Emoji &amp; Font-Awesome</h3><p><img src="https://img2018.cnblogs.com/blog/1683299/201909/1683299-20190911231431885-470598308.png" alt><br><img src="https://upload-images.jianshu.io/upload_images/1414656-b1f92b959dfa863e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/301/format/webp" alt><br><a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">更多emoji查看</a></p>
<h3 id="1-4-引用和注脚"><a href="#1-4-引用和注脚" class="headerlink" title="1.4 引用和注脚"></a>1.4 引用和注脚</h3><p>使用 [^keyword] 表示注脚。</p>
<h2 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>上标：30^th^</span><br><span class="line"><span class="bullet">- </span>下标：H~2~O</span><br><span class="line"><span class="bullet">- </span>脚注：Content [^1]</span><br><span class="line">[<span class="symbol">^1</span>]:<span class="link">Hi 这里是一个注脚，会自动拉到最后面排版</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上标：30^th^</li>
<li>下标：H<del>2</del>O</li>
<li>脚注：Content [^1]<br>[^1]:Hi 这里是一个注脚，会自动拉到最后面排版</li>
</ul>
<h2 id="缩略："><a href="#缩略：" class="headerlink" title="缩略："></a>缩略：</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">*[HTML]: 超文本标记语言</span><br><span class="line">*[W3C]:  World Wide Web Consortium</span><br><span class="line">The HTML specification</span><br><span class="line">is maintained by the W3C.</span><br></pre></td></tr></table></figure>
<p>*[HTML]: 超文本标记语言<br>*[W3C]:  World Wide Web Consortium<br>The HTML specification<br>is maintained by the W3C.</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">这里要有空格隔开中文</span><br><span class="line">*<span class="string">[月]</span>: yue4</span><br><span class="line">*<span class="string">[辍]</span>: chuo4</span><br><span class="line">明 明 如 月，何 时 可 辍</span><br></pre></td></tr></table></figure>
<p>*[月]: yue4<br>*[辍]: chuo4<br>明 明 如 月，何 时 可 辍</p>
<h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">==<span class="attribute">marked</span>==</span><br></pre></td></tr></table></figure>

<p>==marked==</p>
<h3 id="1-5-外链接"><a href="#1-5-外链接" class="headerlink" title="1.5 外链接"></a>1.5 外链接</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">关键词</span>](<span class="link">链接地址 "（可选）添加一个标题"</span>)</span><br><span class="line">图片带链接 </span><br><span class="line"><span class="code">    [![](.//img/01.png '百度')](http://www.baidu.com)</span></span><br></pre></td></tr></table></figure>
<p>这里是去 <a href="http://www.baidu.com/" target="_blank" rel="noopener" title="百度一下">百度</a> 的链接</p>
<p><a href="https://user.qzone.qq.com/1535045887/" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1683299/201909/1683299-20190911232801569-1228742801.jpg" alt title="本人QQ:1535045887"></a></p>
<h3 id="1-6文字引用"><a href="#1-6文字引用" class="headerlink" title="1.6文字引用"></a>1.6文字引用</h3><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">&gt;                   <span class="keyword">Only</span> <span class="keyword">action</span> can relieve the uneasiness.</span><br></pre></td></tr></table></figure>
<blockquote>
<pre><code>Only action can relieve the uneasiness.</code></pre></blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">多层嵌套</span><br><span class="line">&gt;天大彭于晏</span><br><span class="line"><span class="meta">&gt;&gt;</span>天大彭于晏</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;天大彭于晏</span><br></pre></td></tr></table></figure>
<blockquote>
<p>天大彭于晏</p>
<blockquote>
<p>天大彭于晏</p>
<blockquote>
<p>天大彭于晏</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="1-7-内容目录"><a href="#1-7-内容目录" class="headerlink" title="1.7 内容目录"></a>1.7 内容目录</h3><p>在段落中填写 [TOC] 以显示全文内容的目录结构。</p>
<blockquote>
<p>[TOC]</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/1414656-4558e18cf543a874.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/376/format/webp" alt></p>
<h3 id="1-8行内标记"><a href="#1-8行内标记" class="headerlink" title="1.8行内标记"></a>1.8行内标记</h3><p>注：用 ` 标记代码块将变成一行<br>代码</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">标记之外`hello </span><br><span class="line">world`标记之外</span><br></pre></td></tr></table></figure>
<p>标记之外<code>hello 
world</code>标记之外</p>
<h3 id="1-9支持内嵌CSS样式"><a href="#1-9支持内嵌CSS样式" class="headerlink" title="1.9支持内嵌CSS样式"></a>1.9支持内嵌CSS样式</h3><p>代码:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: #AD5D0F;font-size: 30px; font-family: '宋体';"</span>&gt;</span>内联样式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p style="color: #AD5D0F;font-size: 30px; font-family: '宋体';">内联样式</p>

<h3 id="1-10-支持html标签"><a href="#1-10-支持html标签" class="headerlink" title="1.10 支持html标签"></a>1.10 支持html标签</h3><p>直接使用 HTML 标签，可以设置文字居中，字体颜色等样色(HTML 语法)<br>代码:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="meta">align</span>=<span class="string">"center"</span> style=<span class="string">"color:red"</span>&gt;VS <span class="meta">Code</span> 使用 <span class="keyword">Markdown </span>编写文档&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>演示:<br>        <div align="center" style="color:red">VS Code 使用 Markdown 编写文档</div></p>
<h2 id="2-标签分类"><a href="#2-标签分类" class="headerlink" title="2. 标签分类"></a>2. 标签分类</h2><p>在编辑区任意行的列首位置输入以下代码给文稿标签：</p>
<p>标签： 数学 英语 Markdown<br>Tags： 数学 英语 Markdown</p>
<h3 id="2-0-常用布局"><a href="#2-0-常用布局" class="headerlink" title="2.0 常用布局"></a>2.0 常用布局</h3><h3 id="2-1-无序列表"><a href="#2-1-无序列表" class="headerlink" title="2.1 无序列表"></a>2.1 无序列表</h3><p>使用 *，+，- 表示无序列表。</p>
<p>示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>无序列表项 一</span><br><span class="line"><span class="bullet">* </span>无序列表项 二</span><br><span class="line"><span class="bullet">+ </span>无序列表项 三</span><br></pre></td></tr></table></figure>
<p>效果:</p>
<ul>
<li>无序列表项 一</li>
</ul>
<ul>
<li>无序列表项 二</li>
</ul>
<ul>
<li>无序列表项 三<h3 id="2-2-有序列表（ol-li）"><a href="#2-2-有序列表（ol-li）" class="headerlink" title="2.2 有序列表（ol-li）"></a>2.2 有序列表（ol-li）</h3>使用数字和点表示有序列表。<br>示例：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表项 一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表项 二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表项 三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">注：序列.后 保持空格</span><br><span class="line"><span class="number">1.</span> one</span><br><span class="line"><span class="number">2.</span> two</span><br><span class="line"><span class="number">3.</span> three</span><br></pre></td></tr></table></figure>
演示:</li>
</ul>
<ol>
<li>one</li>
<li>two</li>
<li>three</li>
</ol>
<h3 id="2-3-行内代码块"><a href="#2-3-行内代码块" class="headerlink" title="2.3 行内代码块"></a>2.3 行内代码块</h3><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">用 ```代码```进行包裹</span><br></pre></td></tr></table></figure>
<h3 id="2-4-插入图像"><a href="#2-4-插入图像" class="headerlink" title="2.4 插入图像"></a>2.4 插入图像</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">使用 !<span class="selector-attr">[]</span>(图片链接地址<span class="string">'描述'</span>) 插入图像。</span><br></pre></td></tr></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/1683299/201909/1683299-20190911233054628-1216522735.jpg" alt title="我是一名程序员"></p>
<h3 id="2-5-表格支持"><a href="#2-5-表格支持" class="headerlink" title="2.5 表格支持"></a>2.5 表格支持</h3><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">|<span class="string"> 项目        </span>|<span class="string"> 价格   </span>|<span class="string">  数量  </span>|</span><br><span class="line">|<span class="string"> --------   </span>|<span class="string"> -----:  </span>|<span class="string"> :----:  </span>|</span><br><span class="line">|<span class="string"> 计算机     </span>|<span class="string"> \$1600 </span>|<span class="string">   5     </span>|</span><br><span class="line">|<span class="string"> 手机        </span>|<span class="string">   \$12   </span>|<span class="string">   12   </span>|</span><br><span class="line">|<span class="string"> 管线        </span>|<span class="string">    \$1    </span>|<span class="string">  234  </span>|</span><br><span class="line">|<span class="string"> &gt; </span>|<span class="string"> ce    </span>|<span class="string">   ce</span>|</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>项目</th>
<th align="right">价格</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td>计算机</td>
<td align="right">$1600</td>
<td align="center">5</td>
</tr>
<tr>
<td>手机</td>
<td align="right">$12</td>
<td align="center">12</td>
</tr>
<tr>
<td>管线</td>
<td align="right">$1</td>
<td align="center">234</td>
</tr>
<tr>
<td>&gt;</td>
<td align="right">ce</td>
<td align="center">ce</td>
</tr>
</tbody></table>
<h3 id="2-6-定义型列表"><a href="#2-6-定义型列表" class="headerlink" title="2.6 定义型列表"></a>2.6 定义型列表</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">名词 <span class="number">1</span></span><br><span class="line">: 定义 <span class="number">1</span>（左侧有一个可见的冒号和四个不可见的空格）</span><br><span class="line"></span><br><span class="line">代码块 <span class="number">2</span></span><br><span class="line">: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</span><br></pre></td></tr></table></figure>
<dl><dt>名词 1</dt><dd>定义 1（左侧有一个可见的冒号和四个不可见的空格）</dd></dl><dl><dt>代码块 2</dt><dd>这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</dd></dl><h3 id="2-7表格对齐"><a href="#2-7表格对齐" class="headerlink" title="2.7表格对齐"></a>2.7表格对齐</h3><p>注： : 代表对齐方式 ,** : 与 | 之间不要有空格**，否则对齐会有些不兼容</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">代码</span><br><span class="line"></span><br><span class="line">|    a    |       b       |      c     |</span><br><span class="line">|<span class="symbol">:-------</span><span class="symbol">:|</span><span class="symbol">:-------------</span> | ----------<span class="symbol">:|</span></span><br><span class="line">|   居中  |     左对齐    |   右对齐   |</span><br><span class="line">|=========|===============|============|</span><br></pre></td></tr></table></figure>
<p>演示</p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="left">b</th>
<th align="right">c</th>
</tr>
</thead>
<tbody><tr>
<td align="center">居中</td>
<td align="left">左对齐</td>
<td align="right">右对齐</td>
</tr>
<tr>
<td align="center">=========</td>
<td align="left">===============</td>
<td align="right">============</td>
</tr>
</tbody></table>
<h3 id="2-8-Html-标签"><a href="#2-8-Html-标签" class="headerlink" title="2.8 Html 标签"></a>2.8 Html 标签</h3><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：<br>设置colspan，rowspan<br><a href="https://blog.csdn.net/loongshawn/article/details/72829090?utm_source=blogxgwz6" target="_blank" rel="noopener">Markdown表格之合并单元格效果</a></p>
<h3 id="2-8-待办事宜-Todo-列表"><a href="#2-8-待办事宜-Todo-列表" class="headerlink" title="2.8 待办事宜 Todo 列表"></a>2.8 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：<br><img src="https://upload-images.jianshu.io/upload_images/1414656-3c07364e15ba43dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/773/format/webp" alt></p>
<h2 id="3-补充"><a href="#3-补充" class="headerlink" title="3.补充"></a>3.补充</h2><h3 id="3-1定义型列表"><a href="#3-1定义型列表" class="headerlink" title="3.1定义型列表"></a>3.1定义型列表</h3><p>注：解释型定义</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">代码：</span><br><span class="line">        Markdown   </span><br><span class="line"><span class="title">        : 轻量级文本标记语言，可以转换成html，pdf等格式  //  开头一个`:</span>` + `Tab` 或 四个空格</span><br></pre></td></tr></table></figure>
<p>Markdown<br>  : 轻量级文本标记语言，可以转换成html，pdf等格式  //  开头一个<code>:</code> + <code>Tab</code> 或 四个空格</p>
<h3 id="3-2自动邮箱链接"><a href="#3-2自动邮箱链接" class="headerlink" title="3.2自动邮箱链接"></a>3.2自动邮箱链接</h3><p>代码:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">xxx</span>@<span class="keyword">outlook</span>.<span class="keyword">com</span>&gt;</span><br></pre></td></tr></table></figure>
<p>演示<br>    <a href="mailto:&#x31;&#x35;&#x33;&#x35;&#x30;&#52;&#x35;&#56;&#x38;&#x37;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#x31;&#x35;&#x33;&#x35;&#x30;&#52;&#x35;&#56;&#x38;&#x37;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;</a></p>
<h3 id="3-3字体-字号与颜色"><a href="#3-3字体-字号与颜色" class="headerlink" title="3.3字体,字号与颜色"></a>3.3字体,字号与颜色</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;font <span class="attribute">face</span>=<span class="string">"STCAIYUN"</span>&gt;我是华文彩云&lt;/font&gt;</span><br><span class="line">&lt;font <span class="attribute">color</span>=gray <span class="attribute">size</span>=5&gt;color=gray&lt;/font&gt;</span><br><span class="line">&lt;font color=  #0099ff <span class="attribute">size</span>=5 <span class="attribute">face</span>=<span class="string">"黑体"</span>&gt;color=#0099ff <span class="attribute">size</span>=5 <span class="attribute">face</span>=<span class="string">"黑体"</span>&lt;/font&gt;</span><br></pre></td></tr></table></figure>
<p><font face="STCAIYUN">我是华文彩云</font><br><font color="gray" size="5">color=gray</font><br><font color="#0099ff" size="5" face="黑体">color=#0099ff size=5 face=”黑体”</font><br><font face="楷体"><br>Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。</font><br>##4. 数学和LaTeX<br>$ 表示行内公式：</p>
<p>质能守恒方程可以用一个很简洁的方程式 E=mc^2 来表达。</p>
<p>$$ 表示整行公式：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\sum_&#123;i=<span class="number">1</span>&#125;^n a_i=<span class="number">0</span><span class="symbol">$</span><span class="symbol">$</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$E</span>=mc^2$</span></span><br></pre></td></tr></table></figure>
<p>$$\sum_{i=1}^n a_i=0$$<br>$ E=mc^2$</p>
<h3 id="4-1-常用计算速查"><a href="#4-1-常用计算速查" class="headerlink" title="4.1 常用计算速查"></a>4.1 常用计算速查</h3><h3 id="4-2省略号"><a href="#4-2省略号" class="headerlink" title="4.2省略号"></a>4.2省略号</h3><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">a_1</span>,<span class="built_in">a_2</span>,\ldots,<span class="built_in">a_n</span>$</span><br><span class="line">$ <span class="built_in">a_1</span>+<span class="built_in">a_2</span>+\ldots+<span class="built_in">a_n</span>$</span><br><span class="line">$ <span class="built_in">a_1</span>+<span class="built_in">a_2</span>+\cdots+<span class="built_in">a_n</span>$</span><br></pre></td></tr></table></figure>
<p>$ a_1,a_2,\ldots,a_n$<br>$ a_1+a_2+\ldots+a_n$<br>$ a_1+a_2+\cdots+a_n$</p>
<h3 id="4-3字体"><a href="#4-3字体" class="headerlink" title="4.3字体"></a>4.3字体</h3><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> \mathsf&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125;   <span class="symbol">$</span></span><br><span class="line"><span class="symbol">$</span> \mathcal&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; <span class="symbol">$</span></span><br><span class="line"><span class="symbol">$</span> \mathscr&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; <span class="symbol">$</span></span><br><span class="line"><span class="symbol">$</span> \mathfrak&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; <span class="symbol">$</span></span><br></pre></td></tr></table></figure>
<p>$ \mathsf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}   $<br>$ \mathcal{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $<br>$ \mathscr{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $<br>$ \mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $</p>
<h3 id="4-4常用公式"><a href="#4-4常用公式" class="headerlink" title="4.4常用公式"></a>4.4常用公式</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$x_i^<span class="number">2</span>$，$x_i^<span class="number">2</span>+x_&#123;i^<span class="number">2</span>&#125;$，$<span class="number">10</span>^&#123;<span class="number">10</span>&#125;$</span><br><span class="line">$\log_2 x$</span><br><span class="line">$&#123;x^y&#125;^z+x^&#123;y^z&#125;$</span><br><span class="line">$\sum^&#123;j<span class="number">-1</span>&#125;_&#123;k=<span class="number">0</span>&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125; z_k&#125;$</span><br><span class="line">$\sum_&#123;i=<span class="number">0</span>&#125;^n i^<span class="number">2</span> = \frac&#123;(n^<span class="number">2</span>+n)(<span class="number">2</span>n+<span class="number">1</span>)&#125;&#123;<span class="number">6</span>&#125;$</span><br><span class="line">$f(x_1,x_x,\ldots,x_n) = x_1^<span class="number">2</span> + x_2^<span class="number">2</span> + \cdots + x_n^<span class="number">2</span> $</span><br><span class="line">$\displaystyle \lim_&#123;t \to <span class="number">0</span>&#125; \<span class="built_in">int</span>_t^<span class="number">1</span> f(t)\, dt$</span><br><span class="line">$\lim_&#123;t \to <span class="number">0</span>&#125; \<span class="built_in">int</span>_t^<span class="number">1</span> f(t)\, dt$.</span><br></pre></td></tr></table></figure>
<p>$x_i^2$，$x_i^2+x_{i^2}$，$10^{10}$<br>$\log_2 x$<br>${x^y}^z+x^{y^z}$<br>$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$<br>$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$<br>$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $<br>$\displaystyle \lim_{t \to 0} \int_t^1 f(t), dt$<br>$\lim_{t \to 0} \int_t^1 f(t), dt$.</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">如果需要大小调整，大小写切换写</span><br><span class="line">$$<span class="symbol">\B</span>iggl(<span class="symbol">\b</span>iggl(<span class="symbol">\B</span>igl(<span class="symbol">\b</span>igl((x)<span class="symbol">\b</span>igr)<span class="symbol">\B</span>igr)<span class="symbol">\b</span>iggr)<span class="symbol">\B</span>iggr) gives (((((x)))))$$</span><br></pre></td></tr></table></figure>
<p>$$\Biggl(\biggl(\Bigl(\bigl((x)\bigr)\Bigr)\biggr)\Biggr) gives (((((x)))))$$</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">括号自适应大小</span><br><span class="line"><span class="symbol">$</span><span class="symbol">$</span>(\<span class="built-in">frac</span>&#123;\<span class="built-in">sqrt</span> x&#125;&#123;y^<span class="number">3</span>&#125;)<span class="symbol">$</span><span class="symbol">$</span></span><br><span class="line"><span class="symbol">$</span><span class="symbol">$</span> \left(\<span class="built-in">frac</span>&#123;\<span class="built-in">sqrt</span> x&#125;&#123;y^<span class="number">3</span>&#125;\right)<span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure>
<p>$$(\frac{\sqrt x}{y^3})$$<br>$$ \left(\frac{\sqrt x}{y^3}\right)$$</p>
<h3 id="4-5等式"><a href="#4-5等式" class="headerlink" title="4.5等式"></a>4.5等式</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$$</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;aligned&#125;</span></span></span></span><br><span class="line"><span class="formula">        a &amp;= b + c <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">        &amp;= d + e + f + g <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">        &amp;= h + i</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;aligned&#125;</span></span></span></span><br><span class="line"><span class="formula">$$</span></span><br></pre></td></tr></table></figure>
<p>$$<br>    \begin{aligned}<br>        a &amp;= b + c \<br>        &amp;= d + e + f + g \<br>        &amp;= h + i<br>    \end{aligned}<br>$$</p>
<h3 id="4-6矩阵"><a href="#4-6矩阵" class="headerlink" title="4.6矩阵"></a>4.6矩阵</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;matrix&#125;</span></span></span></span><br><span class="line"><span class="formula">    1 &amp; x &amp; x^2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    1 &amp; y &amp; y^2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    1 &amp; z &amp; z^2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;matrix&#125;</span></span></span></span><br><span class="line"><span class="formula">$</span> , <span class="formula">$</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;pmatrix&#125;</span></span> </span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;pmatrix&#125;</span></span></span></span><br><span class="line"><span class="formula">$</span> , <span class="formula">$   </span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;bmatrix&#125;</span></span> </span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;bmatrix&#125;</span></span></span></span><br><span class="line"><span class="formula">$</span> , <span class="formula">$</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;Bmatrix&#125;</span></span> </span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;Bmatrix&#125;</span></span> </span></span><br><span class="line"><span class="formula">$</span> , <span class="formula">$</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;vmatrix&#125;</span></span> </span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;vmatrix&#125;</span></span> </span></span><br><span class="line"><span class="formula">$</span> , <span class="formula">$</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;Vmatrix&#125;</span></span> </span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;Vmatrix&#125;</span></span> </span></span><br><span class="line"><span class="formula">$</span></span><br></pre></td></tr></table></figure>
<p>$<br>    \begin{matrix}<br>    1 &amp; x &amp; x^2 \<br>    1 &amp; y &amp; y^2 \<br>    1 &amp; z &amp; z^2 \<br>    \end{matrix}<br>$ , $<br>    \begin{pmatrix}<br>    1 &amp; 2 \<br>    1 &amp; 2 \<br>    \end{pmatrix}<br>$ , $<br>    \begin{bmatrix}<br>    1 &amp; 2 \<br>    1 &amp; 2 \<br>    \end{bmatrix}<br>$ , $<br>    \begin{Bmatrix}<br>    1 &amp; 2 \<br>    1 &amp; 2 \<br>    \end{Bmatrix}<br>$ , $<br>    \begin{vmatrix}<br>    1 &amp; 2 \<br>    1 &amp; 2 \<br>    \end{vmatrix}<br>$ , $<br>    \begin{Vmatrix}<br>    1 &amp; 2 \<br>    1 &amp; 2 \<br>    \end{Vmatrix}<br>$</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">省略元素 <span class="tag">\<span class="name">cdots</span></span> ⋯ <span class="tag">\<span class="name">ddots</span></span> ⋱ vdots ⋮</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;matrix&#125;</span></span></span></span><br><span class="line"><span class="formula">    a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; a_&#123;13&#125; &amp; <span class="tag">\<span class="name">cdots</span></span> &amp; a_&#123;1n&#125; <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; a_&#123;23&#125; &amp; <span class="tag">\<span class="name">cdots</span></span> &amp; a_&#123;2n&#125; <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">vdots</span></span> &amp; <span class="tag">\<span class="name">vdots</span></span> &amp; <span class="tag">\<span class="name">vdots</span></span> &amp; <span class="tag">\<span class="name">ddots</span></span> &amp; <span class="tag">\<span class="name">vdots</span></span> <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    a_&#123;n1&#125; &amp; a_&#123;n2&#125; &amp; a_&#123;n3&#125; &amp; <span class="tag">\<span class="name">cdots</span></span> &amp; a_&#123;2n&#125; <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;matrix&#125;</span></span></span></span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"></span><br><span class="line"><span class="formula">$$ <span class="tag">\<span class="name">left</span><span class="string">[</span></span></span></span><br><span class="line"><span class="formula"><span class="tag"><span class="string">\begin&#123;array&#125;&#123;cc|c&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag"><span class="string">  1&amp;2&amp;3\\</span></span></span></span><br><span class="line"><span class="formula"><span class="tag"><span class="string">  4&amp;5&amp;6</span></span></span></span><br><span class="line"><span class="formula"><span class="tag"><span class="string">\end&#123;array&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag"><span class="string">\right]</span></span> </span></span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"><span class="formula">  f(n) =</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">begin</span><span class="string">&#123;cases&#125;</span></span></span></span><br><span class="line"><span class="formula">n/2,  &amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;if $n$ is even&#125;</span></span> <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">3n+1, &amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;if $n$ is odd&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;cases&#125;</span></span></span></span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">left</span></span>.</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">begin</span><span class="string">&#123;array&#125;</span><span class="string">&#123;l&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">text</span><span class="string">&#123;if $n$ is even:&#125;</span></span>&amp;n/2<span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">text</span><span class="string">&#123;if $n$ is odd:&#125;</span></span>&amp;3n+1</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;array&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">right</span></span><span class="tag">\<span class="name">&#125;</span></span></span></span><br><span class="line"><span class="formula">=f(n)</span></span><br><span class="line"><span class="formula">$$</span></span><br></pre></td></tr></table></figure>


<p>$$<br>    \begin{matrix}<br>    a_{11} &amp; a_{12} &amp; a_{13} &amp; \cdots &amp; a_{1n} \<br>    a_{21} &amp; a_{22} &amp; a_{23} &amp; \cdots &amp; a_{2n} \<br>    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>    a_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \cdots &amp; a_{2n} \<br>    \end{matrix}<br>$$</p>
<p>$$ \left[<br>\begin{array}{cc|c}<br>  1&amp;2&amp;3\<br>  4&amp;5&amp;6<br>\end{array}<br>\right]<br>$$</p>
<p>$$<br>  f(n) =<br>\begin{cases}<br>n/2,  &amp; \text{if $n$ is even} \<br>3n+1, &amp; \text{if $n$ is odd}<br>\end{cases}<br>$$</p>
<p>$$<br>\left.<br>\begin{array}{l}<br>\text{if $n$ is even:}&amp;n/2\<br>\text{if $n$ is odd:}&amp;3n+1<br>\end{array}<br>\right}<br>=f(n)<br>$$</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">上下行的间距调整 ex</span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"><span class="formula">f(n) =</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">begin</span><span class="string">&#123;cases&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">frac</span><span class="string">&#123;n&#125;</span><span class="string">&#123;2&#125;</span></span>,  &amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;if $n$ is even&#125;</span></span> <span class="tag">\<span class="name">\</span><span class="string">[5ex]</span></span></span></span><br><span class="line"><span class="formula">3n+1, &amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;if $n$ is odd&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;cases&#125;</span></span></span></span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="formula">$$</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">left</span></span><span class="tag">\<span class="name">&#123;</span></span> </span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">begin</span><span class="string">&#123;array&#125;</span><span class="string">&#123;c&#125;</span></span></span></span><br><span class="line"><span class="formula">a_1x+b_1y+c_1z=d_1 <span class="tag">\<span class="name">\</span></span> </span></span><br><span class="line"><span class="formula">a_2x+b_2y+c_2z=d_2 <span class="tag">\<span class="name">\</span></span> </span></span><br><span class="line"><span class="formula">a_3x+b_3y+c_3z=d_3</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;array&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">right</span></span>. </span></span><br><span class="line"><span class="formula">$$</span></span><br></pre></td></tr></table></figure>
<p>$$<br>f(n) =<br>\begin{cases}<br>\frac{n}{2},  &amp; \text{if $n$ is even} \[5ex]<br>3n+1, &amp; \text{if $n$ is odd}<br>\end{cases}<br>$$</p>
<p>$$<br>\left{<br>\begin{array}{c}<br>a_1x+b_1y+c_1z=d_1 \<br>a_2x+b_2y+c_2z=d_2 \<br>a_3x+b_3y+c_3z=d_3<br>\end{array}<br>\right.<br>$$</p>
<h3 id="aligned-对齐"><a href="#aligned-对齐" class="headerlink" title="aligned 对齐"></a>aligned 对齐</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$$ </span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">left</span></span><span class="tag">\<span class="name">&#123;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">begin</span><span class="string">&#123;aligned&#125;</span></span> </span></span><br><span class="line"><span class="formula">a_1x+b_1y+c_1z &amp;=d_1+e_1 <span class="tag">\<span class="name">\</span></span> </span></span><br><span class="line"><span class="formula">a_2x+b_2y&amp;=d_2 <span class="tag">\<span class="name">\</span></span> </span></span><br><span class="line"><span class="formula">a_3x+b_3y+c_3z &amp;=d_3 </span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;aligned&#125;</span></span> </span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">right</span></span>. </span></span><br><span class="line"><span class="formula">$$</span></span><br></pre></td></tr></table></figure>
<p>$$<br>\left{<br>\begin{aligned}<br>a_1x+b_1y+c_1z &amp;=d_1+e_1 \<br>a_2x+b_2y&amp;=d_2 \<br>a_3x+b_3y+c_3z &amp;=d_3<br>\end{aligned}<br>\right.<br>$$</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">继续用em调整行距</span><br><span class="line"><span class="formula">$$<span class="tag">\<span class="name">begin</span><span class="string">&#123;cases&#125;</span></span></span></span><br><span class="line"><span class="formula">a_1x+b_1y+c_1z=d_1 <span class="tag">\<span class="name">\</span><span class="string">[2ex]</span></span> </span></span><br><span class="line"><span class="formula">a_2x+b_2y+c_2z=d_2 <span class="tag">\<span class="name">\</span><span class="string">[2ex]</span></span> </span></span><br><span class="line"><span class="formula">a_3x+b_3y+c_3z=d_3</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;cases&#125;</span></span></span></span><br><span class="line"><span class="formula">$$</span></span><br></pre></td></tr></table></figure>
<p>$$\begin{cases}<br>a_1x+b_1y+c_1z=d_1 \[2ex]<br>a_2x+b_2y+c_2z=d_2 \[2ex]<br>a_3x+b_3y+c_3z=d_3<br>\end{cases}<br>$$</p>
<h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><h2 id="5-流程图"><a href="#5-流程图" class="headerlink" title="5.流程图"></a>5.流程图</h2><h3 id="5-1简单流程图"><a href="#5-1简单流程图" class="headerlink" title="5.1简单流程图"></a>5.1简单流程图</h3><p><a href="http://flowchart.js.org/" target="_blank" rel="noopener">流程图语法参考</a></p>
<h3 id="5-2序列图x"><a href="#5-2序列图x" class="headerlink" title="5.2序列图x`"></a>5.2序列图x`</h3><p>代码:<br><img src="/2020/01/02/VsCode%E6%94%AF%E6%8C%81%E7%9A%84markdown%E8%AF%AD%E6%B3%95%E5%8F%82%E8%80%83/%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt><br>效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A-&gt;&gt;B: 你好</span><br><span class="line">Note left of A: 我在左边 </span><br><span class="line">Note right of B: 我在右边</span><br><span class="line">B--&gt;A: 很高兴认识你</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">起床-&gt;吃饭: 稀饭油条</span><br><span class="line">吃饭-&gt;上班: 不要迟到了</span><br><span class="line">上班-&gt;午餐: 吃撑了</span><br><span class="line">上班-&gt;下班:</span><br><span class="line">Note right of 下班: 下班了</span><br><span class="line">下班-&gt;回家:</span><br><span class="line">Note right of 回家: 到家了</span><br><span class="line">回家--&gt;&gt;起床:</span><br><span class="line">Note left of 起床: 新的一天</span><br></pre></td></tr></table></figure>
<p>未完待续…. </p>
<h3 id="5-3mermaid-甘特图"><a href="#5-3mermaid-甘特图" class="headerlink" title="5.3mermaid 甘特图"></a>5.3mermaid 甘特图</h3><h3 id="5-4-puml-序列图"><a href="#5-4-puml-序列图" class="headerlink" title="5.4 puml 序列图"></a>5.4 puml 序列图</h3><h3 id="5-5-dot"><a href="#5-5-dot" class="headerlink" title="5.5 dot"></a>5.5 dot</h3>]]></content>
      <tags>
        <tag>VsCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Homework Shell</title>
    <url>/2020/01/01/Homework%20Shell/</url>
    <content><![CDATA[<h2 id="操作系统-Homework-Shell"><a href="#操作系统-Homework-Shell" class="headerlink" title="操作系统 Homework: Shell"></a>操作系统 Homework: Shell</h2><p><a href="https://pdos.csail.mit.edu/6.828/2016/homework/xv6-shell.html" target="_blank" rel="noopener">Homework: shell</a></p>
<p>通过此次作业，将会了解到 Shell 的工作原理，以及类 Linux 系统的新进程到底是如何产生的。</p>
<a id="more"></a>
<p>首先自然是看懂 main 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> fd, r;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read and run input commands.</span></span><br><span class="line">  <span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">'c'</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">'d'</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">' '</span>)&#123;</span><br><span class="line">      <span class="comment">// 如果只是 cd 命令，则切换文件夹后继续等待命令</span></span><br><span class="line">      <span class="comment">// Clumsy but will have to do for now.</span></span><br><span class="line">      <span class="comment">// Chdir has no effect on the parent if run in the child.</span></span><br><span class="line">      <span class="comment">// 一般写完命令敲回车，这里就是把回车改为'\0'</span></span><br><span class="line">      buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></span><br><span class="line">      <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"cannot cd %s\n"</span>, buf+<span class="number">3</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若不是 cd 命令，则fork出子程序尝试运行命令</span></span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">      runcmd(parsecmd(buf));</span><br><span class="line">    <span class="comment">// 等待子进程完成</span></span><br><span class="line">    wait(&amp;r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环调用 getcmd 函数读入命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">getcmd(<span class="keyword">char</span> *buf, <span class="keyword">int</span> nbuf)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(fileno(<span class="built_in">stdin</span>)))  <span class="comment">// 判断标准输入是否为终端</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"6.828$ "</span>);  <span class="comment">// 是终端则显示提示符</span></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, nbuf);</span><br><span class="line">  fgets(buf, nbuf, <span class="built_in">stdin</span>);  <span class="comment">// 从标准输入读入nbuf个字符到 buf 中</span></span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0</span>) <span class="comment">// EOF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读入命令并确定不是 cd 命令后，执行关键语句<br><code>runcmd(parsecmd(buf))</code>,显然是将 buf 用 parsecmd 解析后，送入 runcmd 运行。我们暂时并不关心如何解析，无非是一些字符串处理，提取关键符号确定类型。先看 runcmd 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Execute cmd.  Never returns.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">runcmd(struct cmd *cmd)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> p[<span class="number">2</span>], r;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">execcmd</span> *<span class="title">ecmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipecmd</span> *<span class="title">pcmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">redircmd</span> *<span class="title">rcmd</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(cmd == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">switch</span>(cmd-&gt;type)&#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"unknown runcmd\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">    ecmd = (struct execcmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"exec not implemented\n"</span>);</span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'&gt;'</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">    rcmd = (struct redircmd*)cmd;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"redir not implemented\n"</span>);</span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    runcmd(rcmd-&gt;cmd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'|'</span>:</span><br><span class="line">    pcmd = (struct pipecmd*)cmd;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pipe not implemented\n"</span>);</span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可看出，parsecmd 把命令分成了3个类型，分别是可执行命令，重定向命令，以及管道命令。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>可执行命令</strong><br>在文中找到关键提示：</p>
<blockquote>
<p>You may want to change the 6.828 shell to always try /bin, if the program doesn’t exist in the current working directory, so that below you don’t have to type “/bin” for each program. If you are ambitious you can implement support for a PATH variable.</p>
</blockquote>
<p>也就是说对于 ls 这个存在的命令，我们只需要想办法将命令引导到 /bin/目录下寻找即可。这里涉及到 linux 系统调用的一个关键函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> mode)</span></span></span><br></pre></td></tr></table></figure>
<p>它的作用是检查能否对某个文件(pathname)执行某个操作(mode)，操作的主要模式有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R_OK      <span class="comment">// 测试读许可权</span></span><br><span class="line">W_OK      <span class="comment">// 测试写许可权</span></span><br><span class="line">X_OK      <span class="comment">// 测试执行许可权</span></span><br><span class="line">F_OK      <span class="comment">// 测试文件是否存在</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，测试成功返回值为0。失败为-1。有了这个函数，可以把之前的类型为’ ‘的部分改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">  ecmd = (struct execcmd*)cmd;</span><br><span class="line">  <span class="keyword">if</span> (ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// fprintf(stderr, "exec not implemented\n");</span></span><br><span class="line">  <span class="keyword">if</span> (access(ecmd-&gt;argv[<span class="number">0</span>], F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">  execv(ecmd-&gt;argv[<span class="number">0</span>], ecmd-&gt;argv);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *binPath = <span class="string">"/bin/"</span>;</span><br><span class="line">  <span class="keyword">int</span> pathLen = <span class="built_in">strlen</span>(binPath) + <span class="built_in">strlen</span>(ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">char</span> *abs_path = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((pathLen+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">  <span class="built_in">strcpy</span>(abs_path, binPath);</span><br><span class="line">  <span class="built_in">strcat</span>(abs_path, ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> (access(abs_path, F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">      execv(abs_path, ecmd-&gt;argv);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: Command not found\n"</span>, ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要补充说明的可能就是 execv 函数，它是 exec 函数族的一个，exec 函数族的作用就是根据 pathname 找到可执行文件，并用它取代调用进程的内容。虽然 pid 未改变，但是实际运行的内容已经不同。结合之前 main 函数中的内容，可以看出 Shell 执行某个命令实际上就是 fork 出一个子进程，然后把子进程替换为想要执行的程序。<br>测试结果为：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rlj@rlj-virtual-machine:~/OS/shell$ ./myShell</span><br><span class="line">6.828$ ls</span><br><span class="line">myShell  sh.c  shell_script  Shell_script_习题.pdf  t.sh</span><br><span class="line">6.828$ ls .//</span><br><span class="line">myShell  sh.c  shell_script  Shell_script_习题.pdf  t.sh</span><br><span class="line">6.828$ abc</span><br><span class="line">abc: Command not found</span><br><span class="line">6.828$ ps</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line"> 17514 pts/2    00:00:00 bash</span><br><span class="line"> 17537 pts/2    00:00:00 myShell</span><br><span class="line"> 17541 pts/2    00:00:00 ps</span><br><span class="line">6.828$ <span class="built_in">echo</span> i love you</span><br><span class="line">i love you</span><br></pre></td></tr></table></figure>
<p>好奇又试了试其他指令</p>
<h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>首先可能需要看一下配套的 xv6 教材第 10 页的文件系统，至少需要了解文件描述符 (file descriptor) 是什么。<br>刚开始写的时候还以为需要自己处理 ‘&lt;’ 和 ‘&gt;’ 情况，后来发现结构体 rcmd 中已经设置好，不需要分开处理。注意一下这个函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct cmd*</span><br><span class="line">redircmd(struct cmd *subcmd, char *file, int <span class="built_in">type</span>)</span><br><span class="line">&#123;</span><br><span class="line">  struct redircmd *cmd;</span><br><span class="line"></span><br><span class="line">  cmd = malloc(sizeof(*cmd));</span><br><span class="line">  memset(cmd, 0, sizeof(*cmd));</span><br><span class="line">  cmd-&gt;<span class="built_in">type</span> = <span class="built_in">type</span>;</span><br><span class="line">  cmd-&gt;cmd = subcmd;</span><br><span class="line">  cmd-&gt;file = file;</span><br><span class="line">  cmd-&gt;mode = (<span class="built_in">type</span> == <span class="string">'&lt;'</span>) ?  O_RDONLY : O_WRONLY|O_CREAT|O_TRUNC;</span><br><span class="line">  cmd-&gt;fd = (<span class="built_in">type</span> == <span class="string">'&lt;'</span>) ? 0 : 1;</span><br><span class="line">  <span class="built_in">return</span> (struct cmd*)cmd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看懂之后的工作就很简单了，结果代码为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'&gt;'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">  rcmd = (struct redircmd*)cmd;</span><br><span class="line">  // fprintf(stderr, <span class="string">"redir not implemented\n"</span>);</span><br><span class="line">  // Your code here ...</span><br><span class="line">  close(rcmd-&gt;fd);</span><br><span class="line">  <span class="keyword">if</span> (open(rcmd-&gt;file, rcmd-&gt;flags, 0644) &lt; 0) &#123;</span><br><span class="line">  fprintf(stderr, <span class="string">"Unable to open file: %s\n"</span>, rcmd-&gt;file);</span><br><span class="line">  <span class="built_in">exit</span>(0);</span><br><span class="line">  &#125;</span><br><span class="line">  runcmd(rcmd-&gt;cmd);</span><br><span class="line">  <span class="built_in">break</span>;</span><br></pre></td></tr></table></figure>
<pre><code>思路就是先关闭程序原先的标准输入/输出，打开指定文件作为新的标准输入/输出。</code></pre><p>非常容易漏掉权限位，即open的第三个参数。注意这里用的是8进制数，所以一定不能直接写<code>644</code>而要写<code>0644。</code><br>我还遇到了一个问题，在此记录一下，第一次权限设置不对，导致无法打开生成的文件，更改后运行，还是不行。后来发现其实由于只是 Truncate，没有把之前生成的文件删除新建，所以权限还是第一次有问题的版本。删掉之前的文件，重新运行，结果正常。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>本次作业的最难的就是管道。重点还是参考 xv6 教材 13 页管道部分，在 xv6 源码的 Sheet 86 还能找到管道的实现。重点是搞明白 <code>pipe</code>，<code>dup</code> 两个函数。</p>
<ul>
<li><code>int pipe(int p[])</code><br>作用是建立一个缓冲区，并把缓冲区通过 fd 形式给程序调用。它将 p[0] 修改为缓冲区的读取端， p[1] 修改为缓冲区的写入端。</li>
<li><code>int dup(int old_fd)</code><br>作用是产生一个fd，指向 old_fd 指向的文件，并返回这个fd。产生的 fd 总是空闲的最小 fd。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'|'</span>:</span><br><span class="line">  pcmd = (struct pipecmd*)cmd;</span><br><span class="line">  // fprintf(stderr, <span class="string">"pipe not implemented\n"</span>);</span><br><span class="line">  // Your code here ...</span><br><span class="line">  <span class="keyword">if</span> (pipe(p) &lt; 0) fprintf(stderr,<span class="string">"pipe failed\n"</span>);</span><br><span class="line">  <span class="keyword">if</span> (fork1() == 0) &#123;</span><br><span class="line">  // 先关闭标准输出再 dup</span><br><span class="line">  // dup 会把标准输出定向到 p[1] 所指文件，即管道写入端</span><br><span class="line">  close(1);</span><br><span class="line">  dup(p[1]);</span><br><span class="line">  // 去掉管道对端口的引用</span><br><span class="line">  close(p[0]);</span><br><span class="line">  close(p[1]);</span><br><span class="line">  // 此时 left 的标准输入不变，标准输出流入管道</span><br><span class="line">  runcmd(pcmd-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fork1() == 0) &#123;</span><br><span class="line">  // 先关闭标准输入再 dup</span><br><span class="line">  // dup 会把标准输入定向到 p[0] 所指文件，即管道读取端</span><br><span class="line">  close(0);</span><br><span class="line">  dup(p[0]);</span><br><span class="line">  // 去掉管道对端口的引用</span><br><span class="line">  close(p[0]);</span><br><span class="line">  close(p[1]);</span><br><span class="line">  // 此时 right 的标准输入从管道读取，标准输出不变</span><br><span class="line">  runcmd(pcmd-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">  close(p[0]);</span><br><span class="line">  close(p[1]);</span><br><span class="line">  <span class="built_in">wait</span>(&amp;r);</span><br><span class="line">  <span class="built_in">wait</span>(&amp;r);</span><br><span class="line">  <span class="built_in">break</span>;</span><br></pre></td></tr></table></figure>
比较费解的就是 fork 了两次，也 wait 了两次。我自己写了一个实现，似乎也能正常运行，并且只 fork 了一次。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'|'</span>:</span><br><span class="line">  pcmd = (struct pipecmd*)cmd;</span><br><span class="line">  // fprintf(stderr, <span class="string">"pipe not implemented\n"</span>);</span><br><span class="line">  // Your code here ...</span><br><span class="line">  <span class="keyword">if</span> (pipe(p) &lt; 0) fprintf(stderr,<span class="string">"pipe failed\n"</span>);</span><br><span class="line">  <span class="keyword">if</span> (fork1() == 0) &#123;</span><br><span class="line">  close(1);</span><br><span class="line">  dup(p[1]);</span><br><span class="line">  close(p[0]);</span><br><span class="line">  close(p[1]);</span><br><span class="line">  runcmd(pcmd-&gt;left);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  close(0);</span><br><span class="line">  dup(p[0]);</span><br><span class="line">  close(p[0]);</span><br><span class="line">  close(p[1]);</span><br><span class="line">  runcmd(pcmd-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">break</span>;</span><br></pre></td></tr></table></figure>
最后，执行脚本判断：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os/shell4" alt><br>好的 ，又出现了问题。这几个命令都位于 <code>/usr/bin/</code>下，而我们在执行中只加入了 <code>/bin/</code> 目录，于是我又为case ‘ ‘添加了一个一劳永逸的实现，方便以后添加新的路径。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">  ecmd = (struct execcmd*)cmd;</span><br><span class="line">  <span class="keyword">if</span>(ecmd-&gt;argv[0] == 0)</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">  // fprintf(stderr, <span class="string">"exec not implemented\n"</span>);</span><br><span class="line">  <span class="keyword">if</span>(access(ecmd-&gt;argv[0], F_OK) == 0) &#123;</span><br><span class="line">  execv(ecmd-&gt;argv[0], ecmd-&gt;argv);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  // 将路径改为数组实现</span><br><span class="line">  const char *binPath[] = &#123;<span class="string">"/bin/"</span>, <span class="string">"/usr/bin/"</span>&#125;;</span><br><span class="line">  char *abs_path;</span><br><span class="line">  int bin_count = sizeof(binPath)/sizeof(binPath[0]);</span><br><span class="line">  int found = 0;</span><br><span class="line">  <span class="keyword">for</span> (int i=0; i&lt;bin_count &amp;&amp; found==0; i++) &#123;</span><br><span class="line">      int pathLen = strlen(binPath[i]) + strlen(ecmd-&gt;argv[0]);</span><br><span class="line">      abs_path = (char *)malloc((pathLen+1)*sizeof(char));</span><br><span class="line">      strcpy(abs_path, binPath[i]);</span><br><span class="line">      strcat(abs_path, ecmd-&gt;argv[0]);</span><br><span class="line">      <span class="keyword">if</span>(access(abs_path, F_OK) == 0) &#123;</span><br><span class="line">          execv(abs_path, ecmd-&gt;argv);</span><br><span class="line">      found = 1;</span><br><span class="line">      &#125;</span><br><span class="line">      free(abs_path);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (found == 0) &#123;</span><br><span class="line">      fprintf(stderr, <span class="string">"%s: Command not found\n"</span>, ecmd-&gt;argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">break</span>;</span><br></pre></td></tr></table></figure>
运行成功,结果如下<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os/shell2" alt></li>
</ul>
<p>[本文来源]<a href="https://www.jianshu.com/p/64385b80210b" target="_blank" rel="noopener">https://www.jianshu.com/p/64385b80210b</a></p>
]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Ping 本质（ ICMP ）</title>
    <url>/2020/01/01/Ping%20%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<h2 id="1、什么是-Ping"><a href="#1、什么是-Ping" class="headerlink" title="1、什么是 Ping"></a>1、什么是 Ping</h2><a id="more"></a>
<blockquote>
<p>ping是一种计算机网络工具，用来测试数据包能否透过IP协议到达特定主机。ping的运作原理是向目标主机传出一个ICMP echo@要求数据包，并等待接收echo回应数据包。程序会按时间和成功响应的次数估算丢失数据包率（丢包率）和数据包往返时间（网络时延，Round-trip delay time）。———— 维基百科<br> 我们在网络通信的过程中，常常使用 ping 某一个 IP 地址或者某个域名看下基本连接是否正常；是否有丢包；是否有网络延迟。ping 就是我们经常用来作为网络连接通信的测试“指令”。</p>
</blockquote>
<p>我记得我们以前调侃说只要会 Ping 就可以去当网吧网管了（其实网管的工作肯定比这个复杂的多）。</p>
<p>Windows 10 下的 Ping</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">C:\&gt;ping www.baidu.com</span><br><span class="line"></span><br><span class="line">正在 Ping www.a.shifen.com [<span class="number">119.75</span><span class="number">.216</span><span class="number">.20</span>] 具有 <span class="number">32</span> 字节的数据:</span><br><span class="line">来自 <span class="number">119.75</span><span class="number">.216</span><span class="number">.20</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">42</span>ms TTL=<span class="number">53</span></span><br><span class="line">来自 <span class="number">119.75</span><span class="number">.216</span><span class="number">.20</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">42</span>ms TTL=<span class="number">53</span></span><br><span class="line">来自 <span class="number">119.75</span><span class="number">.216</span><span class="number">.20</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">42</span>ms TTL=<span class="number">53</span></span><br><span class="line">来自 <span class="number">119.75</span><span class="number">.216</span><span class="number">.20</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">42</span>ms TTL=<span class="number">53</span></span><br><span class="line"></span><br><span class="line"><span class="number">119.75</span><span class="number">.216</span><span class="number">.20</span> 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = <span class="number">4</span>，已接收 = <span class="number">4</span>，丢失 = <span class="number">0</span> (<span class="number">0</span>% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = <span class="number">42</span>ms，最长 = <span class="number">42</span>ms，平均 = <span class="number">42</span>ms</span><br></pre></td></tr></table></figure>
<h2 id="Ping-的工作原理"><a href="#Ping-的工作原理" class="headerlink" title="Ping 的工作原理"></a>Ping 的工作原理</h2><p>在维基百科中解释有说明， Ping 的原理是 ICMP 协议.</p>
<h2 id="什么是-ICMP-协议"><a href="#什么是-ICMP-协议" class="headerlink" title="什么是 ICMP 协议"></a>什么是 ICMP 协议</h2><blockquote>
<p>ICMP 的全称是 Intent Control Message Protocol, 中文过来就是 互联网控制报文协议</p>
</blockquote>
<p>网络数据包在庞大的网络中会很多各种不同情况。如果一定需要举一个例子来比如的话，用相当于兵种的侦察兵。时刻给大部队探测前方的情况。以便后方的大部队能够根据不同情况做出不同的调整。所以 ICMP 经常用于网络环境的测试。</p>
<blockquote>
<p>互联网控制消息协议（英语：Internet Control Message Protocol，缩写：ICMP）是互联网协议族的核心协议之一。它用于TCP/IP网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。 —— 维基百科</p>
</blockquote>
<h2 id="ICMP-协议的格式"><a href="#ICMP-协议的格式" class="headerlink" title="ICMP 协议的格式"></a>ICMP 协议的格式</h2><p>用图文表示：<br><img src="https://upload-images.jianshu.io/upload_images/12814988-200da5d8944c012d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="ICMP 协议格式"><br>ICMP 报文封装在 IP 包里面。ICMP 的报文类型根据类型和代码有很多，文章后面有来自维基百科的完整的表格。但是主要分为两类：</p>
<blockquote>
<p>A、查询报文<br>B、差错报文</p>
</blockquote>
<h2 id="查询报文-（Echo-Request与-Echo-Reply）"><a href="#查询报文-（Echo-Request与-Echo-Reply）" class="headerlink" title="查询报文 （Echo Request与 Echo Reply）"></a>查询报文 （Echo Request与 Echo Reply）</h2><p>定义：发送端主动发起请求，并且获取到应答。</p>
<p>常见应用：Ping</p>
<p>Ping 就是主动请求，获取到主动应答。但是 Ping 是在原生的 ICMP 中添加了自定义格式区域。例如 Ping 中放了发送的请求时间，以此计算出路程。所以，其实在 Ping 的报文中会加入序号，以用来区分数据包，从而提高计算时间或者路程的准确性。</p>
<h2 id="差错报文"><a href="#差错报文" class="headerlink" title="差错报文"></a>差错报文</h2><p>主要有以下几种：</p>
<ol>
<li><p>源抑制<br>发送端发送大量数据时，可能会导致网络( 路由器 )过载，此时过载处可以向发送端发送源抑制的消息，让他降低发送速度。</p>
</li>
<li><p>终点不可到达<br>网络信息不能到达终点，就会给发送端发送一个目的不可到达的信息。告诉发送端可能是设备故障而引起关闭（情况之一）。然后这种又可以再次细分：<br>A、网络不可达 — 代码为 0，<br>B、主机不可达 — 代码为 1.<br>C、协议不可达 — 代码为 2.<br>D、端口不可达 — 代码为 3.<br>E、需要分段 - 代码为 4.（ 必须把数据分段才能去到终点 ）</p>
</li>
<li><p>超时<br>网络包超过设置的在网络中的生存时间，还没有达到。</p>
</li>
<li><p>路由重定向<br>定义数据包的路由股则。因为大部分的时候，路由规则是通过相关协议算法生成的，有些时候重新定义过之后，会让这个数据包绕的更远。</p>
</li>
</ol>
<blockquote>
<p>常见应用：Traceroute<br>Traceoute 有点像是在不断试错的意思。是用来侦测主机到目的主机之间所经路由情况的重要工具。Ping 我们知道是可以知道这条大路通不通的，Traceoute 通过设置 TTL 知道到底是哪个路由器不通。<br>TTL : 数据包在网络中生存时间，也就是通过数据被路由器转发的次数，没转发一次就减一。知道为 0 的时候就抛弃。<br>Traceroute 的原理：它收到目的主机的 IP 后，首先给目的主机发送一个 TTL=1 的 UDP 数据包，而经过的第一个路由器收到这个数据包以后，就自动把 TTL 减 1，而 TTL 变为 0 以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的 ICMP 数据报给主机。如此循环就可以知道所有的路由 IP 了。（ ICMP 出错了就会回错误包 ）</p>
</blockquote>
<p>通常 Traceoute 的目的端口设置的是一个大于 30000 的值（ 一般的应用端口号远小于这个数 ）。所以如果回复的是 “端口不可达”，那就说明到达终点，否则这个信息就会超时。以此确保 消息是否到达终点。</p>
<p>Traceoute 还有一个有意思的功能，就是确定 MTU（数据最大传输单元），Traceoute 通常对数据不分段，就直接发送，如果如果遇到过程中某个路由转发，出现返回 ICMP 需要分段的错误，就把数据进行拆分，直到最后到达终点。就验证出 MTU。</p>
<p>ICMP 其实还有很多意思的地方，这边就简单的介绍到这里。<br>附表：<br><img src="https://upload-images.jianshu.io/upload_images/12814988-660f2b1948e6e6c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1006/format/webp" alt="ICMP"></p>
<p>作者：FutureEye<br>链接：<a href="https://www.jianshu.com/p/e1795962ad76" target="_blank" rel="noopener">https://www.jianshu.com/p/e1795962ad76</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <tags>
        <tag>Computer Networking</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread and locking</title>
    <url>/2020/01/01/Thread%20and%20locking/</url>
    <content><![CDATA[<h3 id="Threads-and-Locking"><a href="#Threads-and-Locking" class="headerlink" title="Threads and Locking"></a>Threads and Locking</h3><p>题目来源<a href="https://pdos.csail.mit.edu/6.828/2018/homework/lock.html" target="_blank" rel="noopener">Threads and Locking</a><br>本次作业主要讲的是并行作业，以及并行作业中互斥锁（P,V问题）的相关知识。</p>
<a id="more"></a>
<p><a href="https://pdos.csail.mit.edu/6.828/2018/homework/ph.c" target="_blank" rel="noopener">ph.c源码</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -g -O2 ph.c -pthread</span><br><span class="line">./a.out <span class="number">1</span></span><br><span class="line">./a.out <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>代码首先创建了10000个小的node，用每一个node（在代码中名字是entry）来表示一个线程（这里涉及C++链表的内容），然后通过平均分配的方法来把这些线程分配给各个进程。</li>
<li>put函数用来将每一个线程加入链表。然后将这个node的对应信息记录到哈希表：struct entry *table[NBUCKET]中。</li>
<li>get函数通过反哈希的方式得到一个node（也就是一个线程）。同时这也表示这次线程的结束。</li>
</ul>
<p>这样不断通过put 和get来实现并行程序。</p>
<blockquote>
<p>产生错误的原因：当我们在使用put函数的时候，不小心造成两个新的node同时插入链表时（也就是同时使用内存），我们的哈希表只能记录下其中的一个表头，而失去了另外一个node的表头，所以造成了get的时候丢失了node。</p>
</blockquote>
<blockquote>
<p>为了避免这样的错误产生，我们仅仅需要在put的时候加入互斥锁即可：</p>
</blockquote>
<p>1)编译ph.c源文件，并分别以单线程和双线程运行，查看结果<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os/thread1" alt></p>
<blockquote>
<p>每个线程分两个阶段(<code>phases</code>)运行。在第一个阶段，每个线程将<code>NKEYS/nthread keys</code>放入<code>the hash table</code>。<br>在第二阶段，每个线程从散列表中获取<code>NKEYS</code>。<code>print</code>语句告诉你每个阶段为每个线程花费了多长时间。 倒数第二行会告诉你有多少个key丢失了，底部的<code>completion time</code>告诉你应用程序的总运行时间。</p>
</blockquote>
<blockquote>
<p><code>ph.c</code>程序主要工作是使用随机数生成10000个<code>keys</code>，然后利用线性<code>hash</code>将其插入5个哈希槽中，最后再取出每<br>个key。</p>
</blockquote>
<p>2)pthread_mutex_t bucket_locks[NBUCKET];//声明锁变量数组:</p>
<p>3)在main()函数中初始锁变量数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i &lt; NBUCKET;i++)&#123;</span><br><span class="line">	pthread_mutex_init(&amp;bucket_locks[i],<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4)修改put函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;bucket_locks[i]);</span><br><span class="line">  insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  pthread_mutex_unlock(&amp;bucket_locks[i]);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>5)再次编译ph.c,并分别以单线程和双线程运行,查看结果<br>gcc -g -O2 ph.c -pthread<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os/thread3" alt><br>0 keys missing<br>结果可能存在偏差。<br><a href="https://blog.csdn.net/a747979985/article/details/97250404" target="_blank" rel="noopener">这篇文章讲的更详细</a></p>
]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>对5个数进行排序最少需要多少次</title>
    <url>/2020/01/01/%E5%AF%B95%E4%B8%AA%E6%95%B0%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E6%9C%80%E5%B0%91%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E6%AC%A1/</url>
    <content><![CDATA[<h2 id="对五个数排序最少需要7次"><a href="#对五个数排序最少需要7次" class="headerlink" title="对五个数排序最少需要7次."></a>对五个数排序最少需要7次.</h2><p>今个儿,算法老师上课给我们出的一道题,老师只是告诉我们7次,也没说具体怎么个过程.<br>上网查了查也是看懂了吧<br>本文介绍一个对5个数进行排序的方法，仅使用7次比较。假设要排序的数为a,b,c,d,e。</p>
<blockquote>
<p>首先将a,b进行比较，假设结果为a&lt;b，再将c,d进行比较，假设结果为c&lt;d；然后将两组数的较大者进行比较（即比较b,d），假设结果为b&lt;d，于是就有下面的关系，箭头的关系表示“&lt;”，即”小于”，至此，已经进行了三次比较。</p>
</blockquote>
<p>即:a&lt;b&lt;d,c&lt;d</p>
<blockquote>
<p>  现在将e插入到{a,b,d}的适当位置，采用二分查找法寻找查找位置时，只需要两次比较——先同b比较，然后再同a或d比较。将e插入到{a,b,d}时,一共有四种情况</p>
</blockquote>
<p>e&lt;a&lt;b&lt;d,<br>a&lt;e&lt;b&lt;d,<br>a&lt;b&lt;e&lt;d,<br>a&lt;b&lt;d&lt;e,<br>c&lt;d</p>
<blockquote>
<p> 在这四中情况中，要将c插入到由[abcd]组成的序列中最多只需要两次比较。同样使用二分法寻找插入位置。以第一种情况为例：c首先同a比较，如果大于a，再同b比较，如果大于b，则不会再同d比较，因为我们在之前已经知道c&lt;d。</p>
</blockquote>
<p>所以 3 + 2 + 2 = 7,一共是7次比较</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络の摘要</title>
    <url>/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%81%AE%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<p>计网马上要考试了,之前从头看了遍网课,整理了点知识点和习题. 挑挑拣拣选一些考纲上的内容也来一个<br><strong>一天一遍,预防失眠</strong>(yjn_语录)</p>
<a id="more"></a>
<h3 id="摘要部分"><a href="#摘要部分" class="headerlink" title="摘要部分"></a>摘要部分</h3><ol>
<li><p>在TCP协议中，某数据包的确认包丢失也不一定导致发送方重传该数据包 √</p>
</li>
<li><p>传输层用进程编号（PID）来标示主机间通信的应用进程        × port</p>
</li>
<li><p>客户使用SMTP协议既能发送邮件又能接收邮件                × POP3接收邮件</p>
</li>
<li><p>某种网络安全威胁是通过非法手段取得对数据的使用权，并对数据进行恶意地添加和修改，这种安全威胁属于<strong>B__</strong><br>A、窃听数据 B、破坏数据完整性<br>C、拒绝服务 D、物理安全威胁</p>
</li>
<li><p>如要将138.10.0.0 网络分为6个子网，则子网掩码应设为（D）<br>A、255.0.0.0 B、255.255.0.0<br>C、255.255.128.0 D、255.255.224.0</p>
<blockquote>
<p>6个子网需要3个子网位,因为2^3=8 所以子网掩码是255.255.1110.0000,即255.255.224.0</p>
</blockquote>
</li>
<li><ol>
<li>下面有关网络互连设备说法正确的有（ABCD）<br>A、在物理层实现网络互连的主要设备有中继器和HUB。<br>B、在数据链路层实现网络互联的主要设备有二层交换机和网桥。<br>C、在网络层实现网络互连的主要设备有三层交换机和路由器。<br>D、在传输层（包括传输层）以上实现网络互连的设备有网关。</li>
</ol>
</li>
<li><p>试简述TCP协议在数据传输过程中收发双方是如何保证数据包的可靠性的。</p>
<blockquote>
<p>（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区； （1分）<br>（2）并为每个已发送的数据包启动一个超时定时器；（1分）<br>（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;（1分）<br>（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。（1分）<br>（5）接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。（1分）</p>
</blockquote>
</li>
<li><p>假设有五个IP地址A：131.107.256.80，B：231.222.0.11，C：126.1.0.0，D：198.121.254.255，E：202.117.34.32，找出不能分配给主机的IP地址，并说明原因。</p>
<blockquote>
<p>(1）A的第三个数256大于255是非法值，不能用于主机地址；（1分）<br>（2）B的第一个数231是保留给组播的地址，不能用于主机地址；（1分）<br>（3）C以全0结尾的IP地址是网络地址，不能用于主机地址；（1分）<br>（4）D以全1结尾的IP地址是广播地址，不能用于主机地址。（2分）</p>
</blockquote>
</li>
<li><p>为什么说TCP协议中针对某数据包的应答包丢失也不一定导致该数据包重传？<br>（1）由于TCP协议采用的是面向字符流的累计确认机制；（2分）<br>（2）当某数据包的应答丢失时，只要接收方还有数据发给发送方，在其应答字段中将包含对前面收到的数据包的应答信息，所以发送方不需要重发该数据包。（3分）<br><a href="https://zhidao.baidu.com/question/241652922.html?qbl=relate_question_0&word=TCP%D0%AD%D2%E9%D6%D0%D5%EB%B6%D4%C4%B3%CA%FD%BE%DD%B0%FC%B5%C4%D3%A6%B4%F0%B0%FC%B6%AA%CA%A7%D2%B2%B2%BB%D2%BB%B6%A8%B5%BC%D6%C2%B8%C3%CA%FD%BE%DD%B0%FC%D6%D8%B4%AB" target="_blank" rel="noopener">click</a></p>
</li>
<li><p>占据两个山顶的红军1与红军2与驻扎在这两个山之间的白军作战。其力量对比是:红军1或红军2打不赢白军，但红军1和红军2协同作战可战胜白军。红军1拟于次日凌晨6点向白军发起攻击，于是给红军2发送电文，但通信线路很不好，电文出错或丢失的可能性较大，因此要求收到电文的红军2必须送回一个确认电文，但确认电文也可能出错或丢失。试问能否设计出一种协议使得红军能够实现协同作战，因而100%的取得胜利？<br>答：</p>
<blockquote>
<p>（1）采用三次握手的方式；（2分）<br>（2）红军1给红军2发送电文，决定次日凌晨6点向白军发起攻击，请求红军2协同作战，并等待红军2的应答，如果在规定时间内没有收到应答，则重发请求；（3分）<br>（3）红军2如果收到红军1的作战报文后，则回送一个响应报文，表明已知道次日凌晨6点向白军发起攻击且愿意协同作战，并等待红军1的确认，如果在规定时间内没有收到确认报文，则重发响应报文；（3分）<br>（4）红军1收到红军2的响应报文，再向红军2发送一个确认报文，并表明已知道红军2将协同作战。（2分）</p>
</blockquote>
</li>
<li><p>学生A希望访问网站<code>www.sina.com</code>，A在其浏览器中输入<a href="http://www.sina.com并按回车，直到新浪的网站首页显示在其浏览器中，请问：在此过程中，按照TCP/IP参考模型，从应用层到网络层都用到了哪些协议？" target="_blank" rel="noopener">http://www.sina.com并按回车，直到新浪的网站首页显示在其浏览器中，请问：在此过程中，按照TCP/IP参考模型，从应用层到网络层都用到了哪些协议？</a><br>答：</p>
<blockquote>
<p>（1）应用层：HTTP：WWW访问协议，DNS：域名解析；（3分）<br>（2）传输层：TCP：在客户和服务器之间建立连接，提供可靠的数据传输；（4分）<br>（3）网络层：IP：IP包传输和路由选择，ICMP：提供网络传输中的差错检测，ARP：将本机的缺省网关IP地址映射成物理MAC地址。（4分）</p>
</blockquote>
</li>
<li><p>目前实际存在与使用的广域网基本都采用（D）。<br>A)总线拓扑 B)环状拓扑   C)星状拓扑 D)网状拓扑 </p>
</li>
<li><p>下列IP地址中属于B类IP地址的是（B）。<br>A) 200.126.32.50 B) 191.23.56.89 C) 192.168.0.1 D) 126.45.33.9</p>
<blockquote>
<p>A类IP地址 地址范围从1.0.0.1到127.255.255.254  子网掩码为255.0.0.0<br>B类IP地址地址范围从128.0.0.1-191.255.255.254   子网掩码为255.255.0.0<br>C类IP地址范围从192.0.0.1-223.255.255.254      子网掩码为255.255.255.0<br>私有地址范围:<br>A类地址：10.0.0.0～10.255.255.255<br>B类地址：172.16.0.0～172.31.255.255<br>C类地址：192.168.0.0～192.168.255.255<br>回送地址：127.0.0.1。 也是本机地址，等效于localhost或本机IP。</p>
</blockquote>
</li>
<li><p>在总线型局域网的介质访问控制方法中，采用“先听后发，边听边发，冲突停止，随机延迟后重发”的是（A）<br>A)CSMA/CD B)TokenBus C)TokenRing D)FDDI</p>
<blockquote>
<p>[解析] CSMA/CD的发送流程可以简单地概括为先听后发、边听边发、冲突停止、随机延迟后重发。<br>采用CSMA/CD介质访问控制方法的总线型局域网在发送数据前，先监听总线是否空闲。<br>若总线忙，则不发送：若总线空闲，则把准备好的数据发送到总线上。<br>在发送数据的过程中，工作站边发送边检测总线，是否自己发送的数据有冲突。<br>若无冲突则继续发送直到发完全部数据；若有冲突，则立即停止发送数据，但是要发送一个加强冲突的信号，以便使网络上所有工作站都知道网上发生了冲突，<br>然后，等待一个预定的随机时间，且在总线为空闲时，再重新发送未发完的数据。</p>
</blockquote>
</li>
<li><p>(ARP)是将IP地址映射成物理地址，而(TCP/IP)的主要目的是把资源名称解析成IP地址。 </p>
</li>
<li><p>网络安全的威胁因素有很多，其中人为的威胁因素类型有中断、窃取、更改和伪造。（√） </p>
</li>
</ol>
<ol start="17">
<li>网络安全的特性。 </li>
</ol>
<ul>
<li>保密性：信息不泄露给非授权用户、实体或过程，或供其利用的特性。</li>
<li>(数据)完整性：数据未经授权不能进行改变的特性。即信息在存储或传输过程中保持不被修改、不被破坏和丢失的特性。</li>
<li>可用性：可被授权实体访问并按需求使用的特性。即当需要时能否存取所需的信息。例如网络环境下拒绝服务、破坏网络和有关系统的正常运行等都属于对可用性的攻击；</li>
<li>可控性：对信息的传播及内容具有控制能力。</li>
</ul>
<ol start="17">
<li><p>计算机网络需要哪几方面的安全性？</p>
<blockquote>
<p>答案：<br>(1)保密性：计算机中的信息只能由授予访问权限的用户读取(包括显示、打印等，也包含暴露信息存在的事实)。<br>(2)数据完整性：计算机系统中的信息资源只能被授予权限的用户修改。<br>(3)可利用性：具有访问权限的用户在需要时可以利用计算机系统中的信息资源，得到密文。</p>
</blockquote>
</li>
<li><p>网络上两个进程之间进行通信需要用一个五元组来标识：(本机主机地址,本机端口号,协议,远程主机地址,远程端口号)</p>
</li>
<li><p>下列媒体访问协议中没有冲突的协议是(D)<br>A、1-支持CSMA B、ALOHA C、CSMA/CD D、TOKEN RING (令牌环网)</p>
</li>
<li><p>试简述主机1（IP地址为192.168.25.1，MAC地址为 E1）向主机2（IP地址为192.168.25.2，MAC地址为E2）发送数据时ARP 协议的工作过程（主机1、主机2在同一个子网内）。</p>
<blockquote>
<p>答：<br>（1）当主机1要向主机2发送数据时，必须知道主机2的MAC地址，为此，先根据主机2的IP地址在本机的ARP缓冲表内查找，如找到E2，则把E2填到MAC帧中，并把数据发送给主机2；<br>（2）如果在本机的ARP缓冲表内找不到主机2的MAC地址，则主机1产生一个ARP询问包，其中包含主机1的IP地址，MAC地址E1，主机2的IP地址，并广播到网络上询问有谁知道主机2的MAC地址？<br>（3）主机2收到ARP询问包后，根据询问者的IP和MAC地址E1立即向主机1回送一个ARP响应包，其中包含主机1的IP地址，MAC地址E1，主机2的IP地址和MAC地址E2，从而主机1获得了主机2的MAC地址E2，进而可向主机2发送数据。<br>3、设某网络在某一时刻的结构如下图所示，试用L-S路由算法为节点C计算到各节点的路由表（包括目的地、下一站、最小代价）。</p>
</blockquote>
</li>
<li><p>在某网络应用系统中，计算机A( IP地址为 192.168.25.168 , MAC地址为00：11：22：33：44：55)需要知道目前本网络内有多少台计算机在联网，其IP地址分别为多少，试运用所学的网络原理，说明解决此问题的方案（要求说明所采用的网络原理以及解决该问题的工作过程）。（本题10分）</p>
<blockquote>
<p>答：<br>（1）采用ICMP 请求应答报文（echo）；（1分）<br>（2）计算机A从IP地址192.168.25.1 到 192.168.25.254 做以下工作；（2分）<br>（3）构造一个ICMP请求应答报文，分别发给上述IP地址；（3分）<br>（4）如果能收到某IP有响应包，说明该IP对应的计算机已联网。（4分）</p>
</blockquote>
</li>
<li><p>将某C 网 192.168.118.0 划分成4个子网，请计算出每个子网的有效的主机IP地址范围和对应的网络掩码（掩码用2进制表示） 。（10分）（答案只要符合题目需求就可给满分，下面只是参考答案之一。）</p>
<blockquote>
<p>解：<br>（1）子网1的有效IP地址范围为： 192.168.118.1 — 192.168.118.63     (2分)</p>
<pre><code>（00 00 0001-00 11 1110）</code></pre><p>子网1的网络掩码为：11111111.11111111.11111111.11000000          (2分)<br>（2）子网2的有效IP地址范围为： 192.168.118.65 — 192.168.118.126   (2分)</p>
<pre><code>（01 00 0001-01 11 1110）</code></pre><p>子网2的网络掩码为：11111111.11111111.11111111.11000000<br>（3）子网3的有效IP地址范围为： 192.168.118.129 — 192.168.118.190  (2分)</p>
<pre><code>（10 00 0001-10 11 1110）</code></pre><p>子网3的网络掩码为：11111111.11111111.11111111.11000000<br>（4）子网4的有效IP地址范围为： 192.168.118.193 — 192.168.118.254  (2分)</p>
<pre><code>（11 00 0001-11 11 1110）</code></pre><p>子网4的网络掩码为：11111111.11111111.11111111.11000000</p>
</blockquote>
</li>
<li><p>假设要设计一个网络应用程序，用来测试从本机到互联网上任意一台主机是否连通，如果不通，还 要知道在哪个路由器不通，并了解中间需要经过哪些路由器（或网关）及从本机到这些路由器的时延有多长，请你根据所学的网络原理（要求先简述该网络原理）， 简要说明如何实现该应用程序。（15分）</p>
<blockquote>
<p>答：<br>（1）根据IP协议的规定，在每一个IP包中有一个TTL字段，标示该IP包剩余的生命周期（如开始时为128），IP包经过某一个路由器时，将IP包中的TTL值减1，当变为0时，该路由器将丢弃该IP包，并通过ICMP协议向发该IP包的源主机报告丢弃的原因（其中包括原因即TTL=0，丢弃的路由器IP，丢弃的时间等信息）；<br>（2）第一次让应用程序向目的主机发送一个TTL=1的ICMP 包，达到第一个路由器后，由于TTL将会变为0，该ICMP包被丢弃，故第一个路由器将源主机报告丢弃的原因，从而得知该路由器的IP地址和时延；<br>（3）同理，第N次让应用程序向目的主机发送一个TTL=N的ICMP 包，达到第N个路由器后，由于TTL将会变为0，该ICMP包被丢弃，故第N个路由器将源主机报告丢弃的原因，从而得知该路由器的IP地址和时延；<br>（4）直到到达目的主机（假如到达目的主机需要经过M个路由器）或无法到达目的主机（通过M个路由器)。</p>
</blockquote>
</li>
<li><p>设有两台主机的IP地址分别：195.248.8.145，195.248.9.220子网掩码都是255.255.255.0。判断这两个主机能否直接通信。如果不能直接通信，可以采用何种方法？并进行详细说明。</p>
<blockquote>
<p>（1）根据两主机的IP地址和子网掩码可以判断两主机不在同一个网络，所以不能直接通信。<br>（2）采用的方法：<br>1、用路由连接两个网络。由路由器来实现数据包从一个网络到另一个网络的转发，使这两台主机可以通信。<br>2.、将子网掩码改为255.255.240.0这样两主机就处于同一个网络中，即网络号相同，这样就能直接通信。</p>
</blockquote>
</li>
<li><p>简答分组交换的特点和不足。</p>
<blockquote>
<p>答案：（1）节点暂时存储的是一个个分组，而不是整个数据文件（2）分组暂时保存在节点的内存中，保证了较高的交换速率（3）动态分配信道，极大的提高了通信线路的利用率缺点：（4）分组在节点转发时因排队而造成一定的延时（5）分组必须携带一些控制信息而产生额外开销，管理控制比较困难</p>
</blockquote>
</li>
<li><p>简述在数据传输中，防止阻塞产生的办法</p>
<blockquote>
<p>答案：（1）通过对点对点的同步控制，使计算机之间的收发数据速率同步（2）控制网络的输入，避免突然大量数据报文提交（3）接收工作站在接收数据报文之前，保留足够的缓冲空间</p>
</blockquote>
</li>
<li><p>什么是路由？简述路由器的主要功能。<br>答：路由指的是从本地到网络的各个地方应该走的路径，由路由器根据目的地址将数据帧转发到不同的路径。选择最佳的转发数据的路径，建立非常灵活的联接，均衡网络负载；利用通信协议本身的流量控制功能来控制数据传输，有效解决拥挤问题；具有判断需要转发的数据分组的功能；把一个大的网络划分成若干个子网。</p>
</li>
<li><p>试说明IP地址与物理地址的区别。为什么要使用这两种不同的地址</p>
<blockquote>
<p>答：IP地址（Internet Protocol Address） 用于确定因特网上的每台主机，它是每台主机唯一性的标识。联网设备用物理地址标识自己，例如网卡地址。<br>TCP／IP用IP地址来标识源地址和目标地址，但源和目标主机却位于某个网络中，故源地址和目标地址都由网络号和主机号组成，但这种标号只是一种逻辑编号，而不是路由器和计算机网卡的物理地址。对于一台计算机而言，IP地址是可变的，而物理地址是固定的。</p>
</blockquote>
</li>
<li><p>（1）子网掩码为255.255.255.0代表什么意思？<br>（2）某网络的现在掩码为255.255.255.248，问该网络能够连接多少个主机？<br>（3）某A类网络和某B类网络的子网号subnet-id分别为16个1和8个1，问这两个网络的子网掩码有何不同？<br>（4）某A类网络的子网掩码为255.255.0.255，它是否是一个有效的子网掩码？</p>
<blockquote>
<p>答：（1）255.255.255.0可代表C类地址对应的子网掩码默认值；也可代表A类或B类地址的掩码，即主机号由最后8bit决定，而路由器寻找网络由前24bit决定。<br>（2）248=（11111000）2，即IP地址中前29位代表网络，后3位代表主机。所以共有主机数=23=8，但由于其中主机号全0代表该网络的网络地址，主机号全1代表该网络的广播地址，均不能分配给连网主机使用，所以网络能够连接的主机数=23-2=6台。<br>（3）这两个网络的子网掩码是一样的，均为255.255.255.0，但子网数不同，子网号为16bit的A类网络的子网数有216-2个，而子网号为8bit的B类网络的子网数有28-2个。<br>（4）有效，因RFC文档中没有规定子网掩码中的一串1必须是连续的，但不建议这样使用。</p>
</blockquote>
</li>
<li><p>与静态路由协议相比，动态路由有哪些优点？ ．（ AB ）<br>A、带宽占用少<br>B、简单<br>C、路由器能自动发现网络拓扑变化<br>D、路由器能自动计算新的路由</p>
</li>
<li><p>为什么要把IP地址解析成MAC地址才能实现数据传输？怎样进行地址解析？</p>
</li>
</ol>
<blockquote>
<p>（1）发送数据时，数据从高层到低层封装，然后才到通信链路上传输，使用IP地址的IP数据报一旦交给了数据链路层，就被封装成MAC帧。MAC帧在传送时使用的源地址和目的地址都是硬件地址（MAC地址），这两个硬件地址都写在MAC帧的首部中。<br>（2）连接在通信链路上的设备（主机或路由器）在接收MAC帧时，根据MAC帧首部中的MAC地址来决定接收或放弃。因此要把IP地址解析成MAC地址才能实现数据在链路层的封装，进而实现数据传输。<br>（3）每个主机或路由器接口都有一个ARP缓存用来完成IP地址到MAC地址的解析，在进行链路层封装时接口会查询该缓存，来实现解析。如果在缓存表中找不到所查询的IP地址对应的MAC地址，接口会向该局域网发送    ARP查询广播包，对应IP地址的接口收到该ARP查询，会向源地址发送ARP应答单播包，从而完成ARP解析。</p>
</blockquote>
<ol start="32">
<li><p>考虑某路由器具有下列路由表项：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">网络前缀	               下一跳</span><br><span class="line"><span class="number">142.150</span><span class="number">.64</span><span class="number">.0</span>/<span class="number">24</span> 	 A</span><br><span class="line"><span class="number">142.150</span><span class="number">.71</span><span class="number">.128</span>/<span class="number">28</span>        B</span><br><span class="line"><span class="number">142.150</span><span class="number">.71</span><span class="number">.128</span>/<span class="number">30</span>	 C</span><br><span class="line"><span class="number">142.150</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span>	         D</span><br></pre></td></tr></table></figure>
<p>（1）假设路由器接收到一个目的地址为142.150.71.132的IP分组，请确定该路由器为该IP分组选择的下一跳，并解释说明。<br>（2）在上面的路由表中增加一条路由表项，该路由表项使以142.150.71.132为目的地址的IP分组选择“A”作为下一跳，而不影响其他目的地址的IP分组转发。<br>（3）在上面的路由表中增加一条路由表项，使所有目的地址与该路由表中的任何路由表项都不匹配的IP分组被转发到下一跳“E”。<br>(4) 将142.150.64.0/24划分为4个规模尽可能大的等长子网，给出子网掩码及每个子网的可分配地址范围。</p>
<blockquote>
<p>(1)下一跳为B，因为该IP地址只和路由 142.150.71.128/28|B匹配。<br>（2）即增加一条主机路由 142.150.71.132/32|A<br>（3）即增加一条默认路由0.0.0.0/0|E<br>（4）255.255.255.192<br>范围:<br><code>142.150.64.1——142.150.64.62</code><br><code>142.150.64.65——142.150.64.126</code><br><code>142.150.64.129——142.150.64.190</code><br><code>142.150.64.193——142.150.64.254</code></p>
</blockquote>
</li>
<li><p>三种计算机分组交换方式比较</p>
<blockquote>
<p>a)    电路交换（Circuit Switching）－整个报文的比特流连续地从源点直达终点，好像在一个管道中传输；在通话的全部时间内，通话的两个用户始终占用端到端的通信资源，所以资源利用率低<br>b)    报文交换（Message Switching）－整个报文传送到相邻节点，全部存储下来后查找转发表，转发到下一个节点；通信线路利用率高、出错后纠错效率高等优点，被计算机与通信界广泛采用。存储转发是该技术的核心。<br>c)    分组（包）交换（Packet Switching）－单个分组（只是整个报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一个节点；<br>的优点<br>高效    动态分配传输带宽，对通信链路是逐段占用。<br>灵活    以分组为传送单位和查找路由。<br>迅速    不必先建立连接就能向其他主机发送分组。<br>可靠    保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。 </p>
</blockquote>
</li>
<li><p>arp的四种使用情况：</p>
<blockquote>
<p>1)发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。<br>2)发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。<br>3)发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。<br>4)发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</p>
</blockquote>
</li>
<li><p>RIP OSPF工作原理的理解与比较区别?</p>
</li>
</ol>
<ul>
<li>RIP工作原理：路由信息协议 RIP 是内部网关协议 IGP中最先得到广泛使用的协议。<ul>
<li>RIP 是一种分布式的基于距离向量的路由选择协议。</li>
<li>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。</li>
</ul>
</li>
<li>OSPF的特征：最主要的特征是分布式的链路状态协议，而不是距离向量协议。<ul>
<li>所有的路由器都维护一个链路状态数据库（路由器到子网的链路状态和可以到达的邻居路由器）。 </li>
<li>当网络中链路状态改变时，通过洪泛法（flooding）方法把更新的本地链路状态信息广播到区域或自治系统中的每个路由器。</li>
<li>每一个路由器用链路状态数据库中的数据，计算出到每个目的地最短路径。</li>
</ul>
</li>
<li>比较区别：<ul>
<li>SPF：只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。RIP：不管网络拓扑有无发生变化，路由器之间都要定期交换路由表信息</li>
</ul>
</li>
<li>与RIP相比<ul>
<li>1.OSPF 规定每隔一段时间，如 30分钟，要刷新一次数据库中的链路状态。 </li>
<li>2.由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。 </li>
<li>3.OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于 100 ms。</li>
<li>4.指定的路由器:多点接入的局域网采用了指定的路由器的方法，使广播的信息量大大减少。指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。</li>
</ul>
</li>
</ul>
<ol start="36">
<li>假定在地球和一个新月亮之间建立一条100M 位/秒的链路。从该月亮到地球的距离大约是385000 公里，数据在链路上以光速3×10^8米/秒传输。</li>
</ol>
<ul>
<li>（a） 计算该链路的最小RTT。<br>解：最小RTT 等于2×385000000 米÷（3×10^8米/秒）=2.57 秒</li>
<li>（b） 使用RTT 作为延迟，计算该链路的“延迟×带宽”值。<br>解：“延迟×带宽”值等于2.57 秒×100M 位/秒=257M 位≈32M 字节</li>
<li>（c） 在（b）中计算的“延迟×带宽”值的含义是什么？<br>解：它表示发送方在收到一个响应之前能够发送的数据量。</li>
<li>（d） 在月亮上用一个照相机拍取地球的相片，并把它们以数字形式保存到磁盘上。<br>假定在地球上的任务控制要下载25M 字节的最新图象，那么，从发出数据请求<br>到传送结束最少要化多少时间？<br>解：在图象可以开始到达地面之前，至少需要一个RTT。假定仅有带宽延迟，那么发送需要<br>的时间等于25M 字节÷100M 位/秒=200M 位÷100M 位/秒=2 秒。所以，直到最后一个图象位到达地球，总共化的时间等于2.0+2.57=4.57 秒。</li>
</ul>
<ol start="37">
<li><p>在因特网上的一个B 类网络具有子网掩码255.255.240.0。问每个子网中的最大主<br>机数目是多少？</p>
<blockquote>
<p>解答：对于一个B 类网络，高端16 位形成网络号，低端16 位是子网或主机域。在子网掩码的低端16 位<br>中，最高有效4 位是1111，因此剩下12 位（第3 字节低4 位和第4 字节）用于主机号。因此，存在4096<br>个主机地址，但由于全零和全1 是特别地址，因此最大主机数目应该是4094。</p>
</blockquote>
</li>
<li><p>假定TCP 使用两次握手替代三次握手来建立连接。也就是说，不需要第三个报文。那么<br>现在是否可能产生死锁？请给出例子来说明你的答案。<br>解答：我们知道，3 次握手完成两个重要功能，既要双方做好发送数据的准备工作（双方都<br>知道彼此已准备好），也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发<br>送与确认。<br>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机A<br>和B 之间的通信。假定B 给A 发送一个连接请求分组，A 收到了这个分组，并发送了确认<br>应答分组。按照两次握手的协定，A 认为连接已经成功地建立了，可以开始发送数据分组。<br>可是，B 在A 的应答分组在传输中被丢失的情况下，将不知道A 是否已准备好，不知道A<br>建议什么样的序列号用于A 到B 的交通，也不知道A 是否同意B 所建议的用于B 到A 交<br>通的初始序列号，B 甚至怀疑A 是否收到自己的连接请求分组。在这种情况下，B 认为连<br>接还未建立成功，将忽略A 发来的任何数据分组，只等待接收连接确认应答分组。而A 在<br>发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
</li>
<li><p><strong>试简述CSMA/CD协议的工作原理</strong>(重点)</p>
<blockquote>
<p>答： CSMA/CD协议即载波监听，多点接入，碰撞检测。（2分）<br>首先，每个站点发送数据之前必须侦听信道的忙、闲状态。如果信道空闲，立即发送数据，同时进行冲突检测；如果信道忙，站点继续侦听总线，直到信道变成空闲。（2分）<br>如果在数据发送过程中检测到冲突，将立即停止发送数据并等待一段随机长的时间，然后重复上述过程。（1分）<br>即：先听后发，边听边发；冲突检测，延时重发。（1分）</p>
</blockquote>
</li>
<li><p>一个Web页面请求全过程？<br>从键入<a href="http://www.google.com到浏览器显示网页经历了一系列的事件" target="_blank" rel="noopener">www.google.com到浏览器显示网页经历了一系列的事件</a></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.首先需要利用DNS域名服务知道google服务器的<span class="built_in">IP</span>地址：主机的操作系统生成一个DNS域名查询  报文，采用UDP传输层协议，端口号<span class="number">53</span>，网络层将此报文封装上<span class="built_in">IP</span>头部信息，加上源<span class="built_in">IP</span>地址与目的<span class="built_in">IP</span>地址（即DNS服务器的<span class="built_in">IP</span>地址），数据链路层将数据报封装成链路层数据帧，并将其转发到网关路由器</span><br><span class="line">（通过ARP协议，链路层转发），网关路由器抽取DNS数据报的<span class="built_in">IP</span>地址，查询转发表，将其从某接口转发，最终到达DNS服务器，DNS服务器查询这个域名DNS源记录，并将包含google服务器的地址的DNS应答报文发送给主机，主机接收到后，提取出google服务器的<span class="built_in">IP</span>地址</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.主机得先与google服务器建立TCP连接：传输层得先创建TCP套接字，目的端口<span class="number">80</span>，目的<span class="built_in">IP</span>地址google服务器的地址，建立连接需要三次握手，主机发送SYN连接请求报文，google服务器收到后，分配缓存与变量，回复SYNACK报文，主机收到后，分配缓存与变量资源，回复ACK报文，并可以携带HTTP <span class="meta">GET</span>报文</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.主机发送HTTP <span class="meta">GET</span>报文：主机应用层生成HTTP <span class="meta">GET</span>报文，传递给TCP传输层，TCP协议给HTTP <span class="meta">GET</span>报文封装TCP头部信息，并交给<span class="built_in">IP</span>层，<span class="built_in">IP</span>层封装<span class="built_in">IP</span>头部信息称为数据报，再交给数据链路层封装成数据帧，通过ARP协议，进行链路层转发到网关路由器，网关路由器提取<span class="built_in">IP</span>地址，查询转发表，再转发到某借口，最终到达google服务器，服务器提取出HTTP <span class="meta">GET</span>报文，生成一个HTTP响应报文，将所请求的WEB页面放入HTTP响应体中，并通过TCP连接将此报文发送回主机，主机收到后，提取出HTTP 响应报文，从HTTP响应体中提取出HTML文件，最终显示出了WEB页面</span><br></pre></td></tr></table></figure></li>
<li><p>概述MAC地址与ARP协议？</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">每一个网络设备的适配器都有自己的链路层地址，<span class="keyword">MAC</span>地址，这个地址是自生产出来就是唯一的。数据链路层需要通过<span class="keyword">MAC</span>地址来转发数据帧来通过交换机网络</span><br><span class="line"></span><br><span class="line">ARP协议称为地址解析协议，提供了IP地址转换为链路层<span class="keyword">MAC</span>地址的机制</span><br><span class="line">IP地址相当于邮政地址，<span class="keyword">MAC</span>地址相当于身份证号</span><br><span class="line"></span><br><span class="line">ARP工作原理：</span><br><span class="line">每台主机或路由器都保存有一张ARP表，表中包含IP地址与<span class="keyword">MAC</span>地址的映射关系当表中有目的IP地址的信息时，就直接交给链路层进行发送</span><br><span class="line">如果表中还没有相关信息，则在本子网内发送ARP广播查询，若此IP目的节点收到后应回复一个ARP应答报文</span><br><span class="line">所以ARP是自适应的，自动建立的，即插即用的</span><br></pre></td></tr></table></figure></li>
<li><p>概述MAC协议？</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MAC</span>协议称为多路访问控制协议</span><br><span class="line">主要能分为三类：信道划分协议，随机接入协议，轮流协议</span><br><span class="line"></span><br><span class="line">信道划分协议</span><br><span class="line">主要分为时分多路复用（TDM），频分多路复用（FDM），码分多址（CDMA）</span><br><span class="line">相当于是为每一个可能使用的人预留了一段资源，每个人在自己分配的那段资源里传输数据，所以一定不会发生碰撞</span><br><span class="line">当某时刻用的人很多时，利用率高当某时刻用的人很少时，利用率低</span><br><span class="line">随机接入协议基本思想是：当用户有数据需要发送时，就直接发送，如果与其他人发生碰撞了，就等一个随机时延，再重新发送，直到没有碰撞发生，发送成功为止</span><br><span class="line">主要有时隙ALOHA，ALOHA，CSMA，CSMA/<span class="keyword">CD</span>协议</span><br><span class="line">时隙ALOHA将时间划分若干时隙，规定所有人只能在某一个时隙的起始点发送数据</span><br><span class="line">ALOHA则没有这个规定，所有人可以在任何时间发送数据时隙ALOHA的效率比ALOHA协议的效率要高一倍左右</span><br><span class="line">CSMA协议称为载波侦听多路访问，即发送数据之前先侦听信道，当没有人发送数据时，才发送数据</span><br><span class="line">CSMA/<span class="keyword">CD</span>协议称为带碰撞检测的载波侦听多路访问协议，在CSMA基础上加了碰撞检测，若检测到碰撞，则都立即停止发送，等一个随机时间后再次发送</span><br><span class="line"></span><br><span class="line">那么既然所有人都侦听了，为什么还会发生碰撞呢？原因是存在传播延迟。随机接入协议，当某时刻用的人少时，效率很高</span><br><span class="line">用的人多时，发生碰撞概率高，效率较低</span><br><span class="line">轮流协议</span><br><span class="line">按照一定的轮流规则，所有需要发送数据的人轮流发送数据，轮到谁就谁发。主要有</span><br><span class="line">轮询协议：主节点轮流通知每个节点，你可以发送数据了，如果你有数据，就发，没数据，就过缺点：带来额外的轮询消耗；如果主节点发生故障，则后果严重</span><br><span class="line">令牌传递：某种称为令牌的特殊帧在节点之间按特定次序传递，令牌传递到的节点才可以发送数据。</span><br><span class="line">缺点：同样带来消耗，某一节点发生故障也可能给整个信道带来奔溃。</span><br></pre></td></tr></table></figure></li>
<li><p>概述数据链路层的服务？</p>
<blockquote>
<p>基本服务：将网络层的数据报封装成数据帧，通过单一通信链路从一个节点传输到另一个节点<br>链路层的主体是在网络适配器上实现的<br>链路层信道主要分为两类，点对点链路（PPP），和广播链路</p>
</blockquote>
</li>
<li><p>概述路由算法？</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">链路状态路由算法（LS）</span><br><span class="line">全局式的路由选择算法</span><br><span class="line">每个节点有本网络所有的网络拓扑以及链路费用的全局信息运用迪杰斯特拉（Dijkstra）算法计算最短路由选择</span><br><span class="line">特点</span><br><span class="line">向网络上所有其他节点广播消息消息仅包括到邻居节点的费用 收敛速度较快</span><br><span class="line">存在震荡现象（当费用与通信量相关时）</span><br><span class="line">距离向量路由算法（DV）</span><br><span class="line">分布式的路由算则算法</span><br><span class="line">每个节点仅保存通往目的地的最短路径的下一跳，通过迭代的方式计算出路径选择</span><br><span class="line">每个节点从直接相连的邻居处获取信息，然后计算，若有变化，则将计算结果分发给直接相连的邻居</span><br><span class="line">每个节点直接检测到链路费用，更新路由信息，若变化，发送给所有直接的邻居</span><br><span class="line">特点</span><br><span class="line">分布式，迭代，异步的路由算法仅向直接相连的邻居交换信息</span><br><span class="line">每个节点仅保存通往目的地最短路径的下一跳收敛速度慢</span><br><span class="line">好消息传播快，坏消息传播慢</span><br><span class="line">存在无穷计数的问题，解决办法为毒性逆转，（如果A通往目的地的最短路径的下一跳是B，则当B 询问B通过A去目的地的最短路径时，A回复无穷大）</span><br><span class="line">层次路由选择</span><br><span class="line">将一个大规模网络分为多个自治系统（AS），每个自治系统内运行相同的路由算法，称为自治系统</span><br><span class="line"></span><br><span class="line">内部路由选择协议（如RIP，OSPF）</span><br><span class="line">两个自治系统AS之间的通信运行自治系统间路由选择协议（如BGP）</span><br><span class="line">RIP</span><br><span class="line">路由选择信息协议（Routing Information Protocol）</span><br><span class="line">基于距离向量路由算法（DV），定义跳数为其链路费用RIP被当做一个应用进程来实现，交换信息使用UDP RIP通常被用于小规模网络，下层ISP及公司网络 OSPF</span><br><span class="line">开放最短路优先协议（Open Shortest Path First） 基于链路状态路由算法（LS）</span><br><span class="line">当一条链路费用变化时，节点向网络中所有节点广播路由选择信息每个节点使用Dijkstra算法计算最低费用路径选择</span><br><span class="line">OSPF更复杂，也有很多优点： 安全</span><br><span class="line">可以有多条相同费用路径，当需要传递大量分组时，有多个选择，充分利用支持单播和多播路由</span><br><span class="line">OSPF支持在AS内部进一步分层</span><br><span class="line">BGP</span><br><span class="line">边界网关协议（Border Gateway Protocol）,自治系统间的路由选择协议eBGP，从邻居子网获取可达信息                           iBGP，向本子网内节点传递子网可达信息</span><br><span class="line">基于可达信息的路径，确定到达外部子网的好的路径</span><br></pre></td></tr></table></figure></li>
<li><p>概述NAT协议？</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">NAT</span>又称为网络地址转换，为本地私有网络提供合法<span class="built_in">IP</span>地址，连接到外部网络</span><br><span class="line"><span class="symbol">NAT</span>不仅能解决<span class="built_in">IP</span>地址不足的问题，而且能有效避免被攻击，隐藏和保护内部计算机NAT的转换方式主要有三种：</span><br><span class="line">静态转换：将私有网络的某<span class="built_in">IP</span>地址转换成特定的合法<span class="built_in">IP</span>地址，一对一静态转换</span><br><span class="line">动态转换：将私有网络的<span class="built_in">IP</span>地址转换成合法<span class="built_in">IP</span>地址时，是不确定的，可以随机转换成任意指定的合法<span class="built_in">IP</span>地址</span><br><span class="line">端口多路复用：将私有网络的<span class="built_in">IP</span>地址转换成合法<span class="built_in">IP</span>地址时，所有私有网络主机共享一个合法<span class="built_in">IP</span>地址，每个主机转换为端口号，进行外部网络的访问。</span><br></pre></td></tr></table></figure></li>
<li><p>概述DHCP协议？<br>DHCP协议又称为动态主机配置协议，DHCP允许主机自动获取IP地址<br>DHCP是一种客户端-服务器协议，在应用层实现，采用UDP<br>主机获取IP地址步骤：</p>
</li>
</ol>
<ul>
<li><ol>
<li>主机广播DHCP发现报文</li>
</ol>
</li>
<li><ol start="2">
<li>DHCP服务器回应ACK，并携带分配给它的IP地址，表示提供服务</li>
</ol>
</li>
<li><ol start="3">
<li>主机广播DHCP请求，表示我打算连接到你分配的IP地址，同时也相当于告诉其他DHCP服务器， 我已经打算连接到这个DHCP服务器的IP地址了，你们分配的IP地址可收回了</li>
</ol>
</li>
<li><ol start="4">
<li>DHCP服务器最后回复ACK报文</li>
</ol>
</li>
</ul>
<ol start="47">
<li>概述TCP协议？<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP协议是一种点对点的，面向连接的，全双工的服务的，面向字节流的，可靠的，具有拥塞控制的传输层协议</span><br><span class="line">点对点：TCP连接只能是一对一建立的</span><br><span class="line">面向连接：TCP协议在传输数据之前需要建立连接</span><br><span class="line">全双工服务：TCP连接建立之后，连接双方都可以同时向对方发送数据</span><br><span class="line">面向字节流的：TCP把数据看成无结构的，有序的字节流，TCP的序号是建立在字节流上而不是建立在报文段上</span><br><span class="line">可靠的：TCP采用确认重传机制，序号机制，定时器机制，快速重传，滑动窗口机制，流量控制等 来保证数据传输的可靠性</span><br><span class="line">拥塞控制：TCP采用慢启动，拥塞避免，快速恢复的机制来进行拥塞控制，共避免网络空间陷入拥塞</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>TCP报文头部<ul>
<li>源端口号：发送方进程端口号目的端口号：接收方进程端口号</li>
<li>序号：32比特，建立在字节流上的序号机制</li>
</ul>
<ul>
<li>确认号：32比特，确认号表示期望收到的下一字节的序号，与序号共同保证TCP的可靠传输首部长度：TCP首部长度，因为选项字段的存在，一般无选项头部长为20字节       URG：表示报文段中存在被发送方指示为紧急的数据。紧急数据由紧急数据指针指出ACK：确认标志位，表示首部的确认号有效</li>
<li>PSH：表示接收方应立即将接收的数据交付给上层。因为TCP接收方可能存在接收缓存，接收方可能在忙其他事情，可能等接收缓存满的时候，才会将数据交付给上层，PSH标志位表示接收方应立即将数据交付上层</li>
<li>RST：表示复位，用来异常的关闭连接，引发RST的原因主要有：提前关闭，请求超时，端口未打开，在一个已关闭的SOCKET接收到数据</li>
<li>SYN：建立TCP连接时的标志位FIN：关闭TCP连接时的标志位</li>
<li>接收窗口：表示接收方还有多少缓存供接收，用于控制发送方的发送速率，以免溢出。用于流量控制</li>
<li>检验和：首部+数据全部的检验和</li>
<li>紧急数据指针：与URG标志位共同使用，指出数据中的紧急数据字段</li>
</ul>
</li>
</ul>
<ul>
<li>TCP的可靠数据传输<br>  TCP的可靠数据传输服务保证应用进程从接收缓存中读取的数据是不错，不乱，不丢的数据<ul>
<li>确认：只发送ACK确认被正确接收的分组，不发NAK，确认号是期望收到的下一字节序号：序号基于无结构，有序的字节流。序号表示该报文段的首字节的字节流编号</li>
<li>定时器：TCP设置单一定时器</li>
<li>累计确认：TCP采用累计确认，即接收方发送确认号为x的ACK，表示x之前的报文段都已被正确的接收；但是采用全部重传还是选择重传，TCP没有明确规定</li>
<li>超时重传：如果报文段的传输时间超时，则重传</li>
<li>快速重传：当发送方收到三个重复ACK（即共4个ACK），则快速重传该报文段</li>
</ul>
</li>
</ul>
<ul>
<li>TCP流量控制<br>  因为接收方设置有限的接收缓存，如果发送方发送速率过大的话，接收方缓存可能溢出，导致不必要的分组丢失<br>  所以流量控制是为了限制发送方的发送速率，来保证接收方可以来得及接收到来的报文段<br>  接收方在头部的接收窗口告诉发送方，接收缓存还剩多少，即还能接收多少数据，发送方保证发送的数据量不超过这个量<br>  若接收方告知接收窗口为0了，为避免阻塞，发送方仍发送数据量为1的报文段，接收方接收并回复ACK，并同时告知此时的接收窗口大小<br>  发送方的发送速率由流量控制的接收窗口大小与拥塞控制的拥塞窗口大小共同控制</li>
<li>TCP的拥塞控制<ul>
<li>发送方控制自己的发送速率，避免公共网络陷入拥塞，所有TCP发送方共同维护公共网络</li>
<li>拥塞控制与流量控制的区别：流量控制是考虑端到端之间的问题，是避免发送方发送速率过快导 致接收方来不及接收，考虑的是私人利益；拥塞控制考虑的是公共网络，避免发送方发送速率过快而导致网络陷入拥塞，考虑的是公共网络的问题</li>
<li>TCP在发送方维护一个CWND的拥塞窗口变量，与接收窗口RWND共同控制发送速率（滑动窗口的大小）</li>
<li>TCP根据丢包事件来感知网络的拥塞状态，如果发生超时丢包事件，则说明网络已经比较拥塞  了，数据已经传输不到接收方；如果重复ACK丢包事件，则表示网络可能即将陷入拥塞，但是没有那么严重，因为数据还能传输到接收方</li>
</ul>
</li>
</ul>
<ul>
<li>拥塞控制方法<ul>
<li>慢启动：TCP启动速度很慢，一般从MSS从1开始，但是希望快速找到可用带宽的数量，发送速率指数增长，知道遇到丢包时间，则设置一个阀值等于丢包时的速率的一般，即ssthresh = CWND/2 拥塞避免：如果是超时事件引起的丢包，则进入拥塞避免状态，拥塞避免状态将阀值设为拥塞窗口值的一半之后，将速率设为MSS = 1，然后开始指数增长，直到达到阀值ssthresh，此时可能即将进入拥塞状态了，所以之后再线性增长，直到遇到丢包事件</li>
<li>快速恢复：如果是3个重复ACK引起的丢包事件，此时TCP执行快速重传，并进入快速恢复状态， 将阀值设为拥塞窗口值的一般，即ssthresh = CWND/2，然后将发送速率降为阀值ssthresh，之后线性增长，直到遇到丢包事件</li>
</ul>
</li>
</ul>
<p>能够理解计算机网络协议栈分层设计的方法，每层的名称、主要功能、Internet 对应层的主要协议。<br>48. OSI七层架构</p>
<table>
<thead>
<tr>
<th align="center">r</th>
<th align="center">l</th>
<th align="center">j</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第一层</td>
<td align="center">物理层（physical）</td>
<td align="center">（单位类型：比特）    实现比特流的透明传输，物理接口，具有电气特性</td>
</tr>
<tr>
<td align="center">第二层</td>
<td align="center">数据链路层（date link）（单位类型：帧）</td>
<td align="center">访问介质；数据在该层封装成帧；用MAC地址作为访问媒介；具有错误检测与修正功能。MAC描述在共享介质环境中如何进行站的调度、发生和接收数据。MAC确保信息跨链路的可靠传输，对数据传输进行同步，识别错误和控制数据的流向。一般地讲，MAC只在共享介质环境中才是重要的，只有在共享介质环境中多个节点才能连接到同一传输介质上</td>
</tr>
<tr>
<td align="center">第三层</td>
<td align="center">网络层（network）（单位类型：报文）</td>
<td align="center">数据传输；提供逻辑地址，选择路由数据包，负责在源和终点之间建立连接</td>
</tr>
<tr>
<td align="center">第四层</td>
<td align="center">传输层（transport）</td>
<td align="center">实现端到端传输；分可靠与不可靠传输；在传输前实现错误检测与流量控制，定义端口号（标记相应的服务）</td>
</tr>
<tr>
<td align="center">第五层</td>
<td align="center">会话层（session）</td>
<td align="center">主机间通信；对应用会话管理，同步</td>
</tr>
<tr>
<td align="center">第六层</td>
<td align="center">表示层（presention）</td>
<td align="center">数据表现形式；特定功能的实现-比如加密模式确保原始设备上加密的数据可以在目标设备上正确地解密</td>
</tr>
<tr>
<td align="center">第七层</td>
<td align="center">应用层（application）</td>
<td align="center">最接近终端用户的OSI层，这就意味着OSI应用层与用户之间是通过应用软件直接相互作用的。网络进程访问应用层；提供接口服务</td>
</tr>
<tr>
<td align="center">- 2.TCP/IP四层架构</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">r</th>
<th align="center">l</th>
<th align="center">j</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第四层</td>
<td align="center">应用层</td>
<td align="center">TCP/IP协议的应用层相当于OSI模型的会话层、表示层和应用层，FTP(文件传输协议)，DNS（域名系统），HTTP协议，Telnet（网络远程访问协议）</td>
</tr>
<tr>
<td align="center">第三层</td>
<td align="center">传输层</td>
<td align="center">提供TCP(传输控制协议)，UDP（用户数据报协议）两个协议，主要功能是数据格式化、数据确认和丢失重传等。</td>
</tr>
<tr>
<td align="center">第二层</td>
<td align="center">网络层</td>
<td align="center">该层负责相同或不同网络中计算机之间的通信主要处理数据包和路由。数据包是网络传输的最小数据单位。通过某条传输路线将数据包传给对方。IP协议,ICMP协议，IGMP协议。在IP层中，ARP协议用于将IP地址转换成物理地址，ICMP协议用于报告差错和传送控制信息。IP协议在TCP/IP协议组中处于核心地位。</td>
</tr>
<tr>
<td align="center">第一层</td>
<td align="center">网络接口层</td>
<td align="center">TCP/IP协议的最低一层，对实际的网络媒体的管理，包括操作系统中的设备驱动程序和计算机对应的网络接口卡</td>
</tr>
</tbody></table>
<ul>
<li>3.TCP/IP五层架构</li>
</ul>
<table>
<thead>
<tr>
<th align="center">r</th>
<th align="center">l</th>
<th align="center">j</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第五层</td>
<td align="center">应用层 单位:报文(message)</td>
<td align="center">应用层是网络应用程序及它们的应用层协议存留的地方    面向用户提供端到端的网络服务</td>
</tr>
<tr>
<td align="center">第四层</td>
<td align="center">运输层 单位:报文段(segment)</td>
<td align="center">因特网的运输层在应用程序端点之间传送应用层报文.有两种运输层协议TCP和UDP.为应用层提供端到端的数据传输服务。</td>
</tr>
<tr>
<td align="center">第三层</td>
<td align="center">网络层 单位:数据报(datagram)</td>
<td align="center">负责将名为数据报的网络层分组从一台主机移动到另一台主机.转发和路由.为数据包找到一条从源地址到目的地址的路径</td>
</tr>
<tr>
<td align="center">第二层</td>
<td align="center">链路层 单位:帧(frame)</td>
<td align="center">将整个帧从一个网络元素移动到邻近的网络元素  为共享同一条链路的多个用户分配链路资源,以便把数据包传输到网络层指定的相邻节点上</td>
</tr>
<tr>
<td align="center">第一层</td>
<td align="center">物理层 单位:比特(bit)</td>
<td align="center">将帧中的一个个比特从一个节点移动到下一个节点    负责把数字信号转换成模拟信号（光/电等）在物理介质上传输。</td>
</tr>
</tbody></table>
<ol start="49">
<li><p>C/S模式和P2P模式的区别和优点缺点?</p>
<blockquote>
<p>1、C/S工作模式中信息资源的共享是以服务器为中心<br>2、P2P工作模式淡化服务提供者与服务使用者的界限，P2P网络中的每台计算机即可以是网络服务使用者也可以是提供者<br>3、C/S与P2P模式的差别主要在应用层<br>C/S：DNS，SMTP，FTP，Web<br>P2P：支持文件共享类Napster与BitTorrent服务协议、支持多媒体传输类Skype服务的协议<br>P2P网络是在IP网络上构建的一种逻辑的覆盖网，P2P是一种网络的覆盖模式</p>
</blockquote>
</li>
<li><p>DNS<br>(name,value,type,ttl)</p>
</li>
</ol>
<ul>
<li>type = A<br>  name 是主机名,value是主机名对应的ip<br>  例如(tju.rlj.com,123.124.0.1,A)</li>
<li>type = NS<br>  name 是个域 如(rlj.com) value是个知道如何获得该域中主机ip地址的权威dns服务器的主机名<br>  例如:(rlj.com,dns.rlj.com,NS)</li>
<li>type = CNAME<br>  value是别名为name的主机对应的规范主机名<br>  例如:(rlj.com,tju.rlj.com,CNAME)</li>
<li>type = MX<br>  value 是个别名为name的邮件服务器的规范主机名<br>  (rlj.com,mail.rlj.com,NX)</li>
</ul>
<ol start="51">
<li>NAT在P2P应用又事码问题? 怎么能解决?具体名字是什么?<blockquote>
<p>：P2P 需要实现两台主机间端到端的对等连接与通信,即参与通信的两台主机都可以是服务器,等待对 方的连接.而使用 NAT 技术后,NAT 设备后面的主机使用的是内部 IP 地址,不能直接被外部的设备访问, 因此部署在 NAT 设备之后的主机不能作为服务器,因而无法实现 P2P 通信.可以通过事先配置 NAT 转换 表来解决这一问题,即在表中增加内部主机的内部 IP,内部端口号和外部 IP,外部端口号的对应表项.这 一技术有 NAT 穿越 技术,UPnP协议</p>
</blockquote>
</li>
</ol>
<ul>
<li>第七,八,九章 <ul>
<li>A通过计算机网络给B发送消息，说其同意签订合同。随后A反悔，不承认发过该消息。为防止这种情况发生，在计算机网络中应采用 D 技术。<br>A、消息认证 B、数据加密 C、防火墙 D、数字签名 </li>
<li>在公钥密码体制中，不公开的是 B 。<br>A、公钥 B、私钥 C、公钥和加密算法 D、私钥和加密算法</li>
</ul>
</li>
</ul>
<p><a href="https://blog.csdn.net/u012557765/article/details/81638446" target="_blank" rel="noopener">相关文章:数据交换</a><br><a href="https://blog.csdn.net/qq894040717/article/details/82426965" target="_blank" rel="noopener">CSMA/CA</a></p>
]]></content>
      <categories>
        <category>期末</category>
      </categories>
      <tags>
        <tag>Computer Networking</tag>
      </tags>
  </entry>
  <entry>
    <title>DataBase</title>
    <url>/2020/01/01/DataBase/</url>
    <content><![CDATA[<h2 id="数据库复习"><a href="#数据库复习" class="headerlink" title="数据库复习"></a>数据库复习</h2><p>还几天考数据库了,看了看往年试卷没找几道会的题.<br>翻了翻书复习,内容太多了<br>所以打算拿往年试卷复习.</p>
<a id="more"></a>
<p>INTERSECT ∩<br>UNION ∪<br>EXCEPT -<br>exists/in/all/any R</p>
<!--more-->
<ul>
<li>DBMS 数据库管理系统</li>
<li>DBA 数据库管理员</li>
<li>DB 数据库</li>
<li>关系数据库(关系模型)提出者(E.F.code)</li>
<li>网状模型<br>  用网络结构表示实体类型及其实体之间联系的模型</li>
<li>数据库分层<ul>
<li>逻辑层 : 模式</li>
<li>物理层 : 实际是数据存储</li>
<li>视图层 : 虚的概念</li>
</ul>
</li>
<li>约束条件的写法<ul>
<li>至少选三门不同的课<ul>
<li>$\pi$ 投影 select</li>
<li>$\sigma$ 选择 where</li>
<li>from 是不是连接??</li>
</ul>
</li>
</ul>
</li>
<li>给定关系模式和函数依赖,判断无损连接(使用表格法,P55 图3-9)</li>
<li>三范式分解<ul>
<li>判断函数依赖最小集<ul>
<li>把每个函数依赖的右边转换成单个属性</li>
<li>左边的多于属性去掉(求闭包)</li>
<li>除掉多余函数依赖(P45)</li>
</ul>
</li>
<li>最小集中的每一个函数依赖作为一个分解<br>  例如:AB-&gt;C, 得S1(A,B,C)</li>
<li>判断是否具有无损连接性,是否包含所有属性</li>
<li>求解关键字(左属性,孤立属性,右属性,左右属性)</li>
</ul>
</li>
<li>BC范式(几乎不考,选择题)</li>
<li>ER图(简答题)<ul>
<li>画 ER图<ul>
<li>如果是一个多值属性,则需将该属性转换为实体集<br>  类如工资,或者是队服颜色</li>
<li>关键字,外关键字</li>
</ul>
</li>
<li>ER图转换成表</li>
</ul>
</li>
<li>虚拟试图<ul>
<li>虚拟视图的创建</li>
<li><h2 id="可更新视图判断-说明原因"><a href="#可更新视图判断-说明原因" class="headerlink" title="可更新视图判断(说明原因)"></a>可更新视图判断(说明原因)</h2><ul>
<li></li>
<li></li>
</ul>
</li>
<li>权限图<ul>
<li>**:具有该数据元素所有权,而不是来自别处授予</li>
<li>*:带有授权选项</li>
<li>grant语句 与 权限图 的转换</li>
</ul>
</li>
<li>关键字和外键的写法及权限</li>
</ul>
</li>
<li>故障恢复与并行控制<ul>
<li>冲突可串行化的判断</li>
<li>ACID 事务的基本特点</li>
<li>undo/redo log</li>
<li>死锁的判断 (依赖图,是否有环)</li>
</ul>
</li>
<li>flush 数据库清理日志<ul>
<li>flush执行一系列 sql 语句,但不提交事务;<br>commit 方法先调用flush()方法,然后提交事务,提交事务意味着对数据库操作永久保存下来.</li>
</ul>
</li>
<li>两个关系R与S  R与S的交集能写成什么？<blockquote>
<p>R∩S=R-(R-S)</p>
</blockquote>
</li>
<li>笛卡尔积用基本的关系代数表述<h3 id="rlj"><a href="#rlj" class="headerlink" title="rlj"></a>rlj</h3></li>
</ul>
<ol>
<li>下列关于关系数据库的说法，哪一项是正确的？B<br>• A. 关系数据库不能存储视频或音频。(可以存储视频或音频)</li>
</ol>
<p><strong>• B. 表是由列和行组成的。</strong><br>• C. 同一个表中的行可以拥有不同的列集。<br>• D. 行也称为表字段。(行也称记录,列有时也称字段和域)<br>2. 下列哪些是关系数据模型的组件？B<br>• A. 指针，集合，约束<br><strong>• B. 关系，属性，元组</strong><br>• C. 实例，记录类型，实体<br>• D. 表，行，等级<br>3. 下列哪一项表述是错误的？A<br><strong>• A. 关系模型中的属性映射到关系数据库中的行</strong> (记录映射成行)<br>• B. 在 ERD 中，用长方形表示实体(集)<br>• C. 一对一和多对多是可以在 ERD 中表示的关系<br>• D. 关系模型中的实体映射到关系数据库中的表</p>
<blockquote>
<p>行可能是一个实体,列是属性<br>4. 应用程序 B 想要在同一事务中多次读取表 EMPLOYEE 中的行子集。为了保证每次<br>都能返回相同的行子集，应该使用哪种隔离级别？C<br>• A.当前落实<br>• B.读稳定性<br><strong>• C.可重复读</strong><br>• D.未落实读<br>5. 下列关于事务的说法，哪一项是错误的？A<br><strong>• A.事务中的操作并行执行。</strong><br>• B.同一个事务中只能执行 1 个 COMMIT 语句。<br>• C.事务会保证一组操作的原子性。<br>• D. ROLLBACK 或 COMMIT 语句可以终结事务。<br>6. 下列哪一项是事务的定义？A<br><strong>• A. 组合在一起的一个或多个 SQL 操作序列，也被称为一个工作单元</strong><br>• B. 一组可以并行执行的独立操作<br>• C. 一个数据隔离级别，可通过允许读取之前已落实的数据来防止死锁<br>• D. 一个 DB2 数据库对象<br>7. 以下哪种情况会发生脏读？C<br>• A. 一个事务读取了相同的数据行两次，并且每次都返回不同的数据值(不可重复读)<br>• B. 在一个事务期间，基于特定标准的搜索在执行连续搜索之后返回额外的行(幻影读))<br><strong>• C. 返回了未落实的数据，但产生这些数据的事务已回滚</strong><br>• D. 两个事务读取并试图更新相同的数据，第二次更新将在第一次更新落实之前将其覆盖<br>8. 下列哪一项是关于 DB2 授权的最佳描述？A<br><strong>• A. 授权是一个过程，检查你是否具有足够的权限以执行所需的数据库操作</strong><br>• B. 授权是一个过程，在此过程中 DBA 将收集相关信息以查看哪些人可以访问数据库<br>• C. 授权是一个过程，在此过程中 DB2 数据库将使用 Windows 安全机制来检查你是<br>否能够访问 DB2 数据库<br>• D. 授权是一个过程，它通过验证你的用户 ID 和密码来确认你是否是所声称的那个人<br>9. 下列哪一项不是恢复的类型？B<br>A. 版本恢复<br><strong>B. 自动重启恢复</strong><br>C. 崩溃恢复<br>D. 前滚恢复<br>10. 自动存储具备什么功能？A<br><strong>• A. 自动存储允许用户指定数据库管理器用于存储表空间数据的路径，从而简化了存储管理。</strong><br>• B. 自动存储是一种选项，它允许写入到数据库的事务自动落实。<br>• C. 自动存储是一种 DB2 功能，它允许按设定计划自动备份表。<br>• D. 自动存储可以用于自动重组物理介质上的数据，以提高性能。<br>11. 铁路售票系统要求客户在订票前可以允许客户查询但客户上次的查询结果必须出现在下次查询中,在售票系统中的事务隔离级至少应该是:C<br>A. Read Uncommitted  B Read Committed<br><strong>C. Repeatable Reads</strong>   D. Serializable<br>12. 数据库管理系统的组成部分:   </p>
</blockquote>
<ul>
<li>锁管理器 </li>
<li>存储管理器</li>
<li>文件/索引/记录管理器</li>
<li>事务管理器</li>
<li>查询编译器</li>
<li>缓冲区管理器</li>
</ul>
<ol start="13">
<li>on update 和 on delete 后面可以跟的词语有四个no action ， set null ， set default ，cascade</li>
</ol>
<ul>
<li>no action 表示 不做任何操作，</li>
<li>set null 表示在外键表中将相应字段设置为null</li>
<li>set default 表示设置为默认值</li>
<li>cascade 表示级联操作，就是说，如果主键表中被参考字段更新，外键表中也更新，主键表中的记录被删除，外键表中改行也相应删除</li>
</ul>
<ol start="14">
<li><p>有关系模式R(A,B,C,D),有函数依赖集F={A-&gt;B,D-&gt;C，A-&gt;C，D-&gt;A},下面哪个分解不具有无损连接性 <strong>D</strong><br>A. ABC,AD   B. ACD,BCD  C.ABD,BD   D.AD,AB </p>
</li>
<li><p>下面哪个说法符合数据库系统WAL(log先写协议): <strong>D</strong><br>A.数据库内存中被事务修改的页面在事务成功完成时被强制写到磁盘中<br>B.数据库内存中被事务修改的页面在事务撤销时被写到标记为非脏页<br>C.事务成功完成时不需要将与其相关的log页面强制写回磁盘<br>D.事务中被修改的内存数据页面在写回磁盘前必须将与其相关的log写回磁盘</p>
</li>
<li><p>在DBMS中执行GRANT REFERENCES(col1) ON TABLE t1 TO user user7,对于该语句下面哪个描述是正确的: <strong>C</strong><br>A.user7可以在t1上定义视图<br>B.user7可以更新t1中的col1属性的值<br>C.user7在创建其他表时可以定义参考于t1中col1属性的外关键字<br>D.user7可以在t1中定义外关键字.</p>
</li>
<li><p>下列哪一个说法是不正确的 （A） （关系模型）</p>
</li>
</ol>
<p><strong>A、层次模型是EF codd一种</strong><br>B、数据的结构的结构模型的一部分<br>C、DBMS全称Database Management System<br>D、DBA的全称Database Administrator<br>18. 关于视图的描述中，说法正确的是（A）<br><strong>A、在查询中视图可以用作表来使用</strong><br>B、数据库对视图另外的保存数据<br>C、试图都是可以更新的<br>D、可更新视图都是可插入视图<br>19. 关于视图的描述下面说法哪些是正确的: A<br><strong>A.数据库只存储视图的定义.</strong><br>B.数据库为视图另外保存数据<br>C.视图都是可更新的<br>D.视图只能在一个关系上创建<br>20. 在数据库系统中，日志文件可以用于 D<br>A.保障事务的并发性   B.保障数据的安全性<br>C.检测系统的死锁     <strong>D.数据库故障的恢复</strong><br>21. 下面哪个隔离级在读的时候不给任何数据加读锁的是：A<br>A.Read Uncommitted    B. Read Committed<br>C. Repeatable Read    D. Serializable<br><strong>D.数据库重新启动时恢复系统中的分析阶段从检查点开始</strong></p>
<ol start="22">
<li>创建视图<br>create view movieprod(t,n) as select title,name<br>from movies,movieexexc<br>where pc#=c#</li>
<li>创建约束<br>club 数据库中定义一个合适的对象，能够实现下面的功能<br>当使用 insert 语句对 sailors 表插入记录时如果某些记录的 age 值小于 19，同时将这些 age 小于 19 的记录插入到 yangsaliors 表中。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> ST</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> sailors</span><br><span class="line"><span class="keyword">referencing</span></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">row</span> <span class="keyword">as</span> newrow</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">when</span> (new.age &lt;<span class="number">19</span> )</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> yangsaliors(<span class="keyword">sid</span>,<span class="keyword">name</span>,age) <span class="keyword">values</span>(newrow.sid,new.name,new.age)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2012-2013"><a href="#2012-2013" class="headerlink" title="2012-2013"></a>2012-2013</h3><ol>
<li>下列哪一个选项中的描述都可以作为E/R图中的实体集？ <strong>D</strong><br>A. 产品，颜色，高度<br>B. 黄色，大，长<br>C. 约翰，狗，飞机<br>D. 人，动物，植物 </li>
</ol>
<blockquote>
<p>实体是某种抽象对象,相似实体的集合形成实体集.<br>实体集有相关的属性,属性是这个实体机中实体所具有的性质<br>联系是两个或多个实体集的连接<br>颜色,高度 应该算是一种属性<br>约翰,狗,飞机 是实体</p>
</blockquote>
<ol start="2">
<li><p>下列哪一项表述是错误的？ <strong>D</strong><br>A.关键字唯一地标识表中的行。<br>B.外关键字是引用其他表主关键字的列集。<br>C.主关键字和外关键字用于强制数据完整性。<br>D.必须始终在表中定义主关键字。</p>
</li>
<li><p>下列哪些实体集在ER图中应该使用一对多关系？ <strong>D</strong><br>A. 人，  汽车<br>B. 学生，课程<br>C. 学生，教师<br>D. 母亲，孩子</p>
</li>
<li><p>如果使用下列语句创建 TAB1<br>CREATE TABLE tab1(c1 int not null,c2 int not null,<br>check  (c1+c2&gt;10))<br>下列哪个语句会将记录成功插入表 TAB1？ <strong>C</strong><br>A. INSERT INTO tab1 VALUES (0, 9)<br>B. INSERT INTO tab1 VALUES (null, 20)<br>C. INSERT INTO tab1 VALUES (4, 22)<br>D. INSERT INTO tab1 VALUES (20,null)</p>
<blockquote>
<p>check 这个是约束吗?</p>
</blockquote>
</li>
<li><p>给定下列两个表 </p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">C1</td>
<td align="center">C2</td>
<td align="center"></td>
<td align="center">CA</td>
<td align="center">CB</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center"></td>
<td align="center">a</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">4</td>
<td align="center"></td>
<td align="center">c</td>
<td align="center">d</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">6</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">下列哪个查询语句会得到下面的结果 <strong>C</strong>?</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>C1   C2    CA    CB<br>1    2     a      b<br>1    2     c      d<br>3    4     a      b<br>3    4     c      d<br>5    6     a      b<br>5    6     c      d<br>A.select * from t1,t2 where t1.c1=t2.cb<br>B.select * from t1,t2 where t1.c2=t2.ca<br>C.select * from t1,t2<br>D.select * from t1 inner join t2 on t1.c1=t2.ca</p>
<ol start="6">
<li><p>我们在DBMS中记录员工和部门的管理信息,当一个部门的管理员辞职后,数据库需要自动将该部门的管理员信息填成空值,在定义管理关系表时我们对于外关键字的删除规则应定义为 <strong>C</strong><br>A.ON DELETE CASCADE            B.ON DELETE ROLLBACK<br>C.ON DELETE SET NULL        D.ON DELETE NO ACTION</p>
</li>
<li><p>执行下列 SQL 语句之后：<br>GRANT ALL  ON TABLE student TO USER user1<br>假设用户 USER1 没有其他权限，下列哪一项操作是 USER1 可以执行的？<strong>D</strong><br>A. 将其获得在表student上的所有权限赋予其他用户<br>B. 删除关联到表 STUDENT 的视图<br>C. 删除表 STUDENT   D. 以上都不是</p>
</li>
<li><p>下面视图定义是中哪个是可更新视图  我猜选<strong>D</strong><br>A.Create view V1 as select  S.rating , max(S.age) as avgage from Sailors S group by S.rating<br>B.Create view V2 as select  *  from saliros S1 where S1.age&gt;18 expect select * from sailors S2 where S2.name like ‘%Tom’<br>C.Create view V3 as select  S.name, R,bid. from Sailor S, Reserves R where S.sid=R.sid<br>D.Create view V4 as select * from Bailors B where B.name is not null</p>
</li>
</ol>
<ul>
<li>(1) 若视图是基于多个表使用联接操作而导出的，那么对这个视图执行更新操作时，每次只能影响其中的一个表。</li>
<li>(2) 若视图导出时包含有分组和聚合操作，则不允许对这个视图执行更新操作。</li>
<li>(3) 若视图是从一个表经选择、投影而导出的，并在视图中包含了表的主键字或某个候选键，这类视图称为‘行列子集视图’。对这类视图可执行更新操作。<br><a href="https://www.cnblogs.com/suncan0/p/4767900.html" target="_blank" rel="noopener">可更新视图规则</a></li>
</ul>
<ol start="9">
<li>有两个关系TAB1,TAB2<br> TAB1                       TAB2<br>C1     C2                   CX     CY </li>
</ol>
<hr>
<p>A      11                    A      21<br>B      12                    C      22<br>C      13<br>   结果集如下<br>C1     C2    CX     CY </p>
<hr>
<p> A     11    A      21<br> C     13    C      22<br> B     12    -       -<br>哪个SQL语句能够生成该结果  <strong>D</strong><br>A. SELECT * FROM tab1 right OUTER JOIN tab2 ON c1=cx<br>  B. SELECT * FROM tab1 INNER JOIN tab2 ON c1=cx<br>C. SELECT * FROM tab1 FULL OUTER JOIN tab2 ON c1=cx<br>D. SELECT * FROM tab1 LEFT OUTER JOIN tab2 ON c1=cx</p>
<ol start="10">
<li>数据库系统管理员按照事务的方式执行下面的语句：<br>Create table tab1 (a int,b int)<br>insert into tabl values(1,2)<br>insert into tab1 values(2,3)<br>commit<br>Insert into tab1 values(2,3)<br>Insert into tab1 values(1,6)<br>rollback<br>Delete from tab1 where a=1<br>Insert into tab1 values(1,7)<br>数据库系统突然崩溃，系统重新启动后，该管理员执行<br>Select count(<em>) from tab1<br>数据库系统的输出是多少：*</em>A**<br>A. 2      B.3        C.4        D.5</li>
</ol>
<ol start="11">
<li>有关系模式R（A,B,C,D）,其函数依赖集F={A-&gt;B,B-&gt;C,C-&gt;D,D-&gt;A},将关系模式R分解为AB，BC，CD后，哪个函数依赖丢失了？<strong>C</strong><br>A． A-&gt;B    B.  B-&gt;C   C. D-&gt;A  D.没有函数依赖丢失</li>
</ol>
<ol start="12">
<li>有两个关系T1,T2<br>T1          T2<br>C1           CX    </li>
</ol>
<hr>
<p>A             A<br>B             C      </p>
<p>结果集如下<br>C1<br>A<br>B<br>A<br>C<br>哪个SQL语句能够生成该结果 <strong>B</strong><br>A.select * from t1 union  select * from t2<br>B.select * from t1 union all select * from t2<br>C.select * from t1,t2<br>D.select * from t1 except select * from t2</p>
<blockquote>
<p>union 默认是去重的,<br>如果要取消去重,要 加上 all关键字</p>
</blockquote>
<ol start="13">
<li><p>假设关系模式R1（EMP_ID，EMP_NAME，PHONE，EMAIL，SALARY）<br>下列方法中，哪一个是限制用户查看 SALARY 信息但仍允许他们查看其他值的最简单方法？<strong>B</strong><br>A. 加密表的数据<br>B. 创建不包含 SALARY 列的视图。赋予访问视图的权限，并撤销访问原始表的权限<br>C. 撤销不应查看 SALARY 数据的用户对 SALARY 列的 SELECT 访问权限<br>D. 将 SALARY 数据存储在其他表中，并赋予相应用户对该表的 SELECT 权限</p>
</li>
<li><p>有关系模式R(A,B,C,D),有函数依赖集F={A-&gt;B,D-&gt;C，A-&gt;C，D-&gt;A},下面哪个分解不具有无损连接性 <strong>D</strong><br>A. ABC,AD   B. ACD,BCD  C.ABD,BD   D.AD,AB </p>
<blockquote>
<p>无损连接性就是能还原关系的意思</p>
</blockquote>
</li>
<li><p>下面哪个说法符合数据库系统WAL(log先写协议): <strong>D</strong><br>A.数据库内存中被事务修改的页面在事务成功完成时被强制写到磁盘中<br>B.数据库内存中被事务修改的页面在事务撤销时被写到标记为非脏页<br>C.事务成功完成时不需要将与其相关的log页面强制写回磁盘<br>D.事务中被修改的内存数据页面在写回磁盘前必须将与其相关的log写回磁盘</p>
</li>
<li><p>在JDBC提供的数据库编程方法中提供了几种JDBC和数据库的连接方法:<strong>C</strong><br>A.5            B.2            C.4            D.1</p>
</li>
<li><p>某数据库应用系统中，在tab1表上频繁出现where a=… ., where a=….and c=….这些查询条件，其中tab1表中的记录个数为1000万条。数据库中数据库管理员为了提高查询效率决定建立索引，请你选出最合适的索引 <strong>D</strong><br>A.  在属性a上和属性（c，b）和属性（a，b，c）上分别建立索引<br>B． 在属性（a，c, b）上建立一个索引<br>C． 在属性a上和属性（a，b，c）分别建立索引<br>D． 在属性（a，c）上建立索引</p>
</li>
<li><p>下面哪个调度是串行调度:  <strong>B</strong><br>A. T1:R(A),T2:R(B),T2:W(B),T1:W(A)<br>B. T1:R(B),T1:W(B),T2:R(A), T2:W(A)<br>C. T1:R(A),T2:R(B),.T1:W(A),T2:W(B)<br>D. T2:R(A),T1:R(B),.T1:W(A),T2:W(B)</p>
</li>
<li><p>关于数据库管理系统下面哪个描述是最正确的  <strong>C</strong><br>A.数据库管理系统是数据的集合.<br>B.数据库管理系统是数据的集合,并且存储着数据与数据之间的关系.<br>C.数据库管理系统是由一个互相关联的数据的集合和一组用以访问和管理这些数据的程序组成.</p>
</li>
</ol>
<ol start="20">
<li>以下哪种情况会发生不可重复读？<strong>A</strong><br>A. 一个事务读取了相同的数据记录两次，并且每次都返回不同的数据值<br>B. 在一个事务期间，基于特定标准的搜索在执行连续搜索之后返回额外的行<br>C. 返回了未落实的数据，但产生这些数据的事务已回滚<br>D. 两个事务读取并试图更新相同的数据，第二次更新将在第一次更新落实之前将其覆盖</li>
<li>在数据库中存储的是 C<br>A．数据    B．数据模型<br>C．数据以及数据之间的联系    D．信息</li>
</ol>
<p>二.名称解释(每题3分,共15分)</p>
<ol>
<li>主关键字<br>主关键字（主键，primary key）是被挑选出来,作表的行的唯一标识的候选关键字。一个表只有一个主关键字。主关键字又可以称为主键。 主键可以由一个字段，也可以由多个字段组成，分别称为单字段主键或多字段主键。又称主码。并且它可以唯一确定表中的一行数据，或者可以唯一确定一个实体。</li>
</ol>
<p>2.BC范式</p>
<p>BCNF<br>设关系模式R&lt;U，F&gt;∈1NF，如果对于R的每个函数依赖X→Y，若Y不属于X，则X必含有候选码，那么R∈BCNF。</p>
<ol start="3">
<li>关系模式分解的无损连接性</li>
</ol>
<p>对关系模式分解时，原关系模式的任何一个合法的关系值在分解之后应该能通过自然连接运算恢复起来，这就是无损连接所要解决的问题。</p>
<ol start="4">
<li><p>数据库</p>
<blockquote>
<p>数据库是存放数据的仓库。它的存储空间很大，可以存放百万条、千万条、上亿条数据。但是数据库并不是随意地将数据进行存放，是有一定的规则的，否则查询的效率会很低。当今世界是一个充满着数据的互联网世界，充斥着大量的数据。即这个互联网世界就是数据世界。数据的来源有很多，比如出行记录、消费记录、浏览的网页、发送的消息等等。除了文本类型的数据，图像、音乐、声音都是数据</p>
</blockquote>
</li>
<li><p>事务原子性<br>事务中的多个数据库操作是一个不可分割的原子单元整体，只有所有的操作执行成功，整个事务才提交。事务中的任何一个数据库操作失败，已经执行的任何操作都必须被撤销，让数据库返回初始状态。<br>拓展:</p>
</li>
</ol>
<ul>
<li>事务ACID四大特性:<ul>
<li>原子性<br>  -定义:事务中的多个数据库操作是一个不可分割的原子单元整体，只有所有的操作执行成功，整个事务才提交。事务中的任何一个数据库操作失败，已经执行的任何操作都必须被撤销，让数据库返回初始状态。<ul>
<li>实现:事务内的一组操作全部成功(或者全部失败),为了实现原子性,就需要通过日志:将所有对数据的操作都写入日志,如果事务中的一部分操作已经成功,但后面部分操作,因为系统断电,操作系统崩溃等问题而没有成功执行,那么就要通过<strong>回溯日志,将前面已经成功执行的操作撤销,从而达到”全部执行失败”的效果。</strong></li>
</ul>
</li>
<li>一致性:<ul>
<li>事务操作成功后，保证数据不会被破坏</li>
<li>如A账户转账100元到B账户，不管操作成功与否，A和B账户的存款总额是不变的。一致性分为数据库外部一致性和内部一致性：</li>
<li>数据库外部一致性:由外部的应用编码来实现,即银行的应用在进行转账的操作时,必须在同一事务内部调用对账户A和账户B的操作。如果在这个阶段出现错误,这不是数据库本身能解决的,也不属于我们要讨论的范围。</li>
<li>数据库内部的一致性:在同一个事务内部的一组操作必须全部成功(或者全部失败) 这就是事务原子性</li>
</ul>
</li>
<li>持久性:<ul>
<li>一旦事务提交成功后，事务中所有的数据操作都必须被持久化到数据库中。即使在事务提交后，数据库马上崩溃，在数据库重启时，也必须保证能够通过某种机制恢复数据。</li>
</ul>
</li>
<li>隔离性:<br>  <a href="https://blog.csdn.net/u014079773/article/details/52808193" target="_blank" rel="noopener">点击阅读隔离</a></li>
</ul>
</li>
</ul>
<h4 id="简答题（共45分）"><a href="#简答题（共45分）" class="headerlink" title="简答题（共45分）"></a>简答题（共45分）</h4><p>有关系模式students(sid,sname,age,grade,class), course(cid, cname), enroll(sid,cid, score). students记录学生的基本信息,在students中sid表示学生的学号，sname表示学生的姓名,age表示年龄,grade表示年级,class表示班级，sid是students的主关键字.Course记录课程信息,cid为课程编号,cname表示课程名称,cid为course的主关键字.Enroll表示学生的选课信息,sid表示学号,cid表示课程编号,score表示成绩,sid,cid共同组成enroll的主关键字,sid为指向students的外关键字,cid为指向course的外关键字<br>1.请用关系代数写出下面的查询<br>查找年龄最小的学生姓名 (5分)<br>差不多就这个意思<br>重命名为S2 (sname2,age2)<br>S3:=Πsname(S∞(age&gt;age2)S2)<br>R4:= S(name)-S3(name)<br>2.请用元组关系演算写出下面的查询<br>查找年龄小于19而且数据库课程的成绩高于89的学生姓名（5分）</p>
<p>请用SQL语句写出下面的查询<br>4. 查找即选了’数据库原理’课程而没有选’web开发’课程的学生姓名（5分）</p>
<p>select sname from course c,students s,enrool r<br>where cname = ‘数据库原理’<br>and s.sid=r.sid<br>and c.cid=r.cid<br>except<br>select sname from course c,students s,enrool r<br>where cname = ‘数据库原理’<br>and s.sid=r.sid<br>and c.cid=r.cid</p>
<ol start="5">
<li>统计2011级每个班中数据库课程不及格的人数 （5分）</li>
</ol>
<p>select count(*)<br>from course c,students s,enrolled r<br>where grade = 2011<br>and cname = ‘数据库原理’<br>and s.sid=r.sid<br>and c.cid=r.cid<br>and score &lt; 60</p>
<ol start="6">
<li>显示在2011级各班中在数据库原理课程上平均分最低的班级和平均分（5分）</li>
</ol>
<p>select min()<br>avg(score) as avg(score)<br>group by class</p>
<ol start="7">
<li>统计选了数据库课程的平均分，最高分和最低分（5分）<br>avg(score),max()</li>
</ol>
<ol start="8">
<li>请根据下面的要求画出ER图（5分）<br>某个企业的数据库中记录以下信息:1.员工(ssn，name，lot)员工编号ssn唯一确定一个员工，2.部门(did，dname，buget)部门编号did唯一确定一个部门,3.员工与部门的管理关系，每个部门有且仅有一个管理者。</li>
</ol>
<blockquote>
<p>一个员工实体集,ssn是主键 (矩形)<br>一个部门实体集,did是主键 (矩形)<br>一个 manage 关系, 剪头指向 部门 (菱形)<br>需不需要用弧线?</p>
</blockquote>
<ol start="9">
<li>有关系模式R(ABCD),R上的函数依赖集F={ A-&gt;C,C-&gt;A,B-&gt;AC,D-&gt;AC,BD-.A },请将R分解成满足第三范式的关系模式，要求该分解具有无损连接性和依赖保持性(10分)</li>
</ol>
<h4 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h4><ul>
<li><p>关系的键 : 一个或多个属性集 {…}; 当键只包括单独的属性A时,称A(而不是{A})是键 </p>
<ul>
<li><ol>
<li>不可能存在两个不同元组具有相同的{…} </li>
</ol>
</li>
<li><ol start="2">
<li>键必须是最小的,ok!</li>
</ol>
</li>
</ul>
</li>
<li><p>超键 : 不满足上述条件的第二种情况.</p>
</li>
<li><p><strong>主属性</strong>：  包含在任一候选关键字中的属性称主属性。</p>
</li>
<li><p><strong>非主属性</strong>：  不包含在主码中的属性称为非主属性。</p>
</li>
<li><p><strong>函数依赖FD</strong>：<br>例：身份证号→姓名。<br>A → B<br>感觉就是 已知 A 可以推出 B (A可能就是键值吧)<br>至于是谁依赖谁呢?</p>
<ul>
<li><p><strong>部分函数依赖</strong>：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。</p>
</li>
<li><p><strong>完全函数依赖</strong>：在R(U)中，如果Y函数依赖于X,并且对于X的任何一个真子集X’，都有Y不函数依赖于X’， 则称Y对X完全函数依赖。否则称Y对X部分函数依赖。</p>
<ul>
<li><strong>平凡函数依赖</strong> : 例如: A,B,C -&gt; A,B<br>右边是左边的子集</li>
</ul>
<blockquote>
<p>【例】:<br>举个例子就明白了。假设一个学生有几个属性<br>SNO 学号   SNAME 姓名    SDEPT系<br>SAGE 年龄  CNO 班级号     G 成绩<br>对于(SNO,SNAME,SDEPT,SAGE,CNO,G)来说，G完全依赖于(SNO, CNO), 因为(SNO,CNO)可以决定G，而SNO和CNO都不能单独决定G。<br>而SAGE部分函数依赖于(SNO,CNO),因为(SNO,CNO)可以决定SAGE，而单独<br>SNO也可以决定SAGE。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>传递函数依赖</strong>：<br>设R（U）是属性集U上的关系，x、y、z是U的子集，在R（U）中，若x→y，但y→x，若y→z，则x→z，称z传递函数依赖于x，记作X→TZ。<br>如果X-&gt;Y, Y-&gt;Z, 则称Z对X传递函数依赖。</p>
</li>
<li><p><strong>计算X+（属性的闭包）算法</strong>： </p>
<blockquote>
<pre><code>a.初始化，令X+ = X;  </code></pre><p>   b.在F中依次查找每个没有被标记的函数依赖，若“左边属性集”包含于X+ ，则令 X+ = X+∪“右边属性集”, 并为访问过的函数依赖设置标记。<br>   c.反复执行b直到X+不改变为止。</p>
</blockquote>
</li>
<li><p><strong>检验给定的任意函数依赖A1A2…An-&gt;B是否蕴含于依赖集S:</strong></p>
<blockquote>
<p>分析：<br>根据属性集闭包的定义，可知A1A2…An-&gt;{A1,A2,…,An}+ 蕴含于S。只要证明B在{A1，A2，….,An}+中，那么函数依赖A1A2…An-&gt;B肯定蕴含于依赖集S中<br>求解过程：<br>（1） 利用依赖集计算闭包<br>（2） 如果B在闭包中，则函数依赖A1A2…An-&gt;B是否蕴含于<br>依赖集S，否则不蕴含于S</p>
</blockquote>
</li>
</ul>
<p>【例】:<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk1.png" alt><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk2.png" alt><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk3.png" alt></p>
<ul>
<li><p>最小化基本集 : 不可能包含平凡FD</p>
<ul>
<li><ol>
<li>B中所有FD的右边均为单一属性</li>
</ol>
</li>
<li><ol start="2">
<li>从B中删除任何一个FD后,该集合不再是基本集</li>
</ol>
</li>
<li><ol start="3">
<li>对于B中任何一个FD,如果从其左边删除一个或者多个属性,B将不再是基本集</li>
</ol>
</li>
</ul>
</li>
<li><p>Armstrong公理</p>
<ul>
<li><p>自反律:自己推自己 A-&gt;A</p>
</li>
<li><p>增广律 A-&gt;B 怎 AC-&gt;BC</p>
</li>
<li><p>传递律 A-&gt;B B-&gt;C 则A-&gt;C</p>
</li>
</ul>
</li>
</ul>
<p><font color="red" size="5">总结：</font><br>判定函数依赖X→Y是否能由F导出的问题，         可转化为求X+并判定Y是否是X+子集的问题。<br><font color="red">即求F闭包的问题可转化为求属性集闭包的问题。</font></p>
<p>函数依赖的闭包：<br>定义：若F为关系模式R(U)的函数依赖集，我们把F以及<font color="red">所有被F逻辑蕴涵的函数依赖的集合</font><br>称为F的闭包，记为F+</p>
<p>求函数依赖闭包，基于函数依赖推理规则<br>函数依赖推理规则：<br>若XY-&gt;Z，则X-&gt;Z，Y-&gt;z （错）<br>正确的：<br>若X-&gt;Y, 则XZ-&gt;YZ<br>若X-&gt;Y,X-&gt;Z，则X-&gt;YZ<br>若X-&gt;Y，Z属于Y，则X-&gt;Z<br>若X-&gt;Y，Y-&gt;Z，则X-&gt;Z<br>若X-&gt;YZ，则X-&gt;Y，X-&gt;Z //可以把每个函数依赖的右边的属性分解，从而使其右边只出现一个属性<br>伪传递率：<br>若A-&gt;B,BC-&gt;D,则AC-&gt;D</p>
<ul>
<li>异常<ul>
<li>冗余</li>
<li>更新异常</li>
<li>删除异常</li>
</ul>
</li>
<li>分解关系<br>  一般用分解关系的方法来消除异常4</li>
</ul>
<p><font size="5" color="red">第一范式（1NF）：</font>属性，属性值，字段不可分<br>就是无重复的列<br>如果一个关系模式R的所有属性都是不可分的基本数据项<br>不满足1NF的数据库就不是关系数据库<br>不可以表中有表</p>
<p><font size="5" color="red">第二范式（2NF）：</font>符合1NF，每一个非主属性完全依赖于码，不能存在部分依赖，有主键，非主键字段依赖主键; 唯一性 一个表只说明一个事物;<br>例:<br>不符合第二范式的例子:<br>表:学号, 姓名, 年龄, 课程名称, 成绩, 学分;<br>这个表明显说明了两个事务:学生信息, 课程信息;<br>存在问题:<br>数据冗余，每条记录都含有相同信息；<br>删除异常：删除所有学生成绩，就把课程信息全删除了；<br>插入异常：学生未选课，无法记录进数据库；<br>更新异常：调整课程学分，所有行都调整。<br>修正:<br>学生：Student(学号, 姓名, 年龄)；<br>课程：Course(课程名称, 学分)；<br>选课关系：SelectCourse(学号, 课程名称, 成绩)。<br>满足第2范式只消除了插入异常。</p>
<p><font size="5" color="red">第三范式（3NF）：</font><br>符合2NF，并且，消除传递依赖，非主键字段不能相互依赖; 每列都与主键有直接关系，不存在传递依赖;<br>若所有的属性都是主属性，则属于第三范式<br>要求一个数据库表中不包含已在其它表中已包含的非主关键字信息<br>【例】：<br>不符合第三范式的例子:<br>学号, 姓名, 年龄, 所在学院, 学院联系电话，关键字为单一关键字”学号”;<br>存在依赖传递: (学号) → (所在学院) → (学院地点, 学院电话)<br>存在问题:<br>数据冗余:有重复值；<br>更新异常：有重复的冗余信息，修改时需要同时修改多条记录，否则会出现数据不一致的情况<br>删除异常<br>修正：<br>学生：(学号, 姓名, 年龄, 所在学院)；<br>学院：(学院, 地点, 电话)。 </p>
<font size="5" color="red">
总结：</font>

<ul>
<li>1nf:不可分</li>
<li>2nf:一个表说明一个事物，唯一性</li>
<li>3nf:对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。</li>
</ul>
<p><font size="5" color="red">BCNF</font>是3NF的改进形式<br>BCNF意味着在关系模式中每一个决定因素都包含候选键，也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。BCNF范式排除了任何属性对候选键的传递依赖与部分依赖。</p>
<ul>
<li>满足BCNF条件<ul>
<li>1 所有非主属性对每一个候选键都是完全函数依赖；</li>
<li>2 所有的主属性对每一个不包含它的候选键，也是完全函数依赖；</li>
<li>3 没有任何属性完全函数依赖于非候选键的任何一组属性。</li>
</ul>
</li>
</ul>
<p><font size="5" color="red">候选键</font>(又称候选码，候选关键字,码 ，candidate key)<br>设K是一个R(U)中的属性或属性集合(注意可以是属性集合，也即多个属性的组合)，若K完全函数确定U，则K为R的候选键(Candidate key);<br>通俗地说就是，能够确定全部属性的某个属性或某组属性，称为候选键。若候选键多于一个，则选定其中一个作为主键。</p>
<p><strong>在所有依赖关系右边没有出现的属性一定是候选键的成员。</strong></p>
<p><font size="5" color="red">BCNF范式排除了任何属性对候选键的传递依赖与部分依赖。</font><br><font size="5" color="red"></font><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk4.png" alt><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk5.png" alt><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk6.png" alt><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk7.png" alt><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk8.png" alt><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk9.png" alt></p>
<h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><p>设有关系模式R（A，B，C，D，E，G）上的函数依赖集为：<br> F={ A→B，B→C，AD→G，D→E } 。求解：<br>31. 求关系模式R的所有侯选键。</p>
<blockquote>
<p>解: 求出侯选键AD。（2分）<br>首先在F中函数依赖右边不出现的属性必在侯选键中,即AD (1分)；由于(AD)+=ABCDEG, 即AD能函数决定所有的属性, 所以侯选键只有一个 AD（1分） 。 AD+=AD BEG C<br>32. 分别求属性集G、AD、CD、BC的闭包。<br>G+=G(1分)；      (AD)+=ABCDEG(1分)；<br>(CD)+= CDE(1分)；(BC)+=BC(1分)<br>33. 将关系模式R保持依赖地且无损地分解成3NF，要求写出分解过程。<br>解：F={ A→B，B→C，AD→G，D→E }<br>F是最小依赖集，所有属性在F中出现，将F中是每个函数依赖组成一个关系模式得保持函数依赖的分解：{AB，BC，ADG， DE} (2分)； 并上一个侯选键{AD}得无损分解：<br>{AB，BC，ADG，DE}∪{AD}={ AB，BC，ADG，DE } (2分)<br>F={ A→B，B→C，AD→G，D→E }<br>34. 将关系模式R无损地分解成BCNF，要求写出分解过程。<br>解：根据转换为BCNF的无损连接分解算法6.5  1）由于候选键为AD，<br>F中存在不符合BCNF要求的函数依赖，所以R不是BCNF，<br>选 A→B 分解为：R1=AB，R2=ACDEG ；(1分)<br>R1上保持的函数依赖集为A→B，键为A，所以是BCNF；<br>R2 上保持的函数依赖集为A→C，AD→G，D→E，键为AD，所以不是BCNF； (1分)<br>选A→C进一步分解为：R21=AC，R22=ADEG；(1分) R21上保持的函数依赖为A→C，键为A，所以是BCNF；<br>R22上保持的函数依赖为AD→G，D→E键为AD，所以不是BCNF； 选D→E进一步分解为：R221=DE，R222=ADG；(1分) R221上保持的函数依赖为D→E，键为D，所以是BCNF； R222上保持的函数依赖为AD→G，键为AD，所以是BCNF；<br>最后得保持无损连接特征的分解：{R1，R21，R221，R222}或表示为{AB，AC，DE，ADG}(1分)<br>注：由于选择不符合BCNF要求的函数依赖有多个，因此选择次序可有不同，最后的结果也不同，原则上按上述评分标准分步给分。<br>35. 说明分解ρ={R1，R2}，R1（ABC）、R2（ADEG）的范式级别并说明理由<br>答：R1是2NF (1分)，R2是1NF；(1分)<br>R1上的函数依赖集为：A→B，B→C，码为：A，不存在部分依赖，存在非主属性C对码A的传递依赖。(1分)<br>R2上的函数依赖集为：AD→G，D→E码为：AD，存在非主属性E对码AD的部分依赖。。(1分)<br>ρ={R1，R2}，R1（ABC）、R2（ADEG）</p>
</blockquote>
<h4 id="关系模型基础"><a href="#关系模型基础" class="headerlink" title="关系模型基础:"></a>关系模型基础:</h4><ul>
<li>属性 : 关系的列命名为属性,属性出现在列的顶部;属性用来表述所在列的项目的语义</li>
<li>模式 : 关系名和其属性集合的组合称为这个关系的模式;</li>
<li>元组 : 关系中除含有属性名所在行以外的其他行称为元组;<br>每个元组均有一个分量对应于关系的每个属性</li>
<li>域 : 一个特殊的元素属性 (数据类型)</li>
<li>关系是元组的集合,而不是元组的列表,关系中元组出现的顺序不是实质问题.</li>
<li>关系上的键 : </li>
<li>修改关系模式<ul>
<li>DROP TABLE R;</li>
<li>ALTER TABLE Moive ADD phone char(16);</li>
<li>ALTER TABLE Moive DROP phone;</li>
</ul>
</li>
<li>默认值 <ul>
<li>gender char(1) default ‘?’,</li>
<li>birthdate date default date ‘0000-00-00’,</li>
</ul>
</li>
<li>键的声明<br>  可声明一个或者一组属性是键<ul>
<li>PRIMARY KEY (属性不能有null值)</li>
<li>UNIQUE (null值是允许的)</li>
<li>外键</li>
</ul>
</li>
</ul>
<h4 id="代数查询语言"><a href="#代数查询语言" class="headerlink" title="代数查询语言"></a>代数查询语言</h4><ul>
<li>关系上的集合操作<ul>
<li>并 R∪S</li>
<li>交 R∩S</li>
<li>差 R-S</li>
</ul>
</li>
<li>投影 π a1,a2,…(R)<br>ok领会!<br>a1,a2…是要投影的列</li>
<li>选择<br>σc(R) C是条件</li>
<li>笛卡尔积 R × S<br>领会</li>
<li>自然连接<br>  R ∞ S (用∞代替那个符号了)<ul>
<li>要求: 连接时相应的元组必须在某些方面一致.(属性名字吗?)</li>
<li>如果一个元组不能和另外关系中的任何一个元组配对的话,这个元组就被称为<strong>悬浮元组</strong></li>
</ul>
</li>
<li>θ连接<br>R ∞c S<br>上面提到了C指的是条件<br>θ连接也就是满足某种条件的笛卡尔积</li>
<li>命名和重命名<br>ρs(R)<br>ρs(A1,A2,…An)(R)<br>把S改成名为R的关系</li>
<li>操作之间的关系<ul>
<li>R ∩ S = R - (R - S)</li>
<li>R ∞c S = σc(R × S) </li>
<li>自然连接和笛卡尔积的连接就不必写了把</li>
</ul>
</li>
<li>代数表达式的线性符号<ul>
<li>关系的名字和用圆括号括起来的关系属性的列表.名字Answer习惯性表示最后一步运算的结果,也就是在表达式树根节点上的关系名</li>
<li>赋值符号 :=</li>
<li>赋值号右边的任何代数表达式,可以采用每个赋值语句只用一个算符的方法.也可把几个代数运算组合到一起写到表达式的右端.</li>
</ul>
</li>
<li>关系上的约束<ul>
<li>R=ø 表示 R的值必须为空的约束 与 “R中没有元组等价”</li>
<li>R ⊆ S 表示”任何在R中出现的元组都必须在S中出现”的约束<br>也可写成R - S = ø</li>
<li>引用完整性约束是一种普通的约束.<br>某个上下文出现的值也必须在另外相关的上下文中出现<br>领悟!</li>
<li>键约束 没有任何两个元组在键分量上具有相同的值</li>
<li>其他约束: 略懂;  满足某些条件的关系代数表达式 等于ø 或 ⊆关系</li>
</ul>
</li>
</ul>
<h4 id="数据库语言SQL"><a href="#数据库语言SQL" class="headerlink" title="数据库语言SQL"></a>数据库语言SQL</h4><p>select L (表达式列表)<br>from R (关系)<br>where C (条件)</p>
<ul>
<li><p>投影 </p>
</li>
<li><p>选择 </p>
</li>
<li><p>模式匹配</p>
<ul>
<li>s LIKE p (p是模式)<br>_表示可匹配一个字符<br>%表示可匹配任何形式字符串</li>
</ul>
</li>
<li><p>输出排序<br>在select-from-where语句后加上<br>order by <list of attributes> (默认序是升序)<br>DESC(表示降序),  ASC(表示升序,可省略)</list></p>
</li>
<li><p>SQL中的积和连接</p>
</li>
<li><p>消除属性歧义<br>A.a B.a</p>
</li>
<li><p>元组变量<br>A as A</p>
</li>
<li><p>多关系查询的解释</p>
<ul>
<li>嵌套循环</li>
<li>并行赋值</li>
<li>转换为关系代数</li>
</ul>
</li>
<li><p>查询的并,交,差(查询应该分别用括号括起来)</p>
<ul>
<li>UNION ∪</li>
<li>INTERSECT ∩</li>
<li>EXCEPT -</li>
</ul>
</li>
<li><p>子查询</p>
<ul>
<li>产生标量值得子查询</li>
<li>关系得条件表达式<ul>
<li>EXISTS R</li>
<li>s IN R</li>
<li>s &gt; ALL</li>
<li>s &gt; ANY</li>
</ul>
</li>
<li>元组的条件表达式</li>
<li>关联子查询</li>
<li>FROM子句中的子查询</li>
<li><strong>SQL的连接表达式</strong><ul>
<li>cross join 交叉连接</li>
<li>join R on θ连接 </li>
<li>natural join R 自然连接 </li>
<li>natural full outer join 外连接<br>natural left outer join<br>natural right outer join</li>
</ul>
</li>
</ul>
</li>
<li><p>全关系操作</p>
<ul>
<li>消除重复<br>SELECT DISTINCT (实际上从关系中消除重复的代价非常昂贵)</li>
<li>并,交,差<br>若要消除重复元组,必须在UNION,INTERSECT和EXCEPT后跟上保留字ALL即可<br>如: R intersect all S</li>
<li>聚集操作符<ul>
<li>SUM</li>
<li>AVG</li>
<li>MIN</li>
<li>MAX</li>
<li>COUNT </li>
</ul>
</li>
<li>分组 GROUP BY name</li>
<li>分组,聚集和空值<br>空值不对求和,取平均和计数做贡献,也不能是列的最大值或最小值</li>
<li>HAVING子句</li>
</ul>
</li>
<li><p>数据库更新</p>
<ul>
<li>插入<br>insert into R(A1,A2…An) values (v1,v2…vn);</li>
<li>删除<br>delete from R where &lt;条件&gt;;</li>
<li>修改<br>update R set&lt;新值赋值&gt; where &lt;条件&gt;;<br>||运算符表示字符串的连接</li>
</ul>
</li>
<li><p>SQL中的事务</p>
<ul>
<li>可串行化</li>
<li>原子性</li>
<li>事务<ul>
<li>START TRANSACTION可用来标记事务的开始</li>
<li>SQL语句COMMIT使得事务成功结束.</li>
<li>SQL语句ROLLBACK使得事务夭折或不成功结束,任何由该事务的SQL语句所引起的修改都被撤销,即它们被回滚 rooled back, </li>
</ul>
</li>
<li>只读事务 (即它不会修改数据库,)<br>SET TRANSACTION READ ONLY<br>这条语句必须在事务开始之前执行.可以通过如下语句通知SQL下一个事务可以写数据:<br>SET TRANSACTION READ WRITE;<br>不过,这个选项是默认选项</li>
<li>读脏数据<ul>
<li>脏数据: Dirty data 是表示还没有提交的事务所写的数据的通用术语</li>
<li>脏读 : 是对脏数据的读取</li>
<li>SQL允许指定一个给定的事务是否可以脏读:<br>  SET TRANSACTION READ WRITE<pre><code>ISOLATION LEVEL READ UNCOMMITTED;</code></pre>  上述语句做了两件事:<ol>
<li>第一行声明事务可以写数据</li>
<li>第二行声明事务用读未提交的”隔离层次”运行,即允许事务读脏数据    </li>
</ol>
</li>
</ul>
</li>
<li>其他隔离层次<ul>
<li>可串行化<br>SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;默认的;</li>
<li>读未提交(脏读)</li>
<li>读提交<br>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</li>
<li>可重复读<br>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;<h4 id="事务其他相关"><a href="#事务其他相关" class="headerlink" title="事务其他相关"></a>事务其他相关</h4></li>
</ul>
</li>
</ul>
</li>
<li><p>共享锁和排他锁</p>
</li>
<li><p>日志的flush,书上例子，output</p>
</li>
</ul>
<h4 id="约束与触发器"><a href="#约束与触发器" class="headerlink" title="约束与触发器"></a>约束与触发器</h4><ul>
<li><p>键和外键</p>
<ul>
<li><p>外键声明隐含的两层意思</p>
</li>
<li><p>两种声明外键的方法<br>a) 在属性的名字和类型后加 references &lt;表名&gt; (&lt;属性名&gt;)<br>b) create table语句的属性列表上追加一个或多个声明<br>foreign key (&lt;属性名列表&gt;) reference &lt;表名&gt; (&lt;属性名列表&gt;)</p>
</li>
<li><p>维护引用完整性</p>
<ul>
<li>缺省原则</li>
<li>级联原则</li>
<li>置空值原则<br>ON DELETE SET NULL<br>ON UPDATE CASCADE</li>
</ul>
</li>
<li><p>延迟约束检查<br>创建表时候在外键后添加缺省<br>DEFERRABLE<br>NOT DEFERRABLE<br>后可有<br>INITIALLY DEFERRED 检查仅被推迟到事务提交前执行,<br>或 INITIALLY IMMEDIATE 选项. 检查在每个语句后都立即被执行<br>SET CONSTRAINT Myconstraint deferred</p>
</li>
</ul>
</li>
<li><p>属性和元组上的约束</p>
<ol>
<li>在单一属性上的约束</li>
<li>在整个元组上的约束</li>
</ol>
<ul>
<li>非空值约束</li>
<li>基于属性的CHECK约束</li>
<li>基于元组的CHECK约束</li>
</ul>
</li>
<li><p>修改约束</p>
<ul>
<li>给约束命名<br>在约束前加保留字CONSTRAINT和约束的名字</li>
<li>修改表上的约束</li>
</ul>
</li>
<li><p>断言 : </p>
<ul>
<li><p>创建断言<br>CREATE ASSERTION &lt;断言名&gt; CHECK (&lt;条件&gt;)</p>
</li>
<li><p>使用断言</p>
</li>
<li><p>删除断言<br>DROP ASSERTION (&lt;断言名&gt;)</p>
</li>
</ul>
</li>
<li><p>触发器<br>  有事也称为 事件-条件-动作规则.或者ECA规则</p>
<ul>
<li>SQL中的触发器<ul>
<li>主要特征 : </li>
</ul>
</li>
<li>触发器设计的选项<h4 id="视图与索引"><a href="#视图与索引" class="headerlink" title="视图与索引"></a>视图与索引</h4></li>
</ul>
</li>
<li><p>虚拟视图 </p>
<ul>
<li>视图的定义:<br>CREATE VIEW &lt;视图名&gt; AS &lt;视图定义&gt;<br>视图定义是一个SQL查询</li>
<li>视图查询</li>
<li>属性重命名</li>
</ul>
</li>
<li><p>视图更新</p>
<ul>
<li><p>视图删除<br>DROP VIEW ParamountMovies<br>删除视图不会影响基本关系Movies<br>但是删除表MOVIES 不但使得表Movies 从此消失,也使得视图不可用</p>
</li>
<li><p><strong>可更新视图</strong><br>  该视图是由单个关系R选取出得一些元素组成</p>
<ul>
<li>WHERE 子句在子查询中不能使用关系R</li>
<li>FROM语句只能包含一个关系R,不能再有其他关系</li>
<li>SELECT语句中的属性列表必须包括足够多的属性,以保证对该视图进行元组插入时,能够用NULL或者适当的默认值来填充所有其他不属于该视图的属性.<br>比如,SELECT语句中不允许包括被定义为非空或者没有默认值的属性.</li>
</ul>
</li>
<li><p>视图中的替换触发器<br>  可以用INSTEAD OF 代替BEFORE,AFTER</p>
</li>
</ul>
</li>
<li><p>索引:<br>  一个表最多建一个索引</p>
<ul>
<li>定义:关系中属性A的索引时一种数据结构,他能提高在属性A上查找具有某个特定值的元组的效率.</li>
<li>建立索引的动机<br>当关系变得很大时,通过扫描关系中所有的元组来找出那些匹配给定查询条件的元组的代价太高.</li>
<li>索引的声明<br>  CREATE INDEX 索引名 ON movies(year,title);<br>  DROP INDEX 索引名.</li>
</ul>
</li>
<li><p>索引的选择<br>  索引的选择时衡量数据库设计成败的一个重要因素.</p>
<ul>
<li><p>设计索引主要考虑两个因素:<br>  1)如果属性上存在索引,则为该属性指定一个值或者取值范围能极大地提高查询的执行效率.同样,如果查询涉及该属性上的连接操作,也能带来性能上的改善</p>
</li>
<li><p>另一方面,为关系上的某个属性或者某个属性集建立的索引会使得对关系的插入,删除,和修改变得更复杂和更费时.</p>
</li>
<li><p>简单代价模型</p>
</li>
<li><p>一些有用的索引:</p>
</li>
</ul>
<ol>
<li>在查询中未主键指定值时比较普遍的,因此键上的索引通常会被频繁地使用</li>
<li>因为键值时唯一的,故与给定键值匹配的元组最多只有一个,因为索引返回的要么是这个元组的位置,要么什么也不返回.<ul>
<li>存在两种情况,即使不是建立在键属性上的索引页仍然有效<br>几乎可以看成是键<br>元组在该属性上是聚集的.</li>
</ul>
</li>
</ol>
<ul>
<li>计算最佳索引</li>
<li>所以的自动选择</li>
</ul>
</li>
<li><p>物化视图(不考) </p>
</li>
</ul>
<h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程 :"></a>存储过程 :</h4><ul>
<li><p>创建PSM函数和过程</p>
<ul>
<li>过程声明要素:<br>CREATE PROCEDURE &lt;名字&gt; (&lt;参数&gt;)<br>  &lt;局部声明&gt;<br>  &lt;过程体&gt;;</li>
<li>函数定义的要素:<br>CREATE FUNCTION &lt;名字&gt; (&lt;参数&gt;) RETURNS &lt;类型&gt;<br>  &lt;局部声明&gt;<br>  &lt;函数体&gt;;</li>
<li>参数是 模式-名字-类型<br>例如: IN oldAddr VARCHAR(255)</li>
</ul>
</li>
<li><p>PSM中的简单语句格式</p>
<ul>
<li>调用语句<br>CALL &lt;过程名&gt; (&lt;参数&gt;)</li>
<li>返回语句</li>
<li>局部变量声明<br>declare &lt;名字&gt;&lt;类型&gt;;</li>
<li>赋值语句<br>set &lt;变量&gt;=&lt;表达式&gt;;</li>
<li>语句组<br>begine…end</li>
<li>语句标号<br>用名字(标号名)和冒号作为前缀来标识语句</li>
</ul>
</li>
<li><p>分支语句</p>
<ul>
<li>用保留字END IF结束</li>
<li>嵌套在if语句中的else子句以单词ELSEIF开始</li>
</ul>
</li>
<li><p>PSM中的查询</p>
<ul>
<li>声明和使用游标<br>a)语句中不出现EXEC SQL<br>b)局部变量不适用冒号前缀</li>
</ul>
</li>
<li><p>PSM中的循环<br>LOOP<br>  &lt;语句列表&gt;<br>END LOOP;<br>中断循环: LEAVE&lt;循环标识&gt;</p>
</li>
<li><p>for 循环</p>
</li>
<li><p>PSM中的异常处理</p>
</li>
<li><p>使用PSM函数和过程</p>
<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4></li>
<li><p>九种类型的权限:</p>
<ul>
<li>select,insert,delete,update 应用到关系上</li>
<li>reference权限是指在完整性约束下引用关系的权力</li>
<li>usage 关系和断言之外的多种模式元素上.</li>
<li>trigger 触发器的权限</li>
<li>execute PSM过程或函数之类的代码权限</li>
<li>under 创建给定类型的子类型权限</li>
</ul>
</li>
<li><p>创建权限</p>
</li>
<li><p>检查权限的过程</p>
</li>
<li><p>授权<br>授权语句的格式如下:<br>GRANT &lt;权限列表&gt; ON &lt;数据库元素&gt; TO &lt;用户列表&gt;<br>其后可以加上with grant option.<br>ALL PRIVILEGES可能在这里出现 </p>
</li>
<li><p><strong>授权图</strong></p>
</li>
<li><p>收权<br>  REVOKE &lt;权限列表&gt; ON &lt;数据库元素&gt; FROM &lt;用户列表&gt;</p>
<ul>
<li>CASCADE</li>
<li>RESTRICT\ <h4 id="其他部分"><a href="#其他部分" class="headerlink" title="其他部分:"></a>其他部分:</h4></li>
</ul>
</li>
<li><p>数据库教父—-E.F.Codd<br>关系层次模型提出?</p>
</li>
<li><p>DBMS:数据库管理系统(Database Management System)是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS</p>
</li>
<li><p>DBA : 数据库管理员（Database Administrator，简称DBA），是从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称</p>
</li>
<li><p>关系规范性算法（闭包，函数依赖的投影，BC范式的分解<br>2范式消除了部分依赖，1范式:原子非多值<br>3范式消除了传递依赖</p>
</li>
<li><p>函数依赖集合，不是关系R的键：算闭包</p>
</li>
<li><p>BC范式能否保持无损连接，三范式</p>
</li>
<li><p>分关系代数（注意不是sql语句）<br>关系代数表示约束，用两种方式表达，等于空集或者属于</p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_37799190/article/details/79418322" target="_blank" rel="noopener">规范化理论</a></p>
</li>
<li><p>给一个调度（并行化，并发控制）</p>
</li>
<li><p>什么叫做冲突的（两个事务对同一个对象的写操作（至少一个）</p>
</li>
<li><p>如何判断调度是不是可串行化的（画优先图）；</p>
</li>
<li><p>关于日志恢复的问题，日志分三种类型，考undo，redo日志，</p>
</li>
<li><p>写出数据库的恢复子系统，恢复的过程，以及恢复之后是什么样子；</p>
</li>
<li><p>两阶段锁协议，书上例题，保证不会发生死锁；</p>
</li>
</ul>
<h4 id="数据库恢复技术"><a href="#数据库恢复技术" class="headerlink" title="数据库恢复技术"></a>数据库恢复技术</h4><h5 id="事务的基本概念"><a href="#事务的基本概念" class="headerlink" title="事务的基本概念"></a>事务的基本概念</h5><ul>
<li><p>1.定义：<br>   一个数据库操作序列<br>   一个不可分割的工作单位<br>   恢复和并发控制的基本单位</p>
</li>
<li><p>2.显示定义方式：<br>  COMMIT</p>
<ul>
<li><p>事务正常结束</p>
</li>
<li><p>提交事务的所有操作</p>
</li>
<li><p>事务中所有对数据库的更新写回磁盘上的物理数据库中.</p>
<p>ROLLBACK</p>
</li>
<li><p>事务异常终止</p>
</li>
<li><p>事务运行的过程中发生了故障,不能继续执行</p>
</li>
<li><p>系统将事务中对数据库的所有已完成的操作全部撤销</p>
</li>
<li><p>事务滚回到开始时的状态</p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">BEGIN TRANSACTION</th>
<th align="center">BEGIN TRANSACTION</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SQL语句1</td>
<td align="center">SQL语句1</td>
</tr>
<tr>
<td align="center">SQL语句2</td>
<td align="center">SQL语句2</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">COMMIT</td>
<td align="center">ROLLBACK</td>
</tr>
</tbody></table>
<ul>
<li><p>3.隐式定义：<br>当用户没有显式地定义事务时，DBMS按缺省规定自动划分事务</p>
</li>
<li><p>4.事务的特性（ACID特性)</p>
<ul>
<li>原子性 (Atomicity)</li>
<li>一致性 (Consistency)</li>
<li>隔离性 (Isolation)</li>
<li>持续性 (Durability)<blockquote>
<ul>
<li>保证事务ACID特性是事务管理的重要任务。</li>
<li>事务ACID特性可能遭到破坏的因素是：<br>1)多个事务并行运行时，不同事务的操作交叉执行<br>2)事务在运行过程中被强行终止</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>数据库管理系统要解决的问题：</p>
<ul>
<li><p>必须保证多个事务的交叉运行不影响这些事务的原子性</p>
</li>
<li><p>必须保证被强行终止的事务对数据库和其他事务没有任何影响</p>
</li>
<li><p>这两个问题就是数据库管理系统的恢复机制和并发控制机制的责任</p>
<h5 id="数据库恢复概述"><a href="#数据库恢复概述" class="headerlink" title="数据库恢复概述"></a>数据库恢复概述</h5></li>
<li><p>故障时不可避免</p>
<ul>
<li>计算机硬件故障</li>
<li>软件的错误</li>
<li>操作员的失误</li>
<li>恶意的破坏</li>
</ul>
</li>
<li><p>故障的影响</p>
<ul>
<li>运行事务非正常中断,影响数据库中数据的正确性</li>
<li>破坏数据库,全部或部分丢失数据</li>
</ul>
</li>
<li><p>数据库的恢复</p>
<blockquote>
<p>DBMS把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态)的功能,这就是数据库的恢复管理系统对故障的对策</p>
</blockquote>
</li>
<li><p>恢复子系统是数据库管理系统的一个重要组成部分</p>
</li>
<li><p>恢复技术是衡量系统优劣的重要指标</p>
</li>
</ul>
<h5 id="故障的种类"><a href="#故障的种类" class="headerlink" title="故障的种类"></a>故障的种类</h5><ul>
<li><p>1.事务内部的故障</p>
<blockquote>
<p>两个更新操作要么全部完成要么全部不做。否则就会使数据库处于不一致状态，例如只把账户甲的余额减少了而没有把账户乙的余额增加。在这段程序中若产生账户甲余额不足的情况，应用程序可以发现并让事务滚回，撤销已作的修改，恢复数据库到正确状态</p>
</blockquote>
</li>
<li><p>事务内部更多的故障是非预期的，是不能由应用程序处理的。</p>
<ul>
<li>运算溢出</li>
<li>并发事务发生死锁而被选中撤销该事务</li>
<li>违反了某些完整性限制而被终止等</li>
</ul>
</li>
<li><p>事务故障的恢复：撤消事务（UNDO）</p>
<ul>
<li>强行回滚事务</li>
<li>撤销该事务已经做出的任何对数据库的修改,使得该事务像根本没有启动一样.</li>
</ul>
</li>
<li><p>2.系统故障(软故障)<br>  指造成系统停止运转的任何事件，使得系统要重新启动</p>
<ul>
<li>特定类型的硬件错误（如CPU故障）</li>
<li>操作系统故障</li>
<li>DBMS代码错误</li>
<li>系统断电</li>
</ul>
</li>
<li><p>系统故障的影响</p>
<ul>
<li>整个系统的正常运行突然被破坏</li>
<li>所有正在运行的事务都非正常终止 (所有活跃事务都只运行了一部分,没有全部完成)</li>
<li>内存中数据库缓冲区的信息全部丢失(部分已完成事务更新后的数据还在缓存区,没有来得及刷到硬盘上,这些更新就丢失了)</li>
<li>不破坏数据库</li>
</ul>
</li>
<li><p>系统故障的恢复</p>
<ul>
<li>发生系统故障时，事务未提交 （恢复策略：强行撤消（UNDO）所有未完成事务）</li>
<li>发生系统故障时，事务已提交，但缓冲区中的信息尚未完全写回到磁盘上。（恢复策略：重做（REDO）所有已提交的事务）<blockquote>
<p>系统故障的恢复需要做两件事情:</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>1.撤销所有未完成的事务<br>2.重做所有已提交的事务</p>
<ul>
<li>介质故障（硬故障，指外存故障）<ul>
<li>磁盘损坏</li>
<li>磁头碰撞</li>
<li>瞬时强磁场干扰</li>
</ul>
</li>
<li>介质故障破坏数据库或部分数据库,并影响正在存取这部分数据的所有事务</li>
<li>截至故障比前两类故障的可能性小得多,但破坏性大得多</li>
<li>介质故障的恢复<ul>
<li>装入数据库发生介质故障前某个时刻的数据副本</li>
<li>重做自此时始的所有成功事务，将这些事务已提交的结果重新记入数据库</li>
</ul>
</li>
</ul>
<ol start="4">
<li>计算机病毒</li>
</ol>
<ul>
<li>故障小结<br>  对各类故障，对数据库的影响有两种可能性：<ul>
<li>数据库本身被破坏</li>
<li>数据库没有被破坏，但数据可能不正确，这是由于事务的运行被非正常终止造成的</li>
</ul>
</li>
<li>恢复操作的基本原理: 冗余<br>利用存储在系统别处的冗余数据来重建数据库中已被破坏或不正确的那部分数据</li>
<li>恢复的实现技术: 复杂</li>
</ul>
<p>问: 系统故障会导致什么问题?</p>
<h5 id="恢复的实现技术"><a href="#恢复的实现技术" class="headerlink" title="恢复的实现技术"></a>恢复的实现技术</h5><ul>
<li><p>恢复机制涉及到的关键：</p>
<ul>
<li>如何建立冗余数据<ul>
<li>数据转储</li>
<li>登陆日志文件</li>
</ul>
</li>
</ul>
</li>
<li><p>数据转储</p>
<ul>
<li>转储是指DBA将整个数据库复制到磁带或另一个磁盘上保存起来的过程</li>
<li>备用的数据成为后备副本或后援副本</li>
<li>数据库遭到破坏后可以将后备副本重新装入</li>
<li>重装后备副本只能将数据库恢复到转储时的状态</li>
<li>要想恢复到故障发生时的状态,必须重新运行自转储后的所有更新事务</li>
</ul>
</li>
<li><p>转储方法</p>
<ul>
<li>静态转储<ul>
<li>系统中无运行事务时进行的转储操作</li>
<li>转储期间不允许对数据库进行操作</li>
<li>转储开始时数据库处于一致性状态</li>
<li>得到的一定是一个数据一致性的副本<blockquote>
<p>优点:实现简单<br>缺点：</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>1.降低了数据库的可用性<br>2.转储必须等待正运行的用户事务结束<br>3.新的事务必须等转储结束</p>
<ul>
<li>动态转储<ul>
<li>转储操作与用户并发进行</li>
<li>转储期间允许对数据库进行存取或修改<blockquote>
<p>优点：</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>1.不用等待正在进行的事务结束<br>2.转储期间允许对数据库进行存取或修改<br>缺点：不能保证副本中的数据正确有效</p>
<ul>
<li><p>动态转储进行故障恢复<br>需要把动态转储期间各事务对数据库的修改活动登记下来，建立日志文件<br>后备副本加上日志文件才能把数据库恢复到某一时刻的正确状态</p>
</li>
<li><p>海量转储<br>每次转储全部数据库</p>
</li>
<li><p>增量转储<br>只转储上次转储后更新过的数据</p>
</li>
</ul>
<p>海量转储与增量转储的比较</p>
<blockquote>
<p>1.从恢复角度看，使用海量转储得到的后备副本进行恢复往往更方便<br>2.如果数据库很大，事务处理又十分频繁，则增量转储更有效<br><img src="https://img-blog.csdnimg.cn/20190603175459427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3ODY1OA==,size_16,color_FFFFFF,t_70" alt></p>
</blockquote>
<ul>
<li>登陆日志文件</li>
<li>1.日志文件<br>记录事务对数据库的更新操作文件</li>
<li>格式：<ul>
<li>以记录为单位的日志文件（事务标识，操作类型，操作对象，更新前数据的旧值，更新后数据的新值）</li>
<li>以数据为单位的日志文件（事务标识，被更新的数据块）</li>
</ul>
</li>
<li>内容：<ul>
<li>各个事务的开始标记</li>
<li>各个事务的结束标记</li>
<li>各个事务所有的更新操作</li>
</ul>
</li>
<li>作用：<ul>
<li>进行事务故障恢复</li>
<li>进行系统故障恢复</li>
<li>协助后备副本进行介质故障恢复</li>
</ul>
</li>
</ul>
<p>2.利用静态转储副本和日志文件进行恢复<br><img src="https://img-blog.csdnimg.cn/20190603180545304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3ODY1OA==,size_16,color_FFFFFF,t_70" alt></p>
<p>对上图进行说明:</p>
<ol>
<li>系统在Ta时刻停止运行事务，进行数据库转储</li>
<li>在Tb时刻转储完毕，得到Tb时刻的数据库一致性副本</li>
<li>系统运行到Tf时刻发生故障</li>
<li>为恢复数据库，首先由DBA重装数据库后备副本，将数据库恢复到Tb时刻的状态</li>
<li>重新运行自Tb~Tf时刻的所有更新事务，把数据库恢复到故障发生前的一致状态</li>
</ol>
<ul>
<li>登记日志文件<br>基本原则：<blockquote>
<p>登记的次序严格按并行事务执行的时间次序<br>必须先写日志文件，后写数据库</p>
</blockquote>
</li>
</ul>
<h5 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h5><ul>
<li>事务故障的恢复<br>事务故障：事务运行至正常终止点前被终止<br>恢复方法：由恢复子系统利用日志文件撤销（UNDO）此事务已对数据库进行的修改</li>
</ul>
<p>注: 事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预</p>
<ul>
<li><p>恢复步骤:</p>
<ul>
<li>反向扫描文件日志（从后往前扫描），查找该事务的更新操作</li>
<li>对该事务的更新操作执行逆操作，即将日志记录中“更新前的值”写入数据库</li>
<li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。</li>
<li>如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。</li>
</ul>
</li>
<li><p>系统故障的恢复</p>
<ul>
<li>系统故障:<ul>
<li>未完成事务对 数据库的更新已写入数据库</li>
<li>提交事务对数据库的更新还留在缓存区没来得及写入数据库</li>
</ul>
</li>
<li>恢复方法:<ul>
<li>UNDO故障发生时未完成的事务</li>
<li>Redo已完成的事务<br>注:系统故障的恢复由系统在重新启动时自动完成，不需要用户干预</li>
</ul>
</li>
</ul>
</li>
<li><p>恢复步骤:</p>
<ul>
<li>正向扫描日志文件（</li>
</ul>
<p>  1.将在故障发生前已经提交的事务加入重做（REDO）队列，这些事务既有begin transaction记录，也有commit记录；<br>  2.将在故障发生时未完成的事务加入撤销（Undo）队列，这些事务中只有begin transaction记录，无相应的commit记录）</p>
<ul>
<li>撤销（Undo）队列事务进行撤销（Undo）处理（1.反向扫描日志文件，对每个undo事务的更新操作进行逆操作；2.将日志记录中“更新前的值”写入数据库）</li>
<li>对重做（Redo）队列事务进行重做（Redo）处理（1.正向扫描日志文件，对每个REDO事务重新执行登记的操作；2.将日志记录中“更新后的值”写入数据库）</li>
</ul>
</li>
<li><p>介质故障的恢复(需要DBA介入)</p>
</li>
</ul>
<ol>
<li>重装数据库</li>
<li>装入有关的日志文件副本,重做已完成的事务</li>
</ol>
<h5 id="具有检查点的回复技术"><a href="#具有检查点的回复技术" class="headerlink" title="具有检查点的回复技术"></a>具有检查点的回复技术</h5><ul>
<li><strong>解决问题</strong>：<ul>
<li>搜索整个日志将耗费大量的时间</li>
<li>REDO处理：重新执行，浪费了大量时间</li>
</ul>
</li>
<li><strong>解决方法</strong><ul>
<li>在日志文件中增加检查点记录</li>
<li>增加重新开始文件</li>
<li>恢复子系统在登录日志文件期间动态地维护日志<br><img src="https://img-blog.csdnimg.cn/20190603202218714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3ODY1OA==,size_16,color_FFFFFF,t_70" alt> </li>
</ul>
</li>
</ul>
<p>建立检查点：<br>恢复子系统可以定期或不定期地建立检查点,保存数据库状态<br>1.定期：按照预定的一个时间间隔，如每隔一小时建立一个检查点<br>2.不定期：按照某种规则，如日志文件已写满一半建立一个检查点<br>恢复:<br><img src="https://img-blog.csdnimg.cn/2019060320274211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3ODY1OA==,size_16,color_FFFFFF,t_70" alt="恢复"></p>
<ul>
<li><p>T1：在检查点之前提交</p>
</li>
<li><p>T2：在检查点之前开始执行，在检查点之后故障点之前提交</p>
</li>
<li><p>T3：在检查点之前开始执行，在故障点时还未完成</p>
</li>
<li><p>T4：在检查点之后开始执行，在故障点之前提交</p>
</li>
<li><p>T5：在检查点之后开始执行，在故障点时还未完成</p>
</li>
<li><p>利用检查点的恢复步骤</p>
<ul>
<li>1.从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录</li>
<li>2.由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST<ul>
<li>建立两个事务队列<br>undo-list<br>redo-list<br>把ACTIVE-LIST暂时放入UNDO-LIST队列，REDO队列暂为空。</li>
</ul>
</li>
<li>3.检查点开始正向扫描日志文件，直到日志文件结束<br>  如有新开始的事务Ti，把Ti暂时放入UNDO-LIST队列<br>  如有提交的事务Tj，把Tj从UNDO-LIST队列移到REDO-LIST队列</li>
<li>4.对UNDO-LIST中的每个事务执行UNDO操作<br>  对REDO-LIST中的每个事务执行REDO操作<h5 id="数据库镜像"><a href="#数据库镜像" class="headerlink" title="数据库镜像"></a>数据库镜像</h5></li>
</ul>
</li>
</ul>
<h3 id="2016-2017-如有错误-敬请指正-是应该这样说哈"><a href="#2016-2017-如有错误-敬请指正-是应该这样说哈" class="headerlink" title="2016-2017(如有错误,敬请指正??是应该这样说哈)"></a>2016-2017(如有错误,敬请指正??是应该这样说哈)</h3><p>一、单项选择题（25 题，每题 2 分）</p>
<ol>
<li><p>以下哪个选项是对脏读的描述？C<br>A.一个事务先后执行多次相同条件的查询，并且每次返回的数据都不相同。(不可重复读)<br>B.在一个事务期间，基于特定标准的搜索在执行连续搜索之后返回额外的行(幻影??)<br>C.一个事务读了另外一个事务修改还未提交的数据.(脏读)<br>D.两个事务读取并试图更新相同的数据，第二次更新将在第一次更新落实之前将其覆盖</p>
</li>
<li><p>C</p>
</li>
<li><p>如果使用下列语句创建tab1 CREATE TABLE tab1(<br>col1 INTEGER NOT NULL, col2 CHAR(3),<br>CONSTRAINT cst1 CHECK (col1 in (1,2,3,4)))<br>下列哪个语句会将记录成功插入表 TAB1？ <strong>C</strong><br>A.INSERT INTO tab1 VALUES (0, ‘a’)<br>B.INSERT INTO tab1 VALUES (NULL, ‘abc’)<br>C.INSERT INTO tab1 VALUES (4, ‘a’)<br>D.INSERT INTO tab1 VALUES (4, ‘abcdefhijklmnopq’)</p>
</li>
<li><p>数据库管理员需要在T1表中定义一个外关键字参考与T2表，下面描述正确是：C<br>A．在T1中外关键字属性可以是T2表的某个关键字属性的真子集。<br>B.在T1中外关键字属性名称必须与T2表的某个关键字属性名称相同。<br>C.在T1中外关键字属性的数据类型必须与T2表的某个关键字属性的数据完全相同（包括字符串的长度也要相同）<br>D.在T1中外关键字属性不能为空。(可以为空)</p>
</li>
<li><p>有T1和T2两个表，数据如下：<br>T1    T2</p>
</li>
</ol>
<p>C1    C2    C1    C2<br>5    4    5    1<br>5    2    5    2<br>5    5    5    3<br>下面哪个查询能够返回以下结果   (减法 B)<br>C1    C2<br>5    4<br>5    5</p>
<p>A.SELECT * FROM T1 MINUS SELECT * FROM T2<br>B.SELECT * FROM T1 EXCEPT SELECT * FROM T2<br>C.SELECT * FRM T2 UNION EXCEPT SELECT * FROM T1 (这是啥玩意??没见过)<br>D.SELECT * FROM T1 NOT EXISTS SELECT * FROM T2</p>
<ol start="6">
<li>下面哪个SQL语句可以引起触发器运行？  C<br>A. DROP    B. ALTER<br>C. DELETE    D. ROLLBACK<blockquote>
<p>update,delete,insert三种触发器</p>
</blockquote>
</li>
</ol>
<p>create trigger st<br>after update on &lt;表名&gt;<br>referencing<br>    new row as newrow<br>for each row<br>when()</p>
<ol start="7">
<li><p>下面关于索引说法正确的是？  B<br>A．索引可以提高insert语句的执行速度。<br>B．索引可以提高某些select语句的执行速度。<br>C．索引可以提高所有select语句的执行速度。<br>D．索引属性值不能为空。</p>
</li>
<li><p>张三需要在t1表上创建一个视图，在t1表上他最少需要什么权限： D<br>A. insert    B.    delete<br>C. query    D.    select</p>
<blockquote>
<p>知道视图咋建就应该知道这题咋写了.</p>
</blockquote>
</li>
<li><p>张三需要在t2表上定义一个外关键字，这个外关键字参考与t1表，下面说法正确的是： (我猜是 D)<br>A．张三需要有t2表上的select权<br>B．张三需要有t1表上的select权<br>C．张三需要有t2表上的references权<br>D．张三需要有t1表上的references权</p>
</li>
</ol>
<ol start="10">
<li><p>在使用JDBC编写的数据库应用中下面说法错误的是： D<br>Ａ．可以定义事务的隔离级<br>Ｂ．可以指定事务能否自动提交<br>Ｃ．可以调用数据库定义的存储过程<br>Ｄ．不能查询数据库中已有的表的名称</p>
</li>
<li><p>B?</p>
</li>
<li><p>关于第三范式描述正确的是 D<br>A.如果一个关系属于第三范式那么它没有数据冗余<br>B.一个关系模式不存在非主属性部分依赖,它就是属于第三范式<br>C.一个关系模式不存在非主属性传递依赖,它就是属于第三范式<br>D.一个关系模式属于 BC 范式,它就属于第三范式</p>
<blockquote>
</blockquote>
</li>
<li><p>下面视图定义是中哪个是可更新视图: D</p>
</li>
</ol>
<ul>
<li>A.Create view V1 as select    S.rating , avg(S.age) as avgage from Sailors S <code>group by</code> S.rating ()</li>
<li>B.Create view V2 as select    <code>*</code>    from saliros S1 where S.age &gt; 18 <code>union</code> select <code>*</code> from sailors S2 where S2.name like ‘%Tom’</li>
<li>C.Create view V3 as select    S.name, R.bid from Sailor R, Reserves R where S.sid=R.sid (有两个属性)</li>
<li>D.Create view V4 as select * from Boats B where B.bname like ‘%Happ%’(where子句不能用关系B)</li>
</ul>
<ol start="14">
<li><p>在数据库启动过程中恢复系统执行顺序是: (C)<br>A.分析阶段,取消阶段,重做阶段<br>B.取消阶段,分析阶段,重做阶段<br>C.分析阶段,重做阶段,取消阶段<br>D.取消阶段,重做阶段,分析阶段.</p>
<blockquote>
<p>分析,redo,undo</p>
</blockquote>
</li>
<li><p>一个企业有大量的数据需要存储在数据库中,由于某些原因要求存储的数据条带化分布,有冗余但冗余不能使用算法冗余.下面磁盘技术中采用哪种方法可以满足该要求: (D??)<br>A. RAID 0    B.RAID 1<br>C. RAID 0+1    D.RAID 5</p>
</li>
<li><p>在一个隔离级为读提交数据的事物中执行select * from sailors where 1=1查询，对该语句执行时在数据库中获得的锁下面哪个描述是最准确的？ (D??)<br>A.获得sailors表的S锁，记录上不加锁。<br>B.获得sailors表的IS锁及记录上的IS锁<br>C.获得sailors表的S锁及记录上的IS锁<br>D.获得sailors表的IS锁及记录上的S锁</p>
</li>
<li><p>数据库语言包括 DDL，DML 和DCL,下面哪个语句是 DML 语句: (D)<br>A.Create index<br>B.Drop table<br>C.Alter table<br>D.Update</p>
</li>
<li><p>有关系模式R(A,B,C)和三个合法实例(4,2,3),(4,2,3),(5,3,3),下面哪个函数依赖在关系模式R 上不成立  D<br>A.A-&gt;B    B.    BC-&gt;A    C. B-&gt;C    D. C-&gt;A</p>
</li>
<li><p>有关系模式R(A,B,C,D),其函数依赖集F={A-&gt;B,B-&gt;C,C-&gt;D,D-&gt;A},将R分解为AD，AB，BC请问该分解丢失了下面哪个函数依赖： C<br>A．A-&gt;C    B.B-&gt;D    C.C-&gt;D    D.没有丢失函数依赖</p>
</li>
<li><p>有关系模式R(A,B,C,D,E,F),其函数依赖集F={A-&gt;B,B-&gt;C,C-&gt;A,    D-&gt;E},在该关系模式上有几个关键字：C<br>A．1    B. 2    C.3    D.4</p>
<blockquote>
<p>L:D<br>R:<br>LR:ABC<br>N: F<br>DFA<br>DFB<br>DFC</p>
</blockquote>
</li>
<li><p>有关系模式 R(A,B,C,D,E),R 的函数依赖集 F={A-&gt; B,BC-&gt;E,ED-&gt;A},下面哪个说法是正确的: B<br>A.R 是BCNF    B.R 是 3NF<br>C.分解(ACD,BCE)是无损分解    D.分解(ABD,CDE)是无损分解</p>
<blockquote>
<p>ACD<br>BCD<br>EDC</p>
</blockquote>
</li>
<li><p>有关系模式 R(A,B,C,D)下面哪个函数依赖集使得 R 是 BCNF (D)<br>A. F={C-&gt;D,C-&gt;A,B-&gt;C}    B. F={ABC-&gt;D,D-&gt;A}<br>C. F={B-&gt;C,D-&gt;A}    D. F={AB-&gt;C,C-&gt;D,C-&gt;AB}</p>
</li>
<li><p>在遵循严格2PL锁(两阶段锁)的规则的情况下，下面哪个调度会出现死锁: (B)<br>A.T1:R(X),T2:W(X),T2:W(Y),T3:W(Y),T1:W(Y)<br>B T1:R(X),T2:W(Y),T2:W(X),T3:W(Y),T1:W(Y),<br>C T1:R(A),T2:W(B),T1:R(A),T3:R(C),T2:W(C),T4:W(A)<br>D.T1:R(A),T2:W(B),T3:W(C),T1: Commit,T2:W(A), T2:Commit,T3:W(B), T3:Commit</p>
</li>
<li><p>下面关于数据库事务处理描述正确的是:   C<br>A．原子性和一致性是由数据库的并发调度保证的.<br>B．隔离性和持久性是由数据库的并发调度保证的.<br>C．原子性和持久性是由数据库的恢复系统保证的<br>D．一致性和隔离性是由数据库的恢复系统保证的</p>
<blockquote>
<p>感觉隔离性和一致性保证并发调度</p>
</blockquote>
</li>
</ol>
<p>二．简单题（50 分）<br>在 mysql 中有 club 数据库，该数据库中有三个表分别是：</p>
<ul>
<li>Sailors(sid char(10),sname char(20),rating int,age int，gender char(2)),其中 sid 是主关键字，sid 表示水手的编号，sname 表示水手的姓名，rating 表示水手的级别，age 表示水手的年龄,gender 表示水手的性别。</li>
<li>Boats(bid char(10),bname char(20),color char(10)，),其中 bid 表示船的编号是主关键字，bname 是船的名字，color 是船的颜色。</li>
<li>Reserves(sid char(10),bid char(10),rdate date),Reserves 中记录水手在哪天订了那只船，其中 sid 是指向 Sailors 的外关字， bid 是指向 Boats 的外关键字,(sid,bid,rdate)合起来构成 Reserves 的主关键字。<br>用关系代数写出下面的查询                                                </li>
</ul>
<ol>
<li>查找只订过一艘红色船而没有订过其它颜色船的水手编号（该水手只订过一次船而且船的颜色是红色.）</li>
</ol>
<p>1)Boats 和 Reserves 做自然连接<br>找出 谁定了什么颜色的船 R1<br>2)Sailors 和 R1 做笛卡尔积<br>然后从中选出sid = sid2 and color = ‘red’ and color &lt;&gt; color2 R2<br>然后 Sailors 的 sid 减去 R2 的sid 即要查询的结果</p>
<p>用元组关系验算写出下面的查询</p>
<ol start="2">
<li>查找既订过红色船又订过绿色船水手的姓名和编号</li>
</ol>
<p>1)Boats 和 Reserves 做自然连接 bid,sid,color R1<br>2) R2是 R1重命名<br>3)R1×R2 后 color1=’red’,color2=’green’ sid1=sid2, R3<br>4)R3 和 Sailors 自然连接 R3.sid=S.sid 取出  s.sname和s.sid</p>
<p>用 SQL 语言写出下面的查询<br>3. 查找定了所有船的水手的编号和姓名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.sid,s.name</span><br><span class="line"><span class="keyword">from</span> saliors</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> b.bid </span><br><span class="line">    <span class="keyword">from</span> boats b</span><br><span class="line">    <span class="keyword">except</span> </span><br><span class="line">    <span class="keyword">select</span> r.bid</span><br><span class="line">    <span class="keyword">from</span> reserves r</span><br><span class="line">    <span class="keyword">where</span> r.sid=s.sid</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> s.sid,s.sname</span><br><span class="line">    <span class="keyword">from</span> sailors s</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">not</span> exist (</span><br><span class="line">            <span class="keyword">select</span> b.bid</span><br><span class="line">            <span class="keyword">from</span> boats b</span><br><span class="line">            <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">                    <span class="keyword">select</span> r.bid</span><br><span class="line">                    <span class="keyword">from</span> reserves r</span><br><span class="line">                    <span class="keyword">where</span> r.bid=b.bid</span><br><span class="line">                    <span class="keyword">and</span> r.sid=s.sid</span><br><span class="line">            )</span><br><span class="line">    )</span><br><span class="line">这个人如果都定过就不存在有没订过的船</span><br><span class="line"><span class="number">1</span>)找这人没定过的船,</span><br><span class="line"><span class="number">2</span>)没找到 <span class="keyword">not</span> exist 成立 选出这个人</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>查找订过红色船也订过绿色船水手的编号和姓名<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> s.sname <span class="keyword">from</span> sailors s,reserves r,boats b </span><br><span class="line"><span class="keyword">Where</span> s.sid=r.sid <span class="keyword">and</span> r.bid=b.bid <span class="keyword">and</span> b.color=’red’</span><br><span class="line"><span class="keyword">intersect</span> </span><br><span class="line"><span class="keyword">Select</span> s.sname <span class="keyword">from</span> sailors s,reserves r,boats b </span><br><span class="line"><span class="keyword">Where</span> s.sid=r.sid <span class="keyword">and</span> r.bid=b.bid <span class="keyword">and</span> b.color=’green’</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ul>
<li>students(sid: char(10),sname: char(20) , class:int)，Students 为软件学院 2015 级学生信息表，sid 表示学生的学号，sname 为学生的姓名，class 为学生的班级，sid 为主关键字。</li>
<li>course(cid:char(7),cname:string,teacher:string), Course 为软件学院 2015 级学生在2016-2017 学期可选课程信息表，cid 表示课程号,cname 表示课程名,teacher 表示教师，cid 是主关键字。</li>
<li>enrolled(sid:char(10),cid:char(7),grade:integer),Enrolled 为学生的选课信息表，sid 表示学号, cid 表示课程号, grade 表示成绩。<br>用 SQL 语言写出下面的查询</li>
</ul>
<ol start="5">
<li>统计各班学生的数据库原理的最高分。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(e.grade)</span><br><span class="line"><span class="keyword">from</span> students s,course c,enrolled e</span><br><span class="line"><span class="keyword">where</span> c.cid=e.cid <span class="keyword">and</span> cname= <span class="string">'数据库原理'</span> <span class="keyword">and</span> </span><br><span class="line">    s.sid = e.sid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.class</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="6">
<li>查找数据库原理课程平均分最高的班级中数据库原理课程的最低分。<br>创建一个视图??</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">min</span>(grade)</span><br><span class="line"> <span class="keyword">from</span> enrolled <span class="keyword">natural</span> <span class="keyword">join</span> students <span class="keyword">natural</span> <span class="keyword">join</span> course </span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">class</span></span><br><span class="line"> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">max</span>(grade) <span class="keyword">desc</span></span><br><span class="line"> <span class="keyword">limit</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>有关系模式 R(A,B,C,D,E,F,G,H,I),它的函数依赖集<br>F={AB-&gt;CD,A-&gt;E,B-&gt;FH,C-&gt;G,D-&gt;B,G-&gt;C,H-&gt;I}<br>7. 求解它的函数依赖集最小集<br>第一步: 拆右边<br>AB-&gt;C,AB-&gt;D,A-&gt;E,B-&gt;F,B-&gt;H,C-&gt;G,D-&gt;B,G-&gt;C,H-&gt;I<br>第二步: 拆左边?<br>第三步:算闭包?<br>去掉 AB-&gt;C 算 AB+: ABDEFHI 不能推出AB-&gt;C 保留<br>去掉 AB-&gt;D 算 AB+: ABCEFHGI 不能推出 AB-&gt;D 保留<br>去掉 A-&gt;E 算 A+ = AE<br>去掉 B-&gt;F 算  B+ =BHI<br>去掉 B-&gt;H 算 B+= BF<br>去掉 C-&gt;G 算 C+= CG<br>去掉 D-&gt;B 算 D+ = D<br>去掉 G-&gt;C 算 G+ = G<br>去掉 H-&gt;I 算 H+ = H 都保留<br>所以这就是 函数依赖集最小集是 (AB-&gt;C,AB-&gt;D,A-&gt;E,B-&gt;F,B-&gt;H,C-&gt;G,D-&gt;B,G-&gt;C,H-&gt;I)</p>
<ol start="8">
<li>将其分解为三范式，该分解要具有无损连接性和依赖保持性.<br>第一步:求最小依赖集 (AB-&gt;C,AB-&gt;D,A-&gt;E,B-&gt;F,B-&gt;H,C-&gt;G,D-&gt;B,G-&gt;C,H-&gt;I)<br>第二步:把每个依赖属性分解成一个关系<br>即(ABC),(ABD),(AE),(BF),(BH),(CG),(DB),(GC),(HI)<br>去掉(GC)<br>为: (ABC),(ABD),(AE),(BF),(BH),(CG),(DB),(HI)<br>L: A<br>R: E F I<br>LR:B C D G H<br>N:<br>第三步: 找关键字<br>A+ = AE<br>AB+ = ABCDEFGHI<br>AB在属性集内,所以三范式最后分解为 (ABC),(ABD),(AE),(BF),(BH),(CG),(DB),(HI)</li>
</ol>
<ol start="9">
<li>根据函数依赖公理即 Armstrong 公理，证明下面的定理 有关系模式 R，X,Y,W 是 R 的属性子集，如果 X-&gt;Y，YW-&gt;Z 成立，则 XW-&gt;Z 也成立。</li>
</ol>
<p>根据函数依赖的定义:因为X-&gt;Y,YW-&gt;Z成立,<br>所以对于关系模式R的任意一个实例中的两个元组<br>t1,t2.如果t1.X=t2.X那么t1.Y=t2.Y. 如果t1.Y=t2.Y.,t1.W=t2.W 那么t1.Z=t2.Z<br>所以  当 t1.X=t2.X,t1.w=t2.w,<br>则 t1.Z=t2.Z<br>所以 XW-&gt;Z </p>
<ol start="10">
<li>请详细描述数据库在启动时它的恢复算法</li>
</ol>
<p><strong>不考</strong></p>
<h3 id="2006-2007"><a href="#2006-2007" class="headerlink" title="2006-2007"></a>2006-2007</h3><h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><ol>
<li>关于数据库管理系统下面哪个描述是最正确的  C<br>A.数据库管理系统是数据的集合.<br>B.数据库管理系统是数据的集合,并且存储着数据与数据之间的关系.</li>
</ol>
<p><strong>C.数据库管理系统是由一个互相关联的数据的集合和一组用以访问这些数据的程序组成.</strong><br>D.数据库管理系统是由数据的集合和一组用以访问这些数据的程序组成</p>
<ol start="2">
<li><p>下面那项不是数据库管理系统组成部分:    D<br>A. 事务管理器          B.查询处理器.<br>C. 存储管理器            <strong>D.进程控制器.</strong></p>
</li>
<li><p>如果有两个关系T1,T2.客户要求每当给T2删除一条记录时,T1中特定记录就需要被改变,我们需要定义什么来满足该要求.   D<br>A.在T1上定义视图                B.在T2上定义视图<br>C.在T1和T2上定义约束        <strong>D.定义trigger</strong></p>
</li>
<li><p>关于数据库事务描述<strong>不正确</strong>的是  A</p>
</li>
</ol>
<p><strong>A. 一个事务中的所有对数据库的改变可以部分完成和部分不完成.</strong><br>B. 一个事务中的所有对数据库的改变必须全部完成或全部不完成.<br>C. 数据库的事务是不可以再次划分的.<br>D. 如果事务在完成前被中断,数据库管理系统能把那些由未完成事务所产生的数据变化从数据库中恢复<br>5. 某个企业的数据库包含以下信息:员工(由员工编号唯一确定,记为ssn),部门(由部门编号唯一确定记为did)员工工作在部门中,每个部门最多有一个管理者.下面哪个ER图能够正确的反映管理关系. B<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/ER1.png" alt></p>
<ol start="6">
<li>关于视图的描述下面说法哪些是正确的:  D<br>A. 数据库即存储视图的定义也存视图的数据.<br>B. 用带有聚集运算的SQL创建的视图是可更新视图 ×<br>C. 用带有group by字句的SQL创建的视图是可更新视图 ×                </li>
</ol>
<p><strong>D. 视图可以能在多个关系上创建</strong></p>
<ol start="7">
<li><p>某个企业的数据库包含以下信息.员工(由员工编号唯一确定,记为ssn),员工的子女<br>(属性为name,age),在双亲给定的情况下,每个孩子能由他的姓名唯一确定(假设他们的双亲中只有一个是公司的员工).一旦员工离开公司,那么企业不再对其子女信息感兴趣.下面哪个ER图能够正确的反映以上需求   B<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/ER2.png" alt> </p>
</li>
<li><p>如果将下面的ER图转换成数据库中的关系,那么在数据库中需要定义. D<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/ER3.png" alt></p>
<p>A. 2个关系                    B. 3个关系<br>C. 3个关系     ,1个断言        <strong>D. 2个关系,1个断言</strong></p>
</li>
<li><p>如果将下面的ER图转换成数据库中的关系(该ER图中要求员工的年龄在18到55岁之间),那么在数据库中至少需要定义.  B<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/ER4.png" alt><br>A. 3个关系,1个断言            B.2个关系,1个约束<br>C.3个关系                    D.2个关系</p>
</li>
</ol>
<ol start="10">
<li><p>我们在一个关系中 B<br>A.必须定义一个主关键字 (可以没有)         <strong>B.只能创建一个聚集索引(cluster index)</strong><br>C.只能创建一个稠密索引 ??        D.只能定义一个约束.(约束可以有很多)</p>
</li>
<li><p>在DBMS的关系中  B<br>A.关键字属性值可以为空            B.外关键字属性值可以为空<br>C.任何属性值都可以为空            D.任何属性值都不可以为空.</p>
<blockquote>
<p>关键字属性值不能为空,外关键字属性值可以为空</p>
</blockquote>
</li>
<li><p>下面关于外关键字描述不正确的是  C<br>A.外关键字必须是所参考表的主关键字.<br>B.外关键字属性必须与参考的属性是相同的数据类型</p>
</li>
</ol>
<p><strong>C.定义外关键字需要对所参考表拥有select权</strong><br>D.一个表中可以有多个外关键字.</p>
<ol start="13">
<li><p>我们在DBMS中记录数据库员工和员工工作信息,要求当某个员工离职后,数据库需要自动删除该员工的工作信息,在定义工作表时我们对于外关键字的删除规则应定义为 B<br>A. ON DELETE ROLLBACK            <strong>B.  ON DELETE CASCADE</strong><br>C.ON DELETE SET NULL            D.ON DELETE NO ACTION</p>
</li>
<li><p>在DBMS中执行GRANT update(col1) ON TABLE t.t1 TO user7,对于该语句下面哪个描述是正确的: B<br>A.user7可以在t1上定义视图    </p>
</li>
</ol>
<p><strong>B.user7可以更新t1中的col1属性的值</strong><br>C.user7在创建其他表时可以定义参考于t1中col1属性的外关键字<br>D.user7可以在t1中定义外关键字.<br>15. 关系模式R,R的属性集是{ABCDEG}有函数依赖集F={AB-&gt;C , C-&gt;A, BE-&gt;C, BC-&gt;D , CG-&gt;BD}计算(AB)的属性闭包.D<br>A. BDEG        B. BDC        C.  ABCDEG    <strong>D. ABCD</strong></p>
<ol start="16">
<li>staff的定义如下  C<br>id       INTEGER<br>name     CHAR(20)<br>dept     INTEGER<br>job      CHAR(20)<br>years    INTEGER<br>salary   DECIMAL(10,2)<br>comm     DECIMAL(10,2)<br>下面哪个语句可以按照job和salary的升序排序来返回所有员工的信息.<br>A. SELECT id,name,salary,dept,job,years,comm FROM staff ORDER BY 4,6<br>B. SELECT id,name,salary,dept,job,years,comm FROM staff GROUP BY 4,6</li>
</ol>
<p><strong>C. SELECT id,name,salary,dept,job,years,comm FROM staff ORDER BY 5,3</strong><br>D. SELECT id,name,salary,dept,job,years,comm FROM staff GROUP BY 5,3</p>
<ol start="17">
<li><p>关系模式Sailors(sid,lastname,firtname,age,ratring)其中lastname允许为空. 下面哪个语句能够查找出lastname属性值不为空的水手信息. C<br>A. SELECT * FROM SAILORS WHERE LASTNAME&lt;&gt;’NULL’<br>B. SELECT * FROM SAILORS WHERE LASTNAME&lt;&gt;NULL<br><strong>C. SELECT * FROM SAILORS WHERE LASTNAME IS not NULL</strong><br>D. SELECT * FROM SAILORS WHERE LASTNAME not LIKE ’NULL’</p>
</li>
<li><p>关系模式Sailors(sid,sname,age,ratring)下面哪个语句能够查找出sname属性值至少为四个字符长,并且开始和结束字符都是B的水手信息. B<br>A.SELECT * FROM SAILORS WHERE sname like ’B%%_B’</p>
</li>
</ol>
<p><strong>B.SELECT * FROM SAILORS WHERE sname like’B__%B’</strong><br>C. SELECT * FROM SAILORS WHERE sname like ’B??<em>B’<br>D. SELECT * FROM SAILORS WHERE sname like’B*</em>?B’</p>
<ol start="19">
<li><p>有关系模式R(A,B,C,D,E),R的函数依赖集F={A-&gt;BC,CB-&gt;E,B-&gt;D,E-&gt;A}下面哪个分解具有无损连接性.  B<br>A. (A,D,C),(A,B,C)                B. (A,B,C),(B,C,D,E)<br>C. (A,B,D),(C,D,E)                D. (B,C,D),(A,D,E)    </p>
</li>
<li><p>有关系模式R(A,B,C)和三个合法实例(6,4,6),(6,4,6),(7,4,8),下面哪个函数依赖在关系模式R上不成立  C<br>A.  A-&gt;B        B.  BC-&gt;A        C. B-&gt;C        D. C-&gt;A.</p>
</li>
<li><p>设有关系模式R(B,I,S,Q,D),其上函数依赖集F={S-&gt;D,I-&gt;B,IS-&gt;Q,B-&gt;Q,B-&gt;I}下面那些是R的关键字. A</p>
</li>
</ol>
<p><strong>A.IS</strong>        B.IB        C.IQ     D.ISB</p>
<blockquote>
<p>求闭包<br>IS+ = ISDBQ</p>
</blockquote>
<ol start="22">
<li><p>下面哪个改变可以通过alter table实现 D<br>A. 增加一个触发.        B. 增加一个索引.<br>C. 增加一调记录         <strong>D. 定义一个候选关键字</strong></p>
</li>
<li><p>下面的语句按顺序成功执行后  </p>
</li>
</ol>
<ul>
<li>CREATE TABLE tab1 (c1 CHAR(1))</li>
<li>INSERT INTO tab1 VALUES (‘b’)</li>
<li>CREATE VIEW view1 AS SELECT c1 FROM tab1 WHERE c1 =’a’</li>
<li>INSERT INTO view1 VALUES (‘a’)</li>
<li>INSERT INTO tab1 VALUES (‘b’)<br>  执行SELECT c1 FROM tab1可以选择出多少条记录  D<br>A.0                B.1                C.2                D.3<blockquote>
<p>OK</p>
</blockquote>
</li>
</ul>
<ol start="24">
<li>有一个关系模式employee(name,department,phone_number),下面哪句话允许user1可以修改phone_number列的值  C<br>A. GRANT MODIFY (phone_number) ON TABLE employee TO user1<br>B. GRANT ALTER (phone_number) ON TABLE employee TO user1</li>
</ol>
<p><strong>C. GRANT UPDATE (phone_number) ON TABLE employee TO user1</strong><br>D. GRANT REFERENCES (phone_number) ON TABLE employee TO user1</p>
<ol start="25">
<li>数据库中SAILORS表是由joe创建的.在DBMS完成下面的语句后 D</li>
</ol>
<ul>
<li>Grant select on Sailors To Art With Grant option—Joe执行</li>
<li>Grant select,update on Sailors To Bob With Grant option—Joe执行</li>
<li>Grant select on Sailors To Bob With Grant option—Art执行</li>
<li>Revoke select on Sailors From Art Cascade—Joe执行<br>Bob对Sailors表拥有<br>A. select权        B. Update权        C.没有任何权利    <strong>D.select和Update权</strong>  </li>
</ul>
<ol start="26">
<li><p>在使用数据库中使用索引的目的是: B  ? ?<br>A.提高数据文件的存储率.    <strong>B.可以更加有效的控制事务处理中的幻影问题.</strong><br>C.增加DBMS的安全性.        D.提高增加记录的效率.</p>
<blockquote>
<p>提高查询速度</p>
</blockquote>
</li>
<li><p>下面哪种文件格式对不等值搜索的效率最高 B<br>A.无序文件        <strong>B.排序文件</strong>        C.哈希文件        D.队列文件</p>
</li>
<li><p>下面关于主关键字描述不正确的是:  D<br>A.在表中可以通过主关键字唯一的确定一条记录.<br>B.主关键字可以由多个属性组成.<br>C.组成主关键字的属性值不能空. </p>
</li>
</ol>
<p><strong>D.一个表中可以有多个主关键字</strong></p>
<ol start="29">
<li>关于第三范式描述正确的是 B<br>A.一个关系属于第第一范式,它就属于第三范式</li>
</ol>
<p><strong>B. 一个关系模式属于BC范式,它就属于第三范式</strong><br>C. 一个关系实例有数据冗余,它就是属于第三范式<br>D.一个关系实例没有数据冗余,它就是属于第三范式</p>
<ol start="30">
<li>下面哪个调度是串行调度: B<br>A. T1:R(A),T2:R(B),T2:W(B),T1:W(A)</li>
</ol>
<p><strong>B. T1:R(B),T1:W(B),T2:R(A), T2:W(A)</strong><br>C. T1:R(A),T2:R(B),.T1:W(A),T2:W(B)<br>D. T2:R(A),T1:R(B),.T1:W(A),T2:W(B)</p>
<ol start="31">
<li>下面关于数据库事务处理描述错误的是: C<br>A.原子性:表示的是事务的所有操作在数据库中要么全部正确反映出来要么全部不反映.<br>B.一致性:事务在执行前如果数据库是一致性的那么执行后也是一致性的.</li>
</ol>
<p><strong>C.隔离性:事务在执行过程中可以感觉到系统中其他事务的执行</strong><br>D. 持久性:一个事务成功完成后,它对数据库的改变必须是永久的,即使是系统出现故障时也如此.</p>
<ol start="32">
<li>下面关于数据库事务处理描述正确的是:  C<br>A.原子性和一致性是由数据库的并发控制保证的.<br>B.隔离性和持久性是由数据库的并发控制保证的.</li>
</ol>
<p><strong>C.原子性和持久性是由数据库的恢复系统保证的</strong><br>D.一致性和隔离性是由数据库的恢复系统保证的</p>
<ol start="33">
<li>数据库系统的log中检查点的作用是: D<br>A.系统事务取消时数据库关系系统需要重检查点开始取消.<br>B.系统事务正确完成时数据库系统会在log中设置检查点.<br>C.数据库重新启动时恢复系统中的重做阶段从检查点开始.</li>
</ol>
<p><strong>D.数据库重新启动时恢复系统中的分析阶段从检查点开始</strong></p>
<ol start="34">
<li>下面哪个说法符合数据库系统WAL(log先写协议):  D<br>A.数据库内存中被事务修改的页面在事务成功完成时被强制写到磁盘中<br>B.数据库内存中被事务修改的页面在事务撤销时被写到标记为非脏页<br>C.事务成功完成时不需要将与其相关的log页面强制写回磁盘</li>
</ol>
<p><strong>D.事务中被修改的内存数据页面在写回磁盘前必须将与其相关的log写回磁盘</strong></p>
<ol start="35">
<li>一个企业提供了一个查询数据库,该数据库的数据可以很容易的重新构造.为了提供数据库中磁盘数据的访问速度,下面磁盘技术中采用哪种方法可以满足该要求: A</li>
</ol>
<p><strong>A. RAID 0</strong>        B.RAID 1    C. RAID 0+1        D.RAID 5</p>
<ol start="36">
<li><p>一个企业有大量的数据需要存储在数据库中,企业要求数据的稳定性存储和数据开速访问,但不想使用太多的磁盘进行冗余存储,下面磁盘技术中采用哪种方法可以满足该要求: D<br>A. RAID 0        B.RAID 1    C. RAID 0+1        <strong>D.RAID 5</strong></p>
</li>
<li><p>在JDBC提供的数据库编程方法中提供了几种JDBC和数据库的连接方法: C<br>A.5            B.2            <strong>C.4</strong>        D.1</p>
</li>
</ol>
<p>A．在死锁预防中，等待–死亡法是中止优先级高的事务 (终止优先级低的)<br>B．在死锁预防中，受伤–等待法是优先级高的事务可能等待优先级低的事务释放锁<br><strong>C．使用死锁预防的系统中不会出现死锁。</strong><br>D．使用死锁判断的系统会不会出现死锁。???</p>
<ol start="39">
<li>下面那个说法正确的是 B<br>A. 在嵌入式SQL编程中所有的查询都必须使用游标。</li>
</ol>
<p><strong>B. 如果内存中的某一页的pin_count=0,dirty=true,则该页在替换时该页的数据必须写会磁盘。</strong><br>C. Create table tab1( a int, b int ,c int ,primary key (a,b))  create table tab2(a int , c int, d int, foreign key(a) reference tabl(a))语句可以在DBMS中执行成功  //因为a不是主键<br>D. 如果关系模式R的每一个函数依赖XA都使得下面两个条件中的一个成立则该关系模式满足BC范式。条件:1.XA是平凡函数依赖 2.X是一个关键字</p>
<ol start="40">
<li>数据库系统管理员按照事务的方式执行下面的语句：C</li>
</ol>
<ul>
<li>Create table tab1 (a int,b int)</li>
<li>insert into tabl values(1,2)</li>
<li>insert into tab1 values(2,3)</li>
<li>commit </li>
<li>Insert into tab1 values(2,3)</li>
<li>Insert into tab1 values(1,6)</li>
<li>Commit </li>
<li>Delete from tab1 where a=1</li>
<li>Insert into tab1 values(1,7)</li>
<li>Delete from tab1 where a=1</li>
<li>Insert into tab1 values(1,8)<br>数据库系统突然崩溃，系统重新启动后，该管理员执行<br>Select count(<em>) from tab1<br>数据库系统的输出是多少：<br>A. 6        B.3        *</em>C.4**        D.5<br>???</li>
</ul>
<ol start="41">
<li>下面关于索引说法正确的是: A</li>
</ol>
<p><strong>A. 聚集索引必然是稠密索引</strong><br>B. 在数据库中只能创建一个稀松索引?<br>C.     在数据库中只能创建一个聚集索引<br>D. 索引文件中一定不包括记录的详细数据</p>
<ol start="42">
<li>有关系模式R(A,B,C,D,E),R的函数依赖集F={A-&gt;B,BC-&gt;E,ED-&gt;A},下面哪个说法是正确的: B<br>A.R是BCNF                     B.R是3NF<br>C.分解(ACD,BCE)是无损分解        D.分解(ABD,CDE)是无损分解<br>用眼看!<br><a href="https://blog.csdn.net/suguoliang/article/details/80880923" target="_blank" rel="noopener">例子</a></li>
<li>有关系模式R(A,B,C,D)下面哪个函数依赖集使得R索引<strong>不是</strong>BCNF BC<br>A. F={AB-&gt;CD,C-&gt;ABD }        B. F={ABC-&gt;D,D-&gt;A}<br>C. F={B-&gt;C,D-&gt;A}            D. F={AB-&gt;C,C-&gt;D,C-&gt;AB}</li>
</ol>
<p><strong>BCNF是左边必须是超键，3NF是左边是超键或者右边是主属性</strong></p>
<p>44.下面关于数据库事务并发调度正确的是 BD<br>A. 冲突可串行化调度一定是观测可串行化调度<br><strong>B. 冲突可串行化调度一定与某种串行调度的结果一样.</strong><br>C. 观测可串行化调度调度可以通过画图来判断<br><strong>D. 冲突可串行化调度可以通过画图来判断</strong></p>
<p>45.有两个关系TAB1,TAB2<br>    TAB1           |            TAB2<br>C1     C2            |       CX     CY<br>—    —-         |            —–  —-<br>A      11            |        A      21<br>B      12            |        C      22<br>C      13            |<br>   结果集如下<br>C1     C2  |  CX     CY<br>—-   —- |    —-   —-<br> A     11   | A      21<br> C     13   | C      22<br>哪个SQL语句能够生成该结果 AB<br><strong>A. SELECT * FROM tab1 right OUTER JOIN tab2 ON c1=cx</strong><br><strong>B. SELECT * FROM tab1 INNER JOIN tab2 ON c1=cx</strong><br>C. SELECT * FROM tab1 FULL OUTER JOIN tab2 ON c1=cx<br>D. SELECT * FROM tab1 LEFT OUTER JOIN tab2 ON c1=cx</p>
<p>46下面视图定义是中哪个是可更新视图 D<br>A.Create view V1 as select  S.rating , max(S.age) as avgage from Sailors S group by S.rating<br>B.Create view V2 as select  *  from saliros S1 where S.age&gt;18 expect select * from sailors S2 where S2.name like ‘%Tom’<br>C.Create view V3 as select  S.name, B.bname from Sailor, Boats where S.sid=B.sid<br><strong>D.Create view V4 as select * from Bailors B where B.name is not null</strong></p>
<p>47 下面哪个SQL正确表示查找红色船被订船情况. CD<br>A.Select * from Reserves R,Boat B where R.bid=B.bid and b.color=’red’<br>B.Select * from Reserves R, inner join Boats B on R.bid=B.bid where b.color=’red’<br><strong>C.Select * from Reserves R, right outer join Boats B on R.bid=B.bid and b.color=’red’</strong><br><strong>D.Select * from Reserves R, full outer join Boats B on R.bid=B.bid  and  S.age&gt;17</strong></p>
<ol start="48">
<li>下面说法正确的是: CD<br>A.在任何情况下严格的2PL锁能够保证调度的可串行化.<br>B.在一个表作查询时需要先给符合条件的查询上记录加上S锁然后给表加上IS锁.</li>
</ol>
<p><strong>C.在一个表作查询时需要先给表加上IS锁然后给符合条件的查询上记录加上S锁</strong><br><strong>D.在一个表上同时可以加上IS锁和IX锁</strong></p>
<ol start="49">
<li>下面哪个调度会出现死锁: A</li>
</ol>
<p><strong>A.T1:R(X),T2:W(X),T2:W(Y),T3:W(Y),T1:W(Y),T1:Commit, T2:Commit, T3:Commit</strong><br>B T1:R(X),T2:W(Y),T2:W(X),T3:W(Y),T1:W(Y), T1:Commit, T2:Commit, T3:Commit<br>C T1:R(A),T2:W(B),T1:R(A),T3:R(C),T2:W(C),T4:W(A),T3:W(B)<br>D.T1:R(A),T2:W(B),T3:W(C),T1: Commit,T2:W(A), T2:Commit,T3:W(B), T3:Commit</p>
<blockquote>
<p>卧槽真难<br>我就感觉 D 没有死锁</p>
</blockquote>
<ol start="50">
<li>下面哪个调度是冲突可串行的调度 ABD<br>A. T1:R(X),T1:R(Y),T1:W(X),T2:R(Y),T3:W(Y),T1:W(X),T2:R(Y)<br>B. T1:R(X),T2:R(Y),T3:W(X),T2(R(X),T1:R(X)<br>C. T1:R(X),T2:R(X),T1:W(X),T2:W(X)<br>D. T1:W(X),T2:R(Y),T1:R(Y),T2:R(X)<blockquote>
<p>A可以吗?<br>B可以?<br>C不可以我知道<br>D可以我也知道</p>
</blockquote>
</li>
</ol>
<h4 id="解答题"><a href="#解答题" class="headerlink" title="解答题"></a>解答题</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">有关系有关系模式</span><br><span class="line">- Sailors(sid:integer,sname:string,rating:integer),</span><br><span class="line">- Boats(bid:interger,bname:string,color:string)</span><br><span class="line">- Reserves(sid:integer,bid:integer,day:datetime)</span><br><span class="line">各关系模式的关键字用下划线表示，</span><br><span class="line">其中Reserver的关键字中sid来自Sailors，bid来自Boats，Reserver的记录表示水手的订船记录。</span><br><span class="line"></span><br><span class="line">1.请用关系代数表达式写出下面的查询（4分）</span><br><span class="line">  查找只定过同一艘船的水手的sid。</span><br><span class="line"></span><br><span class="line">不会写,答案也没看懂! </span><br><span class="line"></span><br><span class="line">2.用元组关系演算表达式写出下面的查询(2分)</span><br><span class="line">  查找定了红色船的水手的sid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3．请用SQL语句写出下面的查询（16分）</span><br><span class="line">  1) 查找订过红色船或订过绿色船水手的姓名(3分)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">Select</span> s.sname <span class="keyword">from</span> sailors s,reserves r,boats b </span><br><span class="line"><span class="keyword">Where</span> s.sid=r.sid <span class="keyword">and</span> r.bid=b.bid <span class="keyword">and</span> (b.color=’red’ <span class="keyword">or</span> b.color=’green’)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)将水手按级别(rating)分组,查找平均年龄最小的级别组(<span class="number">6</span>分)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Select</span> temp.rating,temp.avg_age</span><br><span class="line"><span class="keyword">From</span> (<span class="keyword">select</span> rating,<span class="keyword">avg</span>(age) <span class="keyword">as</span> avg_age <span class="keyword">from</span> sailors </span><br><span class="line">      <span class="keyword">Group</span> <span class="keyword">by</span> rating) <span class="keyword">as</span> temp</span><br><span class="line"><span class="keyword">Where</span> temp.avg_age=</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">min</span>(temp1.avg_age) <span class="keyword">from</span> temp temp1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) 查找定了所有红色船的水手的姓名(<span class="number">6</span>分)</span><br><span class="line"><span class="keyword">Select</span> s.sname  <span class="keyword">from</span> sailors s</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> b.bid <span class="keyword">from</span> boats b <span class="keyword">where</span> b.color=’red’ <span class="keyword">except</span> </span><br><span class="line">               <span class="keyword">Select</span> r.bid <span class="keyword">from</span> reserves r <span class="keyword">where</span> r.sid=s.sid)</span><br><span class="line"></span><br><span class="line">定了的红色船 - 所有的红色船 = <span class="literal">null</span> 那就说明定了所有的红色船</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>．有关系模式</span><br><span class="line">- employees(ssn:<span class="built_in">char</span>(<span class="number">10</span>),<span class="keyword">name</span>:<span class="built_in">char</span>(<span class="number">20</span>),age:<span class="built_in">int</span>),其中ssn是employees的主关键字，</span><br><span class="line">- departments(did:<span class="built_in">char</span>(<span class="number">5</span>),dname:<span class="built_in">char</span>(<span class="number">20</span>)), 其中did是departments的主关键字.</span><br><span class="line">- work_in( ssn:<span class="built_in">char</span>(<span class="number">10</span>),did:<span class="built_in">char</span>(<span class="number">5</span>),<span class="keyword">from</span>:<span class="built_in">date</span>,<span class="keyword">to</span>:<span class="built_in">date</span>), 其中(ssn,did,<span class="keyword">from</span>,<span class="keyword">to</span>)是work_in的主关键字,did,ssn分别是指向deparments,employess的外关键字。</span><br><span class="line"></span><br><span class="line">表示员工在某段时间内工作与某个部门。另外还要求每个的员工都要工作与某个部门，每个部门都要有人工作。请用<span class="keyword">SQL</span>语句创建work_in关系，并表达出每个的员工都要工作与某个部门，每个部门都要有人工作这个约束条件。（<span class="number">5</span>分）</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> work_in(</span><br><span class="line">   ssn   <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">   did   <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">   <span class="keyword">from</span>  <span class="built_in">date</span>,</span><br><span class="line">   <span class="keyword">to</span>    <span class="built_in">date</span>,</span><br><span class="line">   primary <span class="keyword">key</span>(ssn,did,<span class="keyword">from</span>,<span class="keyword">to</span>),</span><br><span class="line">   <span class="keyword">foreign</span> <span class="keyword">key</span> ssn <span class="keyword">reference</span> employees,</span><br><span class="line">   <span class="keyword">foreign</span> <span class="keyword">key</span> did <span class="keyword">reference</span> departments)</span><br><span class="line"><span class="keyword">create</span> assert e_d( </span><br><span class="line">    <span class="keyword">check</span>(<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> departments=<span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> did) <span class="keyword">from</span> work_in) <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">check</span>(<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> employees=<span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">sid</span>) <span class="keyword">from</span> work_in)</span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 请用Armstrong公理证明，若X-&gt;Y,Y-&gt;Z.则X-&gt;Z(<span class="number">5</span>分)</span><br><span class="line">&gt;根据函数依赖的定义:因为X-&gt;Y,Y-&gt;Z成立所以对于关系模式R的任意一个实例中的任意两个元组</span><br><span class="line">t1,t2.如果t1.X=t2.X那么t1.Y=t2.Y.如果t1.Y=t2.Y 那么t1.Z=t2.Z.</span><br><span class="line">所以对于任意的两个元组t1,t2 当t1.X=t2.X 则t1.Z=t2.Z</span><br><span class="line">所以XZ</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 设有关系模式R，F=&#123;A-&gt;C,C-&gt;A,B-&gt;AC,D-&gt;AC,BD-&gt;A&#125;是R的函数依赖集(<span class="number">8</span>分)</span><br><span class="line">&gt;<span class="number">1</span>)请求出R的函数依赖最小集（<span class="number">5</span>分）</span><br><span class="line">先将函数依赖的右边变成单个属性</span><br><span class="line">F=&#123; A-&gt;C,C-&gt;A ,B-&gt;A,B-&gt;C,D-&gt;A,D-&gt;C,DB-&gt;A&#125;</span><br><span class="line">除去函数依赖左边的多于属性</span><br><span class="line">因为AC,CA ,BA,BC,DA,DC左边都是单个属性不用检查</span><br><span class="line">对于DB-&gt;A,除去D后,B的属性闭包=BAC 包括A 所以D是多余属性则DB-&gt;A变成,B-&gt;A</span><br><span class="line">所以函数依赖集变为F1=&#123; AC,CA ,BA,BC,DA,DC&#125;</span><br><span class="line">除去多余的函数依赖</span><br><span class="line">a. 去掉A-&gt;C 在F1-&#123;A-&gt;C&#125;中 A的属性闭包=A 所以AC不是多于依赖</span><br><span class="line">b. 去掉C-&gt;A 在F1-&#123;C-&gt;A&#125;中 C的属性闭包=C 所以CA不是多于依赖</span><br><span class="line">c. 去掉B-&gt;A 在F1-&#123;B-&gt;A&#125;中 B的属性闭包=BCA 所以BA是多于依赖F1=&#123; A-&gt;C,C-&gt;A , B-&gt;C,D-&gt;A,D-&gt;C&#125;</span><br><span class="line">d. 去掉C-&gt;A 在F1-&#123;B-&gt;C&#125;中 B的属性闭包=B 所以BC不是多于依赖</span><br><span class="line">e. 去掉D-&gt;A 在F1-&#123;D-&gt;A&#125;中D的属性闭包=DCA 所以DA是多于依赖F1=&#123; A-&gt;C,C-&gt;A , B-&gt;C,D-&gt;C&#125;</span><br><span class="line">R的函数依赖最小集是 F’=&#123; A-&gt;C,C-&gt;A , B-&gt;C,D-&gt;C&#125;</span><br><span class="line">[click](https://blog.csdn.net/sumaliqinghua/article/details/<span class="number">86246762</span>)</span><br><span class="line">- 右侧编程单个属性</span><br><span class="line">- 删除多余属性</span><br><span class="line">- 再拆左边非单属性</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)找出一个关键字,并证明其是关键字(<span class="number">3</span>分)</span><br><span class="line">&gt;BD是一个关键字.</span><br><span class="line">因为BD的属性闭包=BDCA 是R的属性全集</span><br><span class="line">B的属性闭包是BCA不是R的属性全集</span><br><span class="line">D的属性闭包是DCA不是R的属性全集</span><br><span class="line">这样不存在BD的真子集也能是的该真子集的属性闭包是R的属性全集所以BD是R的关键字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 并发控制</span></span><br><span class="line">- 多用户数据库系统</span><br><span class="line">    允许多个用户同时使用的数据库系统</span><br><span class="line">    - 特点: 在同一时刻并发运行的事务数可达数百上千个</span><br><span class="line">- 多事务执行方式</span><br><span class="line">    - 事务串行执行</span><br><span class="line">        - <span class="number">1.</span>每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行</span><br><span class="line">        - <span class="number">2.</span>不能充分利用系统资源，发挥数据库共享资源的特点</span><br><span class="line">    - 交叉并发方式    </span><br><span class="line">        - <span class="number">1.</span>在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行</span><br><span class="line">        - <span class="number">2.</span>单处理机系统中的并行事务并没有真正地并行运行事务，但能够减少处理机的空闲时间，提高系统的效率</span><br><span class="line">    - 同时并发方式</span><br><span class="line">        - 多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行</span><br><span class="line">        - 最理想的并发方式,但受制于硬件环境</span><br><span class="line">        - 更复杂的并发方式机制</span><br><span class="line">- 事务并发执行带来的问题</span><br><span class="line">    - 会产生多个事务同时存取同一数据的情况</span><br><span class="line">    - 可能会存取和存储不正确的数据，破坏事务一致性和数据库的一致性</span><br><span class="line">- DBMS必须提供并发控制机制</span><br><span class="line">- 并发控制机制是衡量一个DBMS性能的重要标志直之一</span><br><span class="line"><span class="comment">##### 并发控制的概述</span></span><br><span class="line">**事务时并发控制的基本单位**</span><br><span class="line">- 并发控制机制的任务</span><br><span class="line">    - 对并发操作进行正确调度</span><br><span class="line">    - 保证事务的隔离性</span><br><span class="line">    - 保证数据库的一致性</span><br><span class="line">- 并发操作带来的数据不一致性</span><br><span class="line">    - 丢失修改</span><br><span class="line">![](https://rlj<span class="number">-1999</span><span class="number">-1259282223.</span>cos.ap-beijing.myqcloud.com/%E6%<span class="number">95</span>%B0%E6%<span class="number">8</span>D%AE%E5%BA%<span class="number">93</span>/%E4%B9%A0%E9%A2%<span class="number">98</span>/s1.png)</span><br><span class="line">    两个事务T1和T2读入同一数据并修改，T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失</span><br><span class="line">    - 不可重复读 </span><br><span class="line">        包括三种情况</span><br><span class="line">        - 事务T1读取某一数据后，**事务T2对其做了修改**，当事务T1再次读该数据时，得到与前一次不同的值 (读-修改)</span><br><span class="line">![](https://rlj<span class="number">-1999</span><span class="number">-1259282223.</span>cos.ap-beijing.myqcloud.com/%E6%<span class="number">95</span>%B0%E6%<span class="number">8</span>D%AE%E5%BA%<span class="number">93</span>/%E4%B9%A0%E9%A2%<span class="number">98</span>/s2.png)</span><br><span class="line">            - T1读取B=<span class="number">100</span>进行运算</span><br><span class="line">            - T2读取同一数据B，对其进行修改后将B=<span class="number">200</span>写回数据库。</span><br><span class="line">            - T1为了对读取值校对重读B，B已为<span class="number">200</span>，与第一次读取值不一致</span><br><span class="line">        - 事务T1按一定条件从数据库中读取了某些数据记录后，**事务T2删除了其中部分记录**，当T1再次按相同条件读取数据时，发现某些记录消失了 (读-删除)</span><br><span class="line">        - 事务T1按一定条件从数据库中读取某些数据记录后，**事务T2插入了一些记录**，当T1再次按相同条件读取数据时，发现多了一些记录。(读-插入)</span><br><span class="line">    **读插入和读删除有时也叫做幻影现象.</span><br><span class="line">    - 读 脏数据</span><br><span class="line">        - 事务T1修改某一数据，并将其写回磁盘</span><br><span class="line">        - 事务T2读取同一数据后，T1由于某种原因被撤销</span><br><span class="line">        - 这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致</span><br><span class="line">        - T2读到的数据就为“脏”数据，即不正确的数据</span><br><span class="line">        ![](https://rlj<span class="number">-1999</span><span class="number">-1259282223.</span>cos.ap-beijing.myqcloud.com/%E6%<span class="number">95</span>%B0%E6%<span class="number">8</span>D%AE%E5%BA%<span class="number">93</span>/%E4%B9%A0%E9%A2%<span class="number">98</span>/s3.png)</span><br><span class="line">        - T1将C值修改为<span class="number">200</span>，T2读到C为<span class="number">200</span></span><br><span class="line">        - T1由于某种原因撤销，其修改作废，C恢复原值<span class="number">100</span></span><br><span class="line">        - 这时T2读到的C为<span class="number">200</span>，与数据库内容不一致，就是“脏”数据</span><br><span class="line">- 数据不一致性: **由于并发操作破坏了事务的隔离性**</span><br><span class="line">- 并发控制就是要用**正确的方式调度并发操作**，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性</span><br><span class="line">- 对 数据库的应用有时允许有些不一致性,可以降低对一致性要求以减少系统开销</span><br><span class="line">- 并发控制的主要技术</span><br><span class="line">    - 封锁</span><br><span class="line">    - 时间戳</span><br><span class="line">    - 乐观控制法</span><br><span class="line">    - 多版本并发控制 (MVCC)</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 封锁</span></span><br><span class="line">- 基本封锁类型</span><br><span class="line">    - 排它锁 X锁</span><br><span class="line">    - 共享锁 S锁</span><br><span class="line"></span><br><span class="line">- 排它锁</span><br><span class="line">    - 若事务T对数据对象A加上X锁,则只允许T读取和修改A,其他任何事务都不能再对A加任何类型的锁,直到T释放A上的锁.</span><br><span class="line">    - 保证其他事务在T释放A上的锁之前不能再读取和修改A</span><br><span class="line">    - 排它锁又称写锁</span><br><span class="line">- 共享锁</span><br><span class="line">    - 若事务T对数据对象A机上S锁,则事务T可以读但不能修改A,其他事务只能再对A加S锁,而不能再加X锁,知道T释放A上的S锁</span><br><span class="line">    - 保证其他事务可以读A,但在T释放A上的S锁之前不能对A做任何修改</span><br><span class="line">    - 共享锁又称读锁</span><br><span class="line"></span><br><span class="line">![](https://rlj<span class="number">-1999</span><span class="number">-1259282223.</span>cos.ap-beijing.myqcloud.com/%E6%<span class="number">95</span>%B0%E6%<span class="number">8</span>D%AE%E5%BA%<span class="number">93</span>/%E4%B9%A0%E9%A2%<span class="number">98</span>/suo1.png)</span><br><span class="line"><span class="comment">##### 封锁协议</span></span><br><span class="line">- 在运用X锁和S锁对数据对象加锁时,需要约定一些规则,这些规则为封锁协议</span><br><span class="line">    - 合适申请X锁或S锁</span><br><span class="line">    - 持锁时间</span><br><span class="line">    - 何时释放</span><br><span class="line">- 一级封锁协议</span><br><span class="line">    - 事务T在修改数据R之前必须先对其加X锁,知道事务结束才释放</span><br><span class="line">    - 一级封锁协议可以防止丢失修改,并保持事务T是可恢复的</span><br><span class="line">    - 不能保证可重复读和脏读</span><br><span class="line">- 二级封锁协议</span><br><span class="line">    - 一级封锁协议加上事务T在读取数据R之前必须显对其加S锁,读完后即可释放S锁(短锁)</span><br><span class="line">    - 可以方式丢失修改和读脏数据</span><br><span class="line">    - 读完数据后即可释放S锁,所以不能保证可重复读</span><br><span class="line">- 三级封锁协议</span><br><span class="line">    - 一级封锁协议加上事务T在读取数据R之前必须显对其加S锁,事务结束才释放S锁(长锁)</span><br><span class="line">    - 都可防止</span><br><span class="line">- 小结: </span><br><span class="line">![](https://rlj<span class="number">-1999</span><span class="number">-1259282223.</span>cos.ap-beijing.myqcloud.com/%E6%<span class="number">95</span>%B0%E6%<span class="number">8</span>D%AE%E5%BA%<span class="number">93</span>/%E4%B9%A0%E9%A2%<span class="number">98</span>/suo2.png)</span><br><span class="line"><span class="comment">##### 活锁和死锁</span></span><br><span class="line">- 活锁</span><br><span class="line">&gt;事务T1封锁了数据R</span><br><span class="line">事务T2又请求封锁R，于是T2等待。</span><br><span class="line">T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。</span><br><span class="line">T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求……</span><br><span class="line">T2有可能永远等待，这就是活锁的情形</span><br><span class="line">- 解决方法:  采取先来先服务策略</span><br><span class="line">- 死锁:</span><br><span class="line">&gt;事务T1封锁了数据R1</span><br><span class="line">T2封锁了数据R2</span><br><span class="line">T1又请求封锁R2，因T2已封锁了R2，于是T1等待T2释放R2上的锁</span><br><span class="line">接着T2又申请封锁R1，因T1已封锁了R1，T2也只能等待T1释放R1上的锁</span><br><span class="line">这样T1在等待T2，而T2又在等待T1，T1和T2两个事务永远不能结束，形成死锁</span><br><span class="line">- 死锁的预防: </span><br><span class="line">    - 一次封锁法</span><br><span class="line">        每个事务必须一次将所有要使用的数据全部加锁</span><br><span class="line">        - 存在问题:</span><br><span class="line">            - <span class="number">1.</span>过早加锁,降低系统并发度</span><br><span class="line">            - <span class="number">2.</span>难于事先精确确定封锁对象</span><br><span class="line">    - 顺序封锁法</span><br><span class="line">        顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。</span><br><span class="line">        - 存在问题:</span><br><span class="line">            - <span class="number">1.1</span>.维护成本：数据库系统中封锁的数据对象极多，并且在不断地变化。</span><br><span class="line">            - <span class="number">2.</span>难以实现：很难事先确定每一个事务要封锁哪些对象</span><br><span class="line">- 死锁的诊断与解除:</span><br><span class="line">    - 超时法:</span><br><span class="line">        如果一个事务的等待时间超过了规定的时限,就认为发生了死锁</span><br><span class="line">        - 优点:实现简单</span><br><span class="line">        - 缺点:</span><br><span class="line">            - 可能误判死锁</span><br><span class="line">            - 时限若设置得太长,死锁发生后不能即使发现</span><br><span class="line">    - 事务等待法:（如果事务等待图存在回路，则表示系统中出现了死锁）</span><br><span class="line">- 解除死锁</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 并发调度的可串行性</span></span><br><span class="line">串行调度是正确的</span><br><span class="line">执行结果等价于穿行调度的调度也是正确的,称为可串行化调度</span><br><span class="line">- 可串行化调度</span><br><span class="line">- 可串行性</span><br><span class="line">    - 是并发事务正确调度的准则</span><br><span class="line">    - 一个给定的并发调度,当且仅当它是可串行化的,才认为是正确调度</span><br><span class="line">嗯,稍懂</span><br><span class="line"><span class="comment">##### 两阶段锁协议</span></span><br><span class="line">- 第一阶段是获得封锁,也称为扩展阶段</span><br><span class="line">    - 事务可以申请获得任何数据项上的任何类型的锁,但是不能释放任何锁</span><br><span class="line">- 第二阶段是释放封锁,也成为收缩阶段</span><br><span class="line">    - 事务可以释放任何数据项上的任何类型的锁,但是不能再申请任何锁</span><br><span class="line">遵循两阶段锁协议仍然可能产生死锁.</span><br><span class="line"><span class="comment">##### 封锁的粒度</span></span><br><span class="line">* 封锁对象的大小称为封锁粒度.</span><br><span class="line">* 封锁粒度与系统的并发度和并发控制的开销密切相关.</span><br><span class="line">封锁粒度越小,并发度越高.    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 其他并发控制机制</span></span><br><span class="line">- 意向锁</span><br><span class="line">    - <span class="keyword">IS</span> 意向共享锁</span><br><span class="line">    - IX</span><br><span class="line">    - SIX</span><br><span class="line">数据锁的相容矩阵</span><br><span class="line">![](https://rlj<span class="number">-1999</span><span class="number">-1259282223.</span>cos.ap-beijing.myqcloud.com/%E6%<span class="number">95</span>%B0%E6%<span class="number">8</span>D%AE%E5%BA%<span class="number">93</span>/%E4%B9%A0%E9%A2%<span class="number">98</span>/suo3.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 小结</span></span><br><span class="line">- 并发操作带的数据不一致性</span><br><span class="line">    - <span class="number">1.</span>丢失修改</span><br><span class="line">    - <span class="number">2.</span>不可重复读</span><br><span class="line">    - <span class="number">3.</span>读脏数据</span><br><span class="line">- 数据库的并发控制通常使用封锁机制</span><br><span class="line">    - 基本封锁(X锁和S锁)</span><br><span class="line">    - 多粒度封锁(意向锁)</span><br><span class="line">- 活锁和死锁</span><br><span class="line">    - 活锁</span><br><span class="line">    - 死锁(预防,检测)</span><br><span class="line">- 解决数据不一致的并发控制协议:三级封锁协议</span><br><span class="line">- 并发事务调度的正确性</span><br><span class="line">    - 可串行性</span><br><span class="line">        - 并发操作的正确性则通常由两阶段锁协议来保证</span><br><span class="line">        - 两阶段锁协议是可串行化调度的充分条件,但不是必要条件</span><br><span class="line">    - 冲突可串行性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[推荐阅读<span class="number">1</span>](https://blog.csdn.net/sumaliqinghua/article/details/<span class="number">86246762</span>)</span><br><span class="line">[推荐阅读<span class="number">2</span>](https://blog.csdn.net/sumaliqinghua/article/details/<span class="number">85872446</span><span class="comment">#commentBox)</span></span><br><span class="line">[不错的文章](https://blog.csdn.net/weixin_42578658/article/details/<span class="number">90744175</span>)</span><br><span class="line"></span><br><span class="line">有关系模式Sailors(<span class="keyword">sid</span>:<span class="built_in">char</span>(<span class="number">10</span>),sname:<span class="built_in">char</span>(<span class="number">20</span>),rating:<span class="built_in">int</span>,age:<span class="built_in">int</span>),其中<span class="keyword">sid</span>是主关键字，<span class="keyword">sid</span>表示水手的编号，sname表示水手的姓名，rating表示水手的级别，age表示水手的年龄。Boats(bid:<span class="built_in">char</span>(<span class="number">10</span>),bname:<span class="built_in">char</span>(<span class="number">20</span>),color:<span class="built_in">char</span>(<span class="number">10</span>)),其中bid表示船的编号是主关键字，bname是船的名字，color是船的颜色。Reserves(<span class="keyword">sid</span>:<span class="built_in">char</span>(<span class="number">10</span>),bid:<span class="built_in">char</span>(<span class="number">10</span>),rdate:<span class="built_in">date</span>),Reserves中记录水手在哪天定了那只船，其中<span class="keyword">sid</span>是指向Sailors的外关键字,bid是指向Boats的外关键字,(<span class="keyword">sid</span>,bid,rdate)合起来构成Reserves的主关键字。</span><br><span class="line"><span class="string">``</span><span class="string">`sql</span></span><br><span class="line"><span class="string">1.查找至少定过两艘不通船的水手的编号</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Reserves R1</span></span><br><span class="line"><span class="string">Πsid(sid1=sid and bid1&lt;&gt;bid)(R1×Reserves)</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/01/DataBase/gx2.png" alt></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span>查找水手中年龄最大的水手编号。</span><br><span class="line">先找出所有小于过其他数的数</span><br><span class="line">然后减去这个集合就是最大的了</span><br><span class="line">age &lt; age1</span><br><span class="line"><span class="symbol">R1:</span>= Πage,sid(Sailors)</span><br><span class="line"><span class="symbol">R2:</span>= ρ<span class="built_in">R2</span>(age1,sid1)(<span class="built_in">R1</span>)</span><br><span class="line"><span class="symbol">R3:</span>= Πage,sid(<span class="built_in">R1</span> ∞(age&lt;age1)<span class="built_in">R2</span>)</span><br><span class="line"><span class="symbol">R4:</span>= <span class="built_in">R1</span>-<span class="built_in">R3</span></span><br><span class="line"><span class="symbol">R5:</span>= Πsid(<span class="built_in">R4</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/01/DataBase/gx1.png" alt></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">3.查找所有水手的定船信息，并将结果按水手编号和船的编号排序（水手编号相同再排船的编号）。（5分）</span><br><span class="line"></span><br><span class="line">order by s1,s2 从小到大</span><br><span class="line">order by s1 desc; 从大到小</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> reserves </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> s.sid,b.bid</span><br><span class="line"><span class="number">4.</span>删除名字叫lubber的水手的定船信息。（<span class="number">5</span>分）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> R(a1,a2..) <span class="keyword">values</span> (v1,v2...)</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> reserves <span class="keyword">where</span> reserves.sid = (<span class="keyword">select</span> s.sid <span class="keyword">from</span> sailors <span class="keyword">where</span> s.sname=<span class="string">"lubber"</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>查找定了<span class="number">103</span>号船的水手的详细信息。（<span class="number">4</span>分）</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> sailors s, reserves r</span><br><span class="line"><span class="keyword">where</span> s.sid=r.sid <span class="keyword">and</span> b.bid = <span class="number">103</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>查找级别最高的水手中年龄最小的水手编号。（<span class="number">6</span>分）</span><br><span class="line"></span><br><span class="line">先找级别最高的还是用减法</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> s1.sid</span><br><span class="line"><span class="keyword">from</span> sailors s1</span><br><span class="line"><span class="keyword">where</span> s1.rating &gt;= <span class="keyword">ALL</span>(<span class="keyword">select</span> s2.rating <span class="keyword">from</span> sailors s2)</span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line"><span class="keyword">select</span> s1.sid</span><br><span class="line"><span class="keyword">from</span> sailors s1</span><br><span class="line"><span class="keyword">where</span> s1.age = <span class="keyword">min</span> (<span class="keyword">select</span> s2.age <span class="keyword">from</span> sailors s2)</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>根据下面的要求创建学生表  （<span class="number">5</span>分）</span><br><span class="line">某学院需要完成一个学生选课及成绩管理系统，该系统要求能够登记，修改，查询，统计学生、课程、选课的基本信息。</span><br><span class="line">学生的基本信息包括：学号(<span class="keyword">sid</span>:<span class="built_in">char</span>(<span class="number">10</span>))，姓名(<span class="keyword">name</span>:<span class="built_in">char</span>(<span class="number">10</span>))，性别(gender:<span class="built_in">char</span>(<span class="number">2</span>))，入学年份(grade:<span class="built_in">char</span>(<span class="number">4</span>)）。</span><br><span class="line">课程的基本信息包括：课程编号(cid:<span class="built_in">char</span>(<span class="number">10</span>))，课程名称(cname:<span class="built_in">char</span>(<span class="number">10</span>))，学分(credit:<span class="built_in">char</span>(<span class="number">10</span>))。</span><br><span class="line">选课信息：学生学号(<span class="keyword">sid</span>:<span class="built_in">char</span>(<span class="number">10</span>))，课程号(cid:<span class="built_in">char</span>(<span class="number">10</span>))，选课年份(<span class="keyword">years</span>:<span class="built_in">char</span>(<span class="number">4</span>))，成绩 (mark:<span class="built_in">int</span>)。要求学生基本信息中性别的可选着值只能是（男或女），所有的学生在<span class="number">2014</span>年全部都要选课。</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">    <span class="keyword">sid</span> <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">    gender <span class="built_in">char</span>(<span class="number">2</span>),</span><br><span class="line">    grade <span class="built_in">char</span>(<span class="number">4</span>),</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="keyword">sid</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">class</span>(</span><br><span class="line">    cid <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">    cname <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">    credit <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">    primary <span class="keyword">key</span> (cid)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> xuanke(</span><br><span class="line">    <span class="keyword">sid</span> <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">    cid <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">years</span> <span class="built_in">char</span>(<span class="number">4</span>),</span><br><span class="line">    mark <span class="built_in">int</span>,</span><br><span class="line">   <span class="keyword">constraint</span> fx_sid <span class="keyword">foreign</span> <span class="keyword">key</span> (<span class="keyword">sid</span>) <span class="keyword">references</span> student(<span class="keyword">sid</span>),</span><br><span class="line">   <span class="keyword">constraint</span> fx_cid <span class="keyword">foreign</span> <span class="keyword">key</span> (cid) <span class="keyword">references</span> <span class="keyword">class</span>(cid)</span><br><span class="line">)</span><br><span class="line"><span class="number">8.</span>设有关系模式R(A，B，C，D)，其上的函数依赖集：F＝&#123;A→C，C→A，B→AC，D→AC&#125;  （<span class="number">15</span>分）  </span><br><span class="line">(<span class="number">1</span>).计算(AD)+。      （<span class="number">2</span>分）</span><br><span class="line">AD+ = ADC</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>).求F的函数依赖最小等价依赖集。   （<span class="number">5</span>分） </span><br><span class="line">先拆右边不为单</span><br><span class="line">A→C,C→A,B→A,B→C,D→A,D→C</span><br><span class="line">因为B→A,A→C可以推出B→C 删除 B→C 同理删除 D→C</span><br><span class="line">然后剩下</span><br><span class="line">A→C,C→A,B→A,D→A</span><br><span class="line">若删除 A→C,A+=A</span><br><span class="line">若删除 C→A,C+=C</span><br><span class="line">同理</span><br><span class="line">最后F的最小等价依赖集为</span><br><span class="line">&#123;A→C,C→A,B→A,D→A&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>).求R的一个关键字。 （<span class="number">3</span>分）</span><br><span class="line"></span><br><span class="line">L:BD</span><br><span class="line">R:</span><br><span class="line">LR:A C </span><br><span class="line">N:</span><br><span class="line">BD+=BDAC</span><br><span class="line">所以BD是R的一个关键字</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>).将R分解成满足<span class="number">3</span>NF并具有无损连接性与保持依赖性。（<span class="number">5</span>分）</span><br><span class="line"></span><br><span class="line">已知R的最小依赖集为</span><br><span class="line">A→C,C→A,B→A,D→A</span><br><span class="line"></span><br><span class="line">BD是关键字</span><br><span class="line"></span><br><span class="line">AC,CA,BA,DA, BDC加入BD</span><br><span class="line">则 分解为AC,BA,DA,BD</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  有关系模式 employee(ssn:string,name:string,city:string)</span><br><span class="line">              department(did:string,cname:string,city:string)</span><br><span class="line">              works(ssn:string,did:stirng,salary:real)</span><br><span class="line">     各关系模式的关键字用下划线表示,其中works的关键字中的ssn来自employee,cid来自department. 关系模式work表示员工工作与某个部门,并且记录员工的工资.</span><br><span class="line">1.查找员工人数最少的部门编号.</span><br><span class="line">     <span class="keyword">Select</span>  temp.did</span><br><span class="line">     <span class="keyword">From</span> (<span class="keyword">Select</span> <span class="keyword">count</span>(*) <span class="keyword">as</span> nu,did</span><br><span class="line">           <span class="keyword">From</span> department D,works W</span><br><span class="line">           <span class="keyword">Where</span> D.did=W.did</span><br><span class="line">           <span class="keyword">Group</span> <span class="keyword">by</span>(did)) <span class="keyword">As</span> temp</span><br><span class="line">     <span class="keyword">Where</span> Temp.nu = (<span class="keyword">SELECT</span>  <span class="keyword">MIN</span> (Temp.nu) <span class="keyword">FROM</span>  Temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>查找在所有部门工作过的员工的姓名.</span><br><span class="line"><span class="keyword">SELECT</span>  e.name</span><br><span class="line"><span class="keyword">FROM</span>  employess e</span><br><span class="line"><span class="keyword">WHERE</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> </span><br><span class="line">              ((<span class="keyword">SELECT</span>  D.did</span><br><span class="line">                 <span class="keyword">FROM</span>  Department D)</span><br><span class="line">                <span class="keyword">EXCEPT</span></span><br><span class="line">                 (<span class="keyword">SELECT</span>  W.did</span><br><span class="line">                  <span class="keyword">FROM</span>  <span class="keyword">Work</span>  W</span><br><span class="line">                  <span class="keyword">WHERE</span>  W.ssn=e.ssn))</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">找出至少两种/三种.... group by havaing count() &gt;=2(3/4);</span><br><span class="line"><span class="keyword">SELECT</span>  M.maker</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">        (<span class="keyword">SELECT</span> maker,</span><br><span class="line">                R.model</span><br><span class="line">        <span class="keyword">FROM</span>    PC P,</span><br><span class="line">                Product R</span><br><span class="line">        <span class="keyword">WHERE</span>   SPEED &gt;= <span class="number">3.0</span></span><br><span class="line">            <span class="keyword">AND</span> P.model=R.model</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">UNION</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">SELECT</span>  maker,</span><br><span class="line">                R.model</span><br><span class="line">        <span class="keyword">FROM</span>    Laptop L,</span><br><span class="line">                Product R</span><br><span class="line">        <span class="keyword">WHERE</span>   speed &gt;= <span class="number">3.0</span></span><br><span class="line">            <span class="keyword">AND</span> L.model=R.model</span><br><span class="line">        ) M</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> M.maker</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(M.model) &gt;= <span class="number">2</span> ;</span><br><span class="line">至少三艘船...</span><br><span class="line"><span class="keyword">SELECT</span>  O.battle</span><br><span class="line"><span class="keyword">FROM</span>    Ships S  ,</span><br><span class="line">        Classes C,</span><br><span class="line">        Outcomes O</span><br><span class="line"><span class="keyword">WHERE</span>   C.Class = S.class</span><br><span class="line">    <span class="keyword">AND</span> O.ship  = S.name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> C.country,</span><br><span class="line">        O.battle</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(O.ship) &gt;= <span class="number">3</span>; </span><br><span class="line">3. 查找定了所有船的水手的编号和姓名</span><br><span class="line"></span><br><span class="line">sql</span><br><span class="line"><span class="keyword">select</span> s.sid,s.name</span><br><span class="line"><span class="keyword">from</span> saliors</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> b.bid </span><br><span class="line">    <span class="keyword">from</span> boats b</span><br><span class="line">    <span class="keyword">except</span> </span><br><span class="line">    <span class="keyword">select</span> r.bid</span><br><span class="line">    <span class="keyword">from</span> reserves r</span><br><span class="line">    <span class="keyword">where</span> r.sid=s.sid</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> s.sid,s.sname</span><br><span class="line">    <span class="keyword">from</span> sailors s</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">not</span> exist (</span><br><span class="line">            <span class="keyword">select</span> b.bid</span><br><span class="line">            <span class="keyword">from</span> boats b</span><br><span class="line">            <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">                    <span class="keyword">select</span> r.bid</span><br><span class="line">                    <span class="keyword">from</span> reserves r</span><br><span class="line">                    <span class="keyword">where</span> r.bid=b.bid</span><br><span class="line">                    <span class="keyword">and</span> r.sid=s.sid</span><br><span class="line">            )</span><br><span class="line">    )</span><br><span class="line">这个人如果都定过就不存在有没订过的船</span><br><span class="line"><span class="number">1</span>)找这人没定过的船,</span><br><span class="line"><span class="number">2</span>)没找到 <span class="keyword">not</span> exist 成立 选出这个人</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 找最大订船数量</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sid</span>,cbid</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(bid) cbid,<span class="keyword">sid</span></span><br><span class="line">    <span class="keyword">from</span> R</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">sid</span></span><br><span class="line">)T1</span><br><span class="line"><span class="keyword">where</span> T1.cbid = (<span class="keyword">select</span> <span class="keyword">max</span>(cbid) <span class="keyword">from</span> T1)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 查找订过红色船也订过绿色船水手的编号和姓名</span><br><span class="line"></span><br><span class="line"><span class="keyword">Select</span> s.sname <span class="keyword">from</span> sailors s,reserves r,boats b </span><br><span class="line"><span class="keyword">Where</span> s.sid=r.sid <span class="keyword">and</span> r.bid=b.bid <span class="keyword">and</span> b.color=’red’</span><br><span class="line"><span class="keyword">intersect</span> </span><br><span class="line"><span class="keyword">Select</span> s.sname <span class="keyword">from</span> sailors s,reserves r,boats b </span><br><span class="line"><span class="keyword">Where</span> s.sid=r.sid <span class="keyword">and</span> r.bid=b.bid <span class="keyword">and</span> b.color=’green’</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 统计各班学生的数据库原理的最高分。</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> s.class,<span class="keyword">max</span>(e.grade) </span><br><span class="line"><span class="keyword">from</span> students s,course c,enrolled e</span><br><span class="line"><span class="keyword">where</span> c.cid=e.cid <span class="keyword">and</span> cname= <span class="string">'数据库原理'</span> <span class="keyword">and</span> </span><br><span class="line">    s.sid = e.sid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.class </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(grade)  <span class="keyword">from</span> student <span class="keyword">natural</span> <span class="keyword">join</span> course <span class="keyword">natural</span> <span class="keyword">join</span> enrolled </span><br><span class="line"><span class="number">6.</span> 查找数据库原理课程平均分最高的班级中数据库原理课程的最低分。</span><br><span class="line">创建一个视图??</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(T1.avg_grade)</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">avg</span>(e.grade) <span class="keyword">as</span> avg_grade</span><br><span class="line"><span class="keyword">from</span> students s,course c,enrolled e</span><br><span class="line"><span class="keyword">where</span> c.cid=e.cid <span class="keyword">and</span> cname= <span class="string">'数据库原理'</span> <span class="keyword">and</span> </span><br><span class="line">    s.sid = e.sid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.class</span><br><span class="line">) T1</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 订过所有船的水手的姓名及编号</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.sid,s.name</span><br><span class="line"><span class="keyword">from</span> saliors</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> b.bid </span><br><span class="line">    <span class="keyword">from</span> boats b</span><br><span class="line">    <span class="keyword">except</span> </span><br><span class="line">    <span class="keyword">select</span> r.bid</span><br><span class="line">    <span class="keyword">from</span> reserves r</span><br><span class="line">    <span class="keyword">where</span> r.sid=s.sid</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 查找没有定过船的水手消息（<span class="keyword">sid</span>，sname，rating，age）</span><br><span class="line"><span class="keyword">select</span> s.sid,s.name,s.rating,s.age</span><br><span class="line"><span class="keyword">from</span> sailors</span><br><span class="line"><span class="keyword">except</span></span><br><span class="line"><span class="keyword">select</span> s.sid,s.name,s.rating,s.age</span><br><span class="line"><span class="keyword">from</span> sailors nature <span class="keyword">join</span> reserves</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>将水手的级别分为初级，中级，高级,其中初级表示为 rating &lt;=3,中级表示为 rating &gt;3 and rating &lt;=9,高级表示为 rating&gt;10.统计这三个级别（初，中，高）中水手的人数。 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">count</span>(*)  <span class="keyword">from</span> sailors <span class="keyword">where</span> rating &lt;=<span class="number">3</span>) chuji</span><br><span class="line">    <span class="keyword">cross</span> <span class="keyword">join</span></span><br><span class="line">    (<span class="keyword">count</span>(*)  <span class="keyword">from</span> sailors <span class="keyword">where</span> rating &gt;<span class="number">3</span> <span class="keyword">and</span> rating&lt;=<span class="number">9</span>) zhongji</span><br><span class="line">      <span class="keyword">cross</span> <span class="keyword">join</span></span><br><span class="line">     (<span class="keyword">count</span>(*)  <span class="keyword">from</span> sailors <span class="keyword">where</span>  rating&gt;<span class="number">9</span>) gaoji</span><br><span class="line">     )</span><br></pre></td></tr></table></figure>




</li>
</ol>
<ol start="6">
<li>统计每个水手订船的次数，并按订船次数降序排序<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> sname, <span class="keyword">count</span>(*) <span class="keyword">num</span></span><br><span class="line"><span class="keyword">from</span> sailors <span class="keyword">natural</span> <span class="keyword">join</span> reserves </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">num</span>  <span class="keyword">desc</span></span><br></pre></td></tr></table></figure></li>
<li>在 club 数据库中定义一个合适的对象，能够实现下面的功能<br>当使用 insert 语句对 sailors 表插入记录时如果某些记录的 age 值小于 19，同时将这些 age 小于 19 的记录插入到 yangsaliors 表中。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> ST</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> sailors</span><br><span class="line"><span class="keyword">referencing</span></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">row</span> <span class="keyword">as</span> newrow</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">when</span> (new.age &lt;<span class="number">19</span> )</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> yangsaliors(<span class="keyword">sid</span>,<span class="keyword">name</span>,age) <span class="keyword">values</span>(newrow.sid,new.name,new.age)</span><br></pre></td></tr></table></figure>
<p>查找选修了全部课程的学生的学号、姓名 (两种语法  )</p>
<p>工资大于某个数值的 员工的ID以及最高的工资 并按照员工的序号进行排序<br>某一列进行重命名，给最高的工资重命名 要求这一列都是最高的工资</p>
<p> 关系代数 5分<br>查找至少选择了两门、三门课程的学生<br>关系代数表示约束 主键外键 用两种方式来表的<br> 两个学生的学号是一样的 =空集 属于</p>
<p> 规范化理论 8分</p>
<p> 问答题24分<br>1.授权图 画图<br>2.给一个调度 有读写 什么叫有冲突的<br>两个事物对同一个事物的读与写<br>看一个调度是否是可串行化的 画一个优先图 没有环 然后给等价的串行调度<br>3.关于日志恢复的 日志记录 redo日志 undo日志<br>书上例子 根据这段日志 来恢复磁盘上的数据  以及恢复之后是什么样子的 书上的例题<br>4.数据库设计题 12分<br>给一个描述  如图书馆、购物网站的设计图 主键必须写下划线。</p>
<p>冲突是指<font color="red" size="5">  不同的事务对同一数据的读写操作和写写操作**</font></p>
]]></content>
      <categories>
        <category>期末</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统习题整理</title>
    <url>/2020/01/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="操作系统习题"><a href="#操作系统习题" class="headerlink" title="操作系统习题"></a>操作系统习题</h2><h3 id="虎哥语录"><a href="#虎哥语录" class="headerlink" title="虎哥语录"></a>虎哥语录</h3><p>本次考试题型: 选择题(30道,60分)+ 计算题 +<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/os7.png" alt></p>
<a id="more"></a>
<ul>
<li><p>四个状态的转移过程</p>
<ul>
<li>running到blocked状态由进程自己进入。</li>
<li>running到ready状态是由调度程序进行的。</li>
<li>ready到running状态是由调度程序进行的。</li>
<li>blocked到ready状态是靠中断进行。<br>Running,Ready,Block,是怎么转化的,为什么可以转换,为什么不能转换?</li>
</ul>
</li>
<li><p>Ready状态是暂时没有CPU分配给他</p>
</li>
<li><p>进程执行一个系统调用调用进入阻塞态</p>
</li>
<li><p>当进程等待的一个外部事件发生时(如一些输入到达),则 block转换为ready,如果此时没有其他进程运行,立即又转换为了running</p>
<ul>
<li>A 运行状态 进程占用着CPU，并且在CPU上运行。显然处于这种状态的进程数量&lt;=CPU的数目。若只有一个CPU那么任何时刻最多只能有一个进程处于运行状态。</li>
<li>B 就绪状态 进程已经具备了运行的条件，但由于CPU正忙着运行其他的进程，所以暂时不能运行。不过只要把CPU分给它，它就立刻可以运行。正所谓万事俱备只欠东风。 </li>
<li>C 阻塞状态 进程因为某种事件的发生暂时不能运行的状态。例如它正等待某个输入输出的操作完成，或者它与其他线程之间存在同步关系，需要等待其他进程给它输入数据。这种情况下即使CPU已经空闲下来，这个进程还是不能运行。 </li>
<li>D 状态切换 运行可转化为阻塞、就绪。 阻塞可转化为就绪。 就绪可转化为运行。</li>
</ul>
</li>
<li><p>线程:</p>
<ul>
<li>引入了多线程机制之后，进程的职责发生了变化，进程只负责资源的管理，线程负责运行。(调度分派的最小单位吗???)</li>
<li>同一个进程里的多个线程会共享资源，每个线程都有自己的栈，局部变量在计算机真正执行的时候不存在，局部变量都是栈。</li>
</ul>
</li>
<li><p>线程实现的机制:</p>
<ul>
<li>内核空间:调度的颗粒度更细了，但是每一次调度都在内核调度，所以时间开销很大。内核的调度策略是固定的，不够灵活。</li>
<li>用户空间:调度灵活，可以定制自己的调度策略，不需要切换到内核态，时间开销很小，但调度颗粒度大。</li>
</ul>
</li>
<li><p>调度:</p>
<ul>
<li>FCFS 先来先服务</li>
<li>SJF (shortest job first) 最短作业优先</li>
<li>HRF (high response-radio first.) 最高相应比优先</li>
<li>SRF (shortest remaining-time first) 最短剩余时间优先</li>
</ul>
</li>
<li><p>实时系统的调度算法重要的思想：</p>
<ul>
<li>round robin：时间片轮转，体现公平性，但无法体现出优先级，新来的永远放在队列尾，时间片定多大合适没有准确值。</li>
<li>priority：优先级调度算法，有可能出现“饥饿”现象，在一般执行过程中优先级会有动态调整。(饥饿现象就是 长时间没有获得资源,类似很长时间没吃饭就饿了)</li>
</ul>
</li>
<li><p>race condition：</p>
<ul>
<li>四个标准: 最重要的两个: 互斥,progress(简称)</li>
<li>progress: 不在临界区的进程不能阻止其他想进入的进程进入。</li>
<li>critical regions(临界区)：访问共享资源的一段代码。</li>
</ul>
</li>
<li><p>解决互斥问题(软件):</p>
<ul>
<li>严格轮转法（strict alternation）：理解思想。可以解决互斥，但无法保证progress</li>
<li>Peterson方法：都可以解决，但只能解决两个进程之间的问题。可以有解决多个进程之间的问题，但我们没有学。</li>
</ul>
</li>
<li><p>解决互斥问题(硬件)</p>
<ul>
<li>TSL（TEST AND LOCK）机器指令级的原子操作（？好像是这么说的）<br>我记得罡哥说:<strong>TSL</strong>指令 (背下来)<br>附上代码<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>信号量(PV题):</p>
<ul>
<li>忙等待(无法保证谁先进去)和睡眠与唤醒</li>
<li>信号量只能通过PV操作进行改变</li>
</ul>
</li>
<li><p>死锁:</p>
<ul>
<li>四个必要条件<ul>
<li>(1)互斥使用(资源独占)：一个资源每次只能给一个进程使用</li>
<li>(2)占有且等待(请求和保持，部分分配)：进程在申请新的资源的同时保持对原有资源的占有</li>
<li>(3)不可抢占(不可剥夺)：资源申请者不能强行的从资源占有者手中夺取资源，资源只能由占有者自愿释放</li>
<li>(4)循环等待：存在一个进程等待队列 {P1 , P2 , … , Pn}，其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路。</li>
</ul>
</li>
</ul>
</li>
<li><p>解决死锁的方法:</p>
<ul>
<li>检测与恢复<ul>
<li>检测算法:<ul>
<li>（1）利用图，如果出现环，则有可能出现死锁。</li>
<li>（2）利用资源分配矩阵。</li>
</ul>
</li>
<li>恢复:<ul>
<li>抢占</li>
<li>回滚</li>
<li>杀死 (杀死年轻的进程,或者优先级低的)</li>
</ul>
</li>
</ul>
</li>
<li>死锁避免<ul>
<li>银行家算法</li>
</ul>
</li>
<li>死锁预防<ul>
<li>（1）如何解决互斥：Spooling.</li>
<li>（2）如何解决部分持有并等待：要么全部分配，要么不分配，即不会出现部分持有但是该方法实际上不可行，因为必须事先知道需要用到哪些资源。</li>
<li>（3）如何解决循环等待：对所有资源编号，然后按序分配。</li>
</ul>
</li>
</ul>
</li>
<li><p>存储模型:<br>金字塔模型,从上到下规律<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/os8.png" alt></p>
</li>
<li><p>固定分区:启动时把内存分为不等的固定大小，然后采用best fit算法决定要把进程放到哪里，解决外碎片的利用问题。固定分区没有外碎片，所以需要解决的是内碎片问题，内碎片无法被再利用。</p>
</li>
<li><p>可变分区：有各种fit算法，需要了解。</p>
<ul>
<li>BF</li>
<li>WF</li>
</ul>
</li>
<li><p>Swap（交换）：为了让内存容纳更多的进程（透明）。</p>
</li>
<li><p>Overlay（部分交换）：需要自己写代码实现Overlay（不透明）。</p>
</li>
<li><p>虚拟内存:</p>
<ul>
<li>分页:页号，页帧号，需要会算页号，物理地址。</li>
<li>TLB:时间计算</li>
<li>多级页表：需要会算需要几级页表。</li>
<li>倒排页表：根据内容查下标，提速方法：哈希。</li>
<li>页面置换算法<ul>
<li>最优页面置换算法(OPT)<br>  置换以后不再被访问，或者在将来最迟才会被访问的页面，缺页中断率最低，但是该算法需要知道后面各页面的使用情况，而现实中一个进程正在运行时，很难知道后面的过程，所以该算法无法被实现。</li>
<li>最近未使用页面置换(NRU)算法<br>  系统为每一个页面设置两个标志位：当页面被访问时设置R位，当页面被修改时设置M位。当发生缺页中断时，系统会检查所有的页面，并根据当前的R位和M位的值分为四类：（0）未被访问也未被修改（1）未被访问但被修改（2）被访问但未被修改（3）已被访问且已被修改</li>
<li>FIFO算法<br>  置换最先调入内存的页面，即置换在内存中驻留时间最长的页面。</li>
<li>second chance算法<br>  这是FIFO算法的一种改进方法，第二次机会算法给每个界面增加一个R位，每次先从链表头部开始查找，如果R置位，则清除R位并且把该页面的节点放到链表结尾；如果R是0，那么就直接替换掉。</li>
<li>clock算法<br>  这种算法是一个环形链表的第二次机会算法，指针指向最老的页面，缺页中断时，检查表针指向的页面，如果R位为0，淘汰页面，如果R位为1，则清除R位并向前移动表针。</li>
<li>LRU算法<ul>
<li>在缺页中断时，置换未使用时间最长的页面。但是完全实现LRU的代价很高。</li>
<li>下面介绍一个使用软件实现的解决方案<br>将每一个页面与一个计数器关联，每次时钟终端，扫描所有页面，把每个页面的R位加到计数器上，这样就跟踪了每个页面的使用情况。这种算法被称为最不常用（NFU）算法。<br>但这样还是存在一个问题，即很久之前的使用与最近的使用权重相等。<br>所以再次进行改进，将计数器在每次时钟滴答时，右移一位，并把R位加在最高位上，这种算法被称为老化（Aging）算法，增加了最近使用的权重。</li>
</ul>
</li>
</ul>
</li>
<li>缺页中断:<ul>
<li>与普通中断的区别:<ul>
<li>在指令执行期间产生和处理中断信号</li>
<li>一条指令在执行期间，可能会产生多次缺页中断</li>
<li>缺页中断返回时，会重新执行产生中断的那一条指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>硬链接和符号链接的区别:</p>
<ul>
<li>硬链接（Hard Link）：文件A是文件B的硬链接，则A的目录项中的inode节点号与B的目录项中的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说完全平等。删除其中一个对另外一个没有影响。只是inode节点上的链接数变化而已。           </li>
<li>符号链接（Symbolic Link）：A是B的符号链接，A的目录项中的inode节点号与B的目录项中的inode节点号不相同，A和B指向的是两个不同的inode，继而指向两块不同的数据块。但是A的数据块中存放的只是B的路径名。A和B之间是“主从“关系，如果B被删除了，A仍然存在，但指向的是一个无效的链接。</li>
</ul>
</li>
<li><p>文件的权限</p>
<ul>
<li>r:read</li>
<li>w:write</li>
<li>x:execute<br>第一部分属于用户，第二部分属于用户组，第三部分属于其他<br>例如 -rw-r-r– 644</li>
</ul>
</li>
<li><p>多级索引:<br>  会算能够支持的最大文件</p>
</li>
<li><p>调度</p>
<ul>
<li>FIFO调度</li>
<li>最短寻道优先</li>
<li>SCAN调度</li>
<li>CSCAN调度<br>类似于SCAN调度，C-SCAN调度移动磁头从磁盘一端到磁盘另一端，并且处理行程上的请求，但是当磁头到达另一端时，它立即返回到磁盘的开头，不处理任何回程上的请求。<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3></li>
</ul>
</li>
</ul>
<h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><ol>
<li><p>若磁盘转速为7200转/分，平均寻道时间为8ms,每个磁道包含1000个扇区，则访问一个扇区<br>的平均存取时间大约是(B)<br>A．8.1ms B．12.2ms C．16.3ms D．20.5ms</p>
<blockquote>
<p>这题跟扇区没啥关系,大骗子</p>
</blockquote>
</li>
<li><p>设某文件为索引顺序文件，由 5 个逻辑记录组成，每个逻辑记录的大小与磁盘块的大小相等， 均为 512B，并依次存放在 50、121、75、80、63 号磁盘块上。若要存取文件的第 1569 逻辑字节处的信息，则要访问的磁盘块号是<br>A. 3    B. 75    C. 80    D. 63</p>
</li>
<li><p>某磁盘的转速为10000转/分，平均寻道时间是6 ms，磁盘传输速率是20 MB/s，磁盘控制器延迟为0.2 ms，读取一个4 KB的扇区所需的平均时间约为 B<br>A. 9 ms    B. 9.4 ms    C. 12 ms    D. 12.4 ms</p>
<blockquote>
<p>第一部分 找到磁道的时间 = 平均寻道时间 = 6ms<br>第二部分 找到扇区的时间 = 磁盘转一圈的时间÷2（因为不知道扇区具体在哪按半圈算）=（60秒）/（2*10000转/分）=3ms<br>第三部分 磁盘控制器延迟时间 = 0.2ms<br>第四部分 数据传输时间 = 传输字节数 / 磁盘传输速度 = 4K / 20M = 0.2ms（1K≈10的3次方）<br>综上 6ms+3ms+0.2ms+0.2ms=9.4ms。</p>
</blockquote>
</li>
<li><p>若某文件系统索引结点（inode）中有直接地址项和间接地址项，则下列选项中，与单个文件长度无关的因素是 A<br>A.索引结点的总数    B.间接地址索引的级数    C.地址项的个数    D.文件块大小</p>
<blockquote>
<blockquote>
<p>A<br>Linux使用索引节点来记录文件信息，作用类似于Windows下的文件分配表。索引节点是一个结构，它包含了一个文件的长度、创建及修改时间、权限、所属关系、磁盘中的位置等信息。</p>
</blockquote>
</blockquote>
</li>
<li><p>一个磁盘的转速为 7200 转/分，每个磁道有 160 个扇区，每个扇区为 512B， 那么理想情况下，其数据传输率为<br>A. 576000KB/s B. 7200KB/s C. 9600KB/s D. 19200KB/s</p>
<blockquote>
<p>C<br>[解析] 磁盘的转速为7200r/min=120r/s，转一圈经过160个扇区，每个扇区有512B所以数据传输率为120×160×512/1024=9600KB/s。<br>[归纳总结] 磁盘的数据传输率=每一道的容量/旋转一圈的时间=每一道的容量×转速</p>
</blockquote>
</li>
<li><p>现有容量为10GB的磁盘分区，磁盘空间以簇（cluster）为单位进行分配， 簇的大小为4KB。若采用位图法管理该分区的空闲空间，即用一位（bit）标识一个簇是否被分配，则存放该位图所需要簇的个数为：<br>A. 80 B. 320 C. 80K D. 320K</p>
<blockquote>
<p>方法一：设磁盘容量为A,则<br>A=10G=10 * 1024 M<br>=10 * 1024 * 1024 K<br>=10 * 1024 * 1024 * 1024 byte<br>=10 * 1024 * 1024 * 1024 * 8 bit<br>设簇大小为B,则<br>B=4K<br>=4 * 1024byte<br>=4 * 1024*8bit<br>设C为10G所需标识的位数，则<br>C=A/B<br>=320K<br>320K/4K=80个<br>方法二：<br>磁盘簇个数：10 * 1024 * 1024KB/4KB=2621440bit，<br>一个簇能容纳的bit数：4 * 1024 * 8= 32768bit<br>则存放该位图所需簇的个数 2621440/ 32768=80个簇</p>
</blockquote>
</li>
<li><p>在文件的索引节点中存放直接索引指针10个，一级二级索引指针各1 个，磁盘块大小为1KB。每个索引指针占4个字节。若某个文件的索引节点已在内存中，到把该文件的偏移量（按字节编址）为1234和307400处所在的磁盘块读入内存。需访问的磁盘块个数分别是（B）<br>A．1，2    B．1，3    C．2，3    D．2，4<br>已知在UNIX文件系统中,</p>
</li>
<li><p>执行命令touch file1新建一个文件，然后执行命令ln -s file1 link1为file1创建一个符号链接link1，再 执行ln link1 link2为link1创建一个（硬）链接，则此时file1的link counter为<strong>B_</strong>。<br>A．0 B．1 C．2 D．3</p>
</li>
<li><p>执行命令rm link1删除link1成功，则此时尝试显示link2的内容，执行cat link2，结果为 _B__。<br>A．提示文件不存在 B．打开文件file1 C．打开一个空文件 D．link2被删除</p>
<h4 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h4></li>
<li><p>UNIX操作系统中，给文件分配外存空间采用的是混合索引分配方式。索引节点（inode）中包含10个直接块指针、1个一级间接块指针、1个二级间接块指针和1个三级间接块指针，间接块指向的是一个索引块，每个索引块和数据块的大小均为4KB，地址指针所占空间为4B。假设该索引节点已经被加载进内存中，则：<br>（1）该文件能支持的最大容量是多少。<br>（2）若要读取文件的第1000B的内容，需要访问磁盘多少次。<br>（3）若要读取文件的第10MB的内容，需要访问磁盘多少次。</p>
<blockquote>
<p>解：（1）一个指针块有 4KB/4B=1K 个指针，故最大支持的文件大小为：<br>[10+2^10 +(2^10) ^2+ (2^10) ^3]  * 4KB 约等于 4TB 即可 （2 分）<br>（2）1000B &lt; 4KB ，直接指针，一个数据块即可访问到，1 次。（2 分）<br>（3）(10+2^10)*4KB &lt; 1000MB &lt; [10+ 2^10 +(2^10) ^2] * 4KB，需要使用二级间接指针，访问两次间接索引块和一个数据块，共 3 次。（2 分</p>
</blockquote>
</li>
<li><p>、当前磁盘读写位于柱面号20，并向柱面号增大方向运动。此时有以下磁盘请求序列：10、22、2、40、6、38。寻道时移动一个柱面需要1ms，则按照先来先服务（FCFS）算法的总寻道时间为多少，电梯算法（优化SCAN）的总寻道时间为多少</p>
<blockquote>
<p>解：(1) FCFS = |20-10| + |10-22| + |22-2| + |2-40| + |40-6| + |6-38| = 10+12+20+38+34+32=146 寻道时间<br>146<em>1ms = 146ms（3 分）<br>(2) SCAN 算法，访问顺序：20-&gt;22-&gt;38-&gt;40-&gt;10-&gt;6-&gt;2，磁道数 = 2+16+2+30+4+4=58，寻道时间<br>58</em>1ms=58ms（3 分）</p>
</blockquote>
</li>
<li><p>xv6操作系统中，给文件分配外存空间采用的是混合索引分配方式。索引节点（inode）中包含12 个直接块指针和1个一级间接块指针，间接块指向的是一个索引块，每个索引块和数据块的大小均为一个扇区，即512B，地址指针所占空间为4B。<br>1）该文件系统能支持的文件最大容量是 (1) 70KB    。<br>2）为了支持更大的文件，在不增加 inode 中的指针个数的前提下，取消一个直接块指针，增加一个二级间接块指针，则能支持的文件最大容量是     (2)(11+128+128<em>128) * 512B 。<br>3）在上一问的基础上，若将数据块的大小修改为 1KB，则该文件系统能支持的文件最大容量是 (3)(11+256+256</em>256) * 1KB    。<br>4）在上一问的基础上，假设该索引节点已经被加载进内存中，则若要读取文件的第 10MB 的内容，需要访问磁盘     (4) 3次。<br>5）若 inode 的大小为 128B，NBPI (Number of Bytes Per Inode) 为 2048，则一个 32GB 大小的文件系统中，用于存放数据和间接指针的数据块总大小约为     (5) 30GB。</p>
<blockquote>
<p>答：<br>(1) (12+128)<em>512B = 71680B = 70KB<br>(2) (11+128+128</em>128) * 512B = 8459776B = 8261.5KB =8.068MB<br>(3) (11+256+256<em>256) * 1KB = 65803KB = 64.261MB<br>(4)3次。由上一问知，10MB需要通过二级间接索引访问，故需要访问二个索引块和一个数据块。<br>(5)30GB。inode大小:NBPI = 1:16，故1/16空间存放inode，15/16空间存放数据块。32</em>15/16=30GB。</p>
</blockquote>
</li>
<li><p>在某UNIX操作系统中，文件系统给文件分配外存空间采用的是混合索引分配方式。索引节点（inode）中包含13个直接块指针、1个一级间接块指针和1个二级间接块指针，间接块指向的是一个索引块，每个索引块和数据块的大小一致， 均为1KB，地址指针所占空间为4B。<br>13 * 1 + 256 * 1 +256 * 256 * 1<br>(1) 若某inode共有2个硬链接（hard link），分别为a和b，另有1个符号链接<br>（symbolic link）x-&gt;a，则该inode的link counter为 C。<br>A．0    B．1    C．2    D．3</p>
</li>
</ol>
<p>(2)将a删除后，访问x，结果为 A。<br>A．提示文件不存在    B．打开文件b C．打开一个空文件    D．x已被删除<br><a href="https://blog.csdn.net/kang19970201/article/details/88931745" target="_blank" rel="noopener">软连接和硬链接</a></p>
<p>(3)    假设该索引节点已经被加载进内存中，则若要读取文件的第1MB的内容，需要访问磁盘 C 次。<br>A．1    B．2    C．3    D．4<br> 1级 一个间接块 == 256个指针  256KB  269KB<br>需要访问二级间接  然后再访问数据 3次</p>
<p>(3)    该文件系统能支持的文件最大容量约为     。<br>A．64KB    B．64MB    C．4GB    D．16GB</p>
<blockquote>
<p>B<br>13 * 1 + 256 * 1 +256 * 256 * 1 </p>
</blockquote>
<p>(4)  若将数据块的大小修改为4KB，则该文件系统能支持的文件最大容量约为     。<br>A．64KB    B．64MB    C．4GB    D．16GB</p>
<blockquote>
<p>C<br>13 * 4+1024 * 4 +1024 * 1024 * 4 =4GB </p>
</blockquote>
<p>(5)    若保持数据块大小1KB不变，在不增加inode中的指针个数的前提下，取<br>消一个直接块指针，增加一个三级间接块指针，则能支持的文件最大容量约为     。<br>A．64KB    B．64MB    C．4GB    D．16GB</p>
<blockquote>
<p>D<br>主要看三级指针 256 * 256 * 256 * 1 KB = 2 ^ 24 = 16GB</p>
</blockquote>
<p>(6)    若inode的大小为128B，NBPI (Number of Bytes Per Inode) 为1024，则一个32GB大小的文件系统中，用于存放数据和间接指针的数据块总大小约为         。<br>A．4GB    B．8GB    C．24GB    D．28GB</p>
<blockquote>
<p>D<br>1024/128 = 8  1/8放 inode 7/8 放数据<br>7/8 * 32 = 28GB</p>
</blockquote>
<h4 id="解答题"><a href="#解答题" class="headerlink" title="解答题"></a>解答题</h4><p>关于四种磁盘调度策略的统一说明：</p>
<ul>
<li>1．SCAN算法，磁臂从磁盘的一端向另一端移动，当磁头移过每一个柱面时，处理位于该柱面上的请求服务。当到达另一端时，改变方向继续处理。（每次都运动到顶端）</li>
<li>2．C-SCAN算法，C-SCAN也是将磁头从磁盘一端移到另一端，随着移动不断的处理请求。但是，当磁头移到另一端时，会马上返回到磁盘开始，返回时不处理请求. （每次都运动到顶端）</li>
<li>3．LOOK算法：是改进的SCAN算法，与SCAN相似，只是每次都不运动到顶端，在最大磁道号和最小磁道号之间移动。</li>
<li>4．C-LOOK算法：是改进的C-SCAN算法，与C-SCAN相似，只是每次都不运动到顶端，在最大磁道号和最小磁道号之间移动。</li>
</ul>
<ol>
<li><p>在使用 Linux 操作系统管理文件时，你有一个 2TB 的大数据文件要存放到硬盘上，但是现在只有<br>二个 1TB 大小的硬盘。如果不考虑硬件上购买 RAID 等设备，请问你有什么办法来操作系统软件<br>层面上解决这个问题吗？</p>
<blockquote>
<p>答：使用 LVM 逻辑卷管理。（2 分）将两个硬盘设置成两个物理卷 VG（PV），再加入一个卷组（VG）<br>中，在卷组中创建一个 2TB 的逻辑卷，此时就可以将大数据文件放入此逻辑卷内的文件系统中。（3分）</p>
</blockquote>
</li>
<li><p>假如你刚刚成为一台服务器的管理员，这台服务器安装的是 Linux操作系统。<br>服务器上只有一块容量为 250GB 的硬盘，系统只划分了一个文件系统，所有<br>的数据都在根文件系统中。根据规划，这台服务器将要满足以下的需求：<br>（1） 开放给多个用户使用，限制每个用户在自己的主目录下最多只能存放<br>500MB 数据。另外，每个用户的邮箱限制只能容纳 200MB 的邮件。<br>（2） 目前计划支持的用户数 300 人，但是日后可能扩大，希望空间可以很<br>方便的扩充，但不能影响数据的正常使用。<br>（3） 服务器上安装数据库软件，需要一个很大的文件系统存放数据文件，<br>一个单独的数据文件甚至可能达到 2TB，文件系统则需要随时增长。<br>可以适当购买一些新硬盘，但是市场上能购买到的硬盘最大只有容量<br>为 1TB 的。<br>（4） 因节约成本，服务器没有安装硬件 RAID 支持，也没有购买 SAN 存储<br>阵列的。在这方面近期也没有新的预算。<br>请问你应该如何规划存储方案，满足上述要求？</p>
<blockquote>
<p>答：<br>（1）应该分别新建二个文件系统，一个用于用户主目录，挂载到/home 下，一个用于用<br>户邮箱，挂载到/var 下。使用用户磁盘配额设置，/home 设置每用户 500MB 配额，/var<br>设置每用户 200MB 配额。<br>（2）由于最大的文件系统可能要大于所有的硬盘，并且要满足文件系统可扩充的需求，<br>可以采用逻辑卷管理（LVM）技术。<br>在逻辑卷管理中，硬盘作为物理卷，组成卷组，在卷组中划分逻辑卷，逻辑卷中可以存<br>放文件系统。由于逻辑卷可以跨物理卷，并且可以动态调整大小，所以其中的文件系统<br>也可以具备这些好处</p>
</blockquote>
</li>
<li><p>在 inode 的多级索引指针中，为什么保留了直接指向数据块的指针，而不是<br>设计成只使用一个指向多级间接索引块的指针，就可以访问到所有的数据块？<br>数据块的大小可以影响文件系统能支持的最大文件的大小，但是数据块的大<br>小对文件系统的性能和空间利用率之间有什么关系？为什么？</p>
<blockquote>
<p>答：虽然只使用一个指向三级间接索引块的指针就可以访问到所有的数据块，但是小文<br>件也需要多级寻址，多次访问硬盘，影响速度。保留直接指向数据块的指针后，小文件<br>可以直接定位数据块，节约了访问硬盘的时间，ᨀ高了存取效率。</p>
</blockquote>
</li>
<li><p>、假设计算机系统采用 CSCAN(循环扫描)磁盘调度策略,使用 2KB 的内存空间<br>记录 16384 个磁盘块的空闲状态。<br>6<br>(1) 请说明在上述条件下如何进行磁盘块空闲状态的管理。<br>(2) 设某单面磁盘旋转速度为每分钟6000 转,每个磁道有100 个扇区,相邻磁<br>道间的平均移动时间为1ms。若在某时刻,磁头位于100 号磁道处,并沿着<br>磁道号增大的方向移动(如下图所示),磁道号请求队列为50,90,30,120,对<br>请求队列中的每个磁道需读取1 个随机分布的扇区,则读完这4 个扇区<br>点共需要多少时间?要求给出计算过程。<br>(3) 如果将磁盘替换为随机访问的Flash 半导体存储器(如U 盘、SSD 等),是<br>否有比CSCAN 更高效的磁盘调度策略?若有,给出磁盘调度策略的名称<br>并说明理由;若无,说明理由<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/os3.png" alt></p>
<blockquote>
<p>(1)位矢图法<br>(2)CSCAN:190.4ms<br>寻道时间: 20+90+20+40 = 170ms<br>旋转时间: 10ms /2 *4 =20ms<br>读数据: 10ms/100 *4 = 0.4ms<br>(3)FCFS</p>
</blockquote>
</li>
<li><p>在磁盘臂调度算法中，循环扫᧿算法（或称为循环电梯算法）（C-SCAN）对扫᧿算法（或称 为电梯算法）（SCAN）有什么改进之处？</p>
<blockquote>
<p>SCAN算法对两端磁道的响应时间过长，相对中间磁道而言不公平，而C-SCAN公平处理各磁道的请求</p>
</blockquote>
</li>
<li><p>Linux 中的为安全起见，一个用户不能进入另一个用户的主目录。现有一个文件需要<br>共享给二个用户，放在各自主目录下共同使用。如何实现？</p>
<blockquote>
<p>答：<br>方法 1：为这个文件设置两个（硬）连接，分别放在两个用户的主目录下即可。<br>方法 2：将这个文件放在两个用户均可访问的目录中，然后做两个（硬）连接或符号连<br>接，分别入在两个用户的主目录下即可。</p>
</blockquote>
</li>
<li><p>产生死锁的必要条件中，在实际操作系统里，哪个条件最有可能被破坏？如何做到<br>这一点？举例说明。</p>
<blockquote>
<p>答：最容易破坏的条件是：资源互斥使用。部分资源，如打印机，可以通过 SPOOLing<br>机制，为此类资源配备一个等待队列，即可破坏资源互斥使用。</p>
</blockquote>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3></li>
</ol>
<ul>
<li>进程与程序的区别?<br>操作系统中最核心的概念是进程,对正在运行程序的一个抽象.<br>进程是程序的 一次执行 过程，程序是进程 赖以存在 的基础。</li>
<li>多道程序 (伪并行):<br>在1秒钟期间,它可能运行多道程序,给人一种同时并行的错觉<br>拥有1个CPU实现多任务同时进行</li>
<li>在一个单CPU系统中，若有5个用户进程。假设当前系统为用户态，则处于就绪状态的用户进程最多有 4 个，最少有 0 个。<blockquote>
<p>注意，题目里给出的是假设当前系统为用户态，这表明现在有一个进程处于运行状态，因此最多有4个进程处于就绪态。也可能除一个在运行外，其他4个都处于阻塞。这时，处于就绪的进程一个也没有。</p>
</blockquote>
</li>
<li>可以把CPU的指令分为两类，一类是操作系统和用户都能使用的指令，一类是只能由操作系统使用的指令。前者称为“非特权”指令，后者称为“特权”指令。<h4 id="选择题-1"><a href="#选择题-1" class="headerlink" title="选择题"></a>选择题</h4></li>
</ul>
<ol>
<li><p>下列选项中，降低进程优先级的合理时机是<strong>A_</strong>。<br>A. 进程的时间片用完 B. 进程刚完成 I/O ,进入就绪队列<br>C. 进程长期处于就绪队列中 D. 进程从就绪态转为运行态</p>
</li>
<li><p>用户程序发出磁盘I/O请求后，系统的正确处理流程是（B）<br>A. 用户程序-&gt;系统调用处理程序-&gt;中断处理程序-&gt;设备驱动程序<br>B. 用户程序-&gt;系统调用处理程序-&gt;设备驱动程序-&gt;中断处理程序<br>C. 用户程序-&gt;设备驱动程序-&gt;系统调用处理程序-&gt;中断处理程序<br>D. 用户程序-&gt;设备驱动程序-&gt;中断处理程序-&gt;系统调用处理程序</p>
</li>
<li><p>在缺页处理过程中，操作系统执行的操作可能是（D）<br>I. 修改页表 II. 磁盘 I/O III. 分配页框<br>A. 仅 I, II B. 仅 II C. 仅 III D. I, II 和 III</p>
<blockquote>
<p>为什么?</p>
</blockquote>
</li>
<li><p>当系统发生抖动（trashing）时，可以采取的有效措施是（A）<br>I. 撤销部分进程 II. 增加磁盘交换区的容量 III. ᨀ高用户进程的优先级<br>A. 仅 I B. 仅 II C. 仅 III D. 仅 I, II</p>
</li>
</ol>
<ul>
<li>系统抖动，解释为在请求分页存储管理中，从主存（DRAM）中刚刚换出（Swap Out）某一页面后（换出到Disk），根据请求马上又换入（Swap In）该页，这种反复换出换入的现象。</li>
<li>产生该现象的主要原因是置换算法选择不当。<ul>
<li>1.如果分配给进程的存储块数量小于进程所需要的最小值，进程的运行将很频繁地产生缺页中断，这种频率非常高的页面置换现象称为抖动。解决方案优化置换算法。</li>
<li>2.在请求分页存储管理中，可能出现这种情况，即对刚被替换出去的页，立即又要被访问。需要将它调入，因无空闲内存又要替换另一页，而后者又是即将被访问的页，于是造成了系统需花费大量的时间忙于进行这种频繁的页面交换，致使系统的实际效率很低，严重导致系统瘫痪，这种现象称为抖动现象。解决方案运用局部性原理优化置换算法。</li>
</ul>
</li>
<li>危害：系统时间消耗在低速的I/O上，大大降低系统效率。进程对当前换出页的每一次访问，与对RAM中页的访问相比，要慢几个数量级。</li>
</ul>
<ol start="5">
<li><p>若系统S1 采用死锁避免方法，S2采用死锁检测方法，下列叙述中正确的是（）<br>Ⅰ. S1 会限制用户申请资源的顺序<br>Ⅱ．S1 需要进行所需资源总量信息，而 S2 不需要<br>Ⅲ．S1 不会给可能导致死锁的进程分配资源，S2 会<br>A．仅Ⅰ Ⅱ B．仅Ⅱ Ⅲ C．仅Ⅰ Ⅲ D．Ⅰ Ⅱ Ⅲ</p>
</li>
<li><p>两个进程合作完成一个任务。在并发执行中，一个进程要等待其合作伙伴发来消息，或者<br>建立某个条件后再向前执行，这种制约性合作关系被称为进程的（ ）。<br>A．同步 B．互斥 C．调度 D．执行</p>
</li>
<li><p>当一个进程处于(B)状态时,称其为等待(或阻塞)状态.<br>A. 它正等待中央处理机        B.它正等待合作进程的一个消息<br>C. 它正等待分给它一个时间片   D.它正在进入内存</p>
</li>
<li><p>下面关于线程的叙述中,正确的是(C)<br>A.不论是系统支持线程还是用户级线程,其切换都需要内核的支持.<br>B.线程是资源管理的分配单位,进程是调度和分配的单位<br>C.不管系统中是否有线程,进程都是拥有资源的独立单位.<br>D.在引入线程的系统中,进程仍是资源分配和调度分配的基本单位.</p>
</li>
<li><p>段页式存储管理汲取了页式管理和段式管理的长处,其实现原理结合了页式和段式管理的基本思想,即用分段式方法分配和管理用户地址空间,用分页方法管理物理存储空间.</p>
</li>
<li><p>下列调度算法中，不可能导致饥饿现象的是：A<br>A.时间片轮转    B.静态优先级调度    C.非抢占式作业优先    D.抢占式短作业优先</p>
</li>
<li><p>一个进程调用了阻塞式系统调用read()进行读磁盘操作，操作完成后，操作系统针对该进程必须做的是： A<br>A.修改进程状态为就绪态    B.降低进程优先级<br>C.进程分配用户内存空间    D.增加进程的时间片大小  </p>
</li>
<li><p>设m为同类资源数，n为系统中并发线程数。当n个进程共享m个互斥资源时，每个进程的最大需求是w；则下列情况会出现系统死锁的是：D<br>A. m=2,n=1,w=2    B. m=2,n=2,w=1    C. m=4,n=3,w=2    D. m=4,n=2,w=3</p>
</li>
<li><p>下列关于银行家算法的叙述中，正确的是 B<br>A.银行家算法可以预防死锁<br>B.当系统处于安全状态时，系统中一定无死锁进程<br>C.当系统处于不安全状态时，系统中一定会出现死锁进程<br>D.银行家算法破坏了死锁必要条件中的“请求和保持”条件</p>
</li>
<li><p>在多进程的系统中，为了保证公共变量的完整性，各进程应互斥进入临界区。所<br>谓临界区是指<strong><em>D</em></strong>。<br>A．一个缓冲区 B．一段数据区 C．同步机制 D．一段程序</p>
</li>
<li><p>某单CPU系统中有输入和输出设备各1台，现有3个并发执行的作业，每个作业的<br>输入、计算和输出时间均分别为2ms、3ms和4ms，且都按输入、计算和输出的顺序执<br>行，则执行完3个作业需要的时间最少是<strong>B</strong>。<br>A. 15ms B. 17ms C. 22ms D.27ms</p>
</li>
<li><p>下面对进程的描述中，错误的是 D 。<br>A．进程是动态的概念 B．进程的执行需要CPU<br>C．进程具有生命周期 D．进程是指令的集合</p>
</li>
<li><p>既考虑作业等待时间，又考虑作业执行时间的作业调度算法是 A 。<br>A．响应比高者优先 B．短作业优先<br>C．优先级调度 D．先来先服务</p>
<h4 id="计算题-1"><a href="#计算题-1" class="headerlink" title="计算题"></a>计算题</h4></li>
<li><p>有3个CPU密集型批处理作业，按照A、B和C的顺序间隔4分钟依次ᨀ交。预计运行时间分别为12， 8和4分钟。对于下列每种调度算法，忽略进程切换的开销，计算其平均进程周转时间。<br>(1) 采用先来先服务调度算法，平均进程周转时间为多少。 (2) 采用最短作业优先调度算法，平均进程周转时间为多少。</p>
</li>
</ol>
<p>FCFS，作业调度顺序：A-&gt;B-&gt;C</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">到达日期</th>
<th align="center">运行时间</th>
<th align="center">等待时间</th>
<th align="center">结束时间</th>
<th align="center">周转时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">0</td>
<td align="center">12</td>
<td align="center">0</td>
<td align="center">12</td>
<td align="center">12</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">20</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">8</td>
<td align="center">4</td>
<td align="center">12</td>
<td align="center">24</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">故平远周转时间：(12+16+16)/3 = 14.67 min（3 分）</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2）SJF，作业调度顺序：A -&gt;C-&gt;B</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">到达日期</td>
<td align="center">运行时间</td>
<td align="center">等待时间</td>
<td align="center">结束时间</td>
<td align="center">周转时间</td>
</tr>
<tr>
<td align="center">:-:</td>
<td align="center">:-:</td>
<td align="center">:-:</td>
<td align="center">:-:</td>
<td align="center">:-:</td>
<td align="center">:-:</td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">0</td>
<td align="center">12</td>
<td align="center">0</td>
<td align="center">12</td>
<td align="center">12</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">12</td>
<td align="center">24</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">8</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">16</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">故平远周转时间：(12+20+8)/3 = 13.33 min（3 分）</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2. 银行家算法问题</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="解答题-1"><a href="#解答题-1" class="headerlink" title="解答题"></a>解答题</h4><ol>
<li><p>你需要在一个很古老的 UNIX 上编写支持多线程的程序，它的内核不支持线程，内核代码也未公开，所以很难改造内核。请问如何解决这个问题？</p>
<blockquote>
<p>答:应该使用用户态线程。<br>在进程中设计运行时环境，由运行时控制多个线程的调度运行。内核不感知线程的<br>存在，只调度进程。资源分配给进程使用。</p>
</blockquote>
</li>
<li><p>在 UNIX 中父进程通过 fork()产生与自己一模一样的子进程，请问执行什么系统调用后，子进程才拥有自己独立的新代码段。这个系统调用的返回值是如何规定的？</p>
<blockquote>
<p>答:exec    系列函数，如 execlp()等。该系统调用替换进程的正文段，如果成功，没<br>有返回值，如果失败，返回值为-1。</p>
</blockquote>
</li>
<li><p>当检测到死锁发生时，如果必须杀死一个进程以解除死锁，请问以什么标准来选择被杀死的进程比较合理？</p>
<blockquote>
<p>答:一般选择运行时间较短的进程，因为这样重新运行的代价较小，另外，程序<br>需要可以多次运行不影响执行结果。还要考虑杀死优先级较低的进程等</p>
</blockquote>
</li>
<li><p>有三个批处理作业，第一个作业 10:00 到达，需要执行 2 小时;第二个作业在 10:10<br>到 达，需要执行 1 小时;第三个作业在 10:25 到达，需要执行 25 分钟。分别采用<br>先来先服务，短作业优先和最高响应比优先三种调度算法，各自的平均周转时间是多<br>少?</p>
<blockquote>
<p>解：<br>FCFS：执行顺序1-&gt;2-&gt;3，平均周转时间为(120+170+180)/3=156.7分=2.61小时<br>SJF：执行顺序1-&gt;3-&gt;2，平均周转时间为(120+195+120)/3=145分=2.42小时<br>HRF：执行顺序 1-&gt;3-&gt;2，平均周转时间为(120+195+120)/3=145 分=2.42 小时<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/os4.png" alt></p>
</blockquote>
</li>
<li><p>某系统有三个作业：<br><img src="https://img-blog.csdn.net/20180920030652549?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDMzNzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>系统确定在它们全部到达后，开始采用响应比高者优先调度算法，并忽略系统调度时间。试问对它们的调度顺序是什么？各自的周转时间是多少？</p>
</li>
</ol>
<p>响应比= 等待时间/所需cpu时间；响应比最高开始运行</p>
<p>解：三个作业是在9.5时全部到达的。这时它们各自的响应比如下：<br>作业1的响应比 =（9.5 – 8.8）/ 1.5 = 0.46<br>作业2的响应比 =（9.5 – 9.0）/ 0.4 = 1.25<br>作业3的响应比 =（9.5 – 9.5）/ 1.0 = 0<br>因此，最先应该调度作业2运行，因为它的响应比最高。它运行了0.4后完成，这时的时间是9.9。再计算作业1和3此时的响应比：<br>作业1的响应比 =（9.9 – 8.8）/ 1.5 = 0.73<br>作业3的响应比 =（9.9 – 9.5）/ 1.0 = 0.40<br>因此，第二个应该调度作业1运行，因为它的响应比最高。它运行了1.5后完成，这时的时间是11.4。第三个调度的是作业3，它运行了1.0后完成，这时的时间是12.4。整个实施过程如下。<br><img src="https://img-blog.csdn.net/20180920031138869?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDMzNzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<ol start="6">
<li><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/os5.png" alt><br> ① 系统中资源总量为某时刻系统中可用资源量与各进程已分配资源量之和，所以各种资源总<br>数为(9,3,6)。各进程对资源的需求量为各进程对资源的最大需求量与进程已分配资源量之差，<br> <img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/os6.png" alt></p>
</li>
<li><p>死锁是一种对操作系统正常运行危害很大的现象，但是大多数死锁的解决方法只<br>停留在理论探讨中，无法应用于实际的操作系统系统。请列举中哪些方法是实际操作<br>系统中采用的应对死锁的可行方法。如果操作系统发现死锁已经发生，应如何应对使<br>造成的损失较小？</p>
<blockquote>
<p>答:实际常采用的方法:    1、鸵鸟算法。因为处理死锁成本太高，而死锁出现的频<br>率较低，故可以忽略死锁的发生。 2、Spooling 技术。假脱机技术。为临界资源增<br>加一个等待队列，使其好像可以被共享使用，如打印机。 当死锁发生时，杀死运<br>行时间较短的进程，损失较小，因为容易恢复。</p>
</blockquote>
</li>
<li><p>在多道程序设计系统中，如何理解“内存中的多个程序的执行过程交织在一起，大家都在走走停停”这样一个现象？</p>
<blockquote>
<p>答：在多道程序设计系统中，内存中存放多个程序，它们以交替的方式使用CPU。因此，从宏观上看，这些程序都开始了自己的工作。但由于CPU只有一个，在任何时刻CPU只能执行一个进程程序。所以这些进程程序的执行过程是交织在一起的。也就是说，从微观上看，每一个进程一会儿在向前走，一会儿又停步不前，处于一种“走走停停”的状态之中。</p>
</blockquote>
</li>
<li><p>作业调度与进程调度有什么区别？</p>
<blockquote>
<p>答：作业调度和进程调度（即CPU调度）都涉及到CPU的分配。<br>但作业调度只是选择参加CPU竞争的作业，它并不具体分配CPU。<br>而进程调度是在作业调度完成选择后的基础上，把CPU真正分配给某一个具体的进程使用。</p>
</blockquote>
</li>
<li><p>为什么说响应比高者优先作业调度算法是对先来先服务以及短作业优先这两种调度算法的折中？</p>
<blockquote>
<p>答：先来先服务的作业调度算法，重点考虑的是作业在后备作业队列里的等待时间，因此对短作业不利；<br>短作业优先的作业调度算法，重点考虑的是作业所需的CPU时间（当然，这个时间是用户自己估计的），因此对长作业不利。<br>“响应比高者优先”作业调度算法，总是在需要调度时，考虑作业已经等待的时间和所需运行时间之比，即：<br>该作业已等待时间 / 该作业所需CPU时间</p>
</blockquote>
</li>
<li><p>进程可以在运行、就绪和阻塞三个状态之间转换，试分析各种转换的发生时机和引发者</p>
<blockquote>
<p>答：运行-&gt;就绪：运行态进程时间片用完，由scheduler剥夺处理器进行调度。 就绪-&gt;运行：处理器空闲时，由scheduler挑选一个就绪进程，分配其处理器开始运行。 运行-&gt;阻塞：正在运行的进程，发现缺少资源或等待特定事件发生时，主动放弃处理器。 阻塞-&gt;就绪：阻塞态进程，阻塞其运行的条件消失，如缺少的资源可用，或特定的事件发生， 这时该进程被释放该资源或引发该事件的进程唤醒被阻塞的进程，被阻塞的进程转入就绪状态，等待 被调度运行。</p>
</blockquote>
</li>
<li><p>什么是系统调用（System call或称为System API）？简述一下系统调用的使用方法和执行过程。在Shell中执行一个命令，从输入命令开始到命令结束，至少可能会涉及到哪些系统调用，这些系统调用的功能分别是什么？</p>
<blockquote>
<p>答：系统调用是由操作系统内核提供的服务例程。用户程序通过软中断的形式调用系统调用，执行过<br>程与中断相似。在shell中执行的命令，至少要涉及到以下系统调用：<br>fork() 创建一个子进程<br>exec() 替换进程代码段<br>wait() 等待其他进程结束<br>exit() 结束当前进程</p>
</blockquote>
</li>
<li><p>分时操作系统中进程调度算法中对普通进程常常采用的是优先级轮转法，请问如何保证不会有进程因为优先级太低而饥饿？</p>
<blockquote>
<p>答：采用动态调整进程优先级的方法。动态降低长时间占用CPU进程的优先级，低优先级的进程的优先级则相对升高，最终得到运行。</p>
</blockquote>
</li>
<li><p>死锁是一种对操作系统正常运行危害很大的现象，但是大多数死锁的解决方法只停留在理论探讨中，无法应用于实际的操作系统系统。请列举中哪些方法是实际操作系统中采用的应对死锁的可行方法。如果操作系统发现死锁已经发生，应如何应对使造成的损失较小？</p>
<blockquote>
<p>答：实际常采用的方法：<br>1、鸵鸟算法。因为处理死锁成本太高，而死锁出现的频率较低，故可以忽略死锁的发生。<br>2、Spooling技术。假脱机技术。为临界资源增加一个等待队列，使其好像可以被共享使用，如打印机。<br>当死锁发生时，杀死运行时间较短的进程，损失较小，因为容易恢复。</p>
</blockquote>
</li>
<li><p>简述进程与线程的区别与联系。进程间通信和线程间通信有什么异同？<br>答：</p>
<blockquote>
<p>线程是进程中的执行序列，进程是资源分配的单位，进程和线程都可以被调度。进程间一般不共享资源，所以进程间通信需要操作系统内核支持，使用信号、管道、SysV IPC或sockets等技术实现共享信号、信号量、共享内存、队列等信息。同一个进程内的线程间共享进程的所有资源，所以很容易实现通信。进程间与线程间通信都面临互斥和同步问题，也都需要加锁、信号量等方法来解决。</p>
</blockquote>
</li>
<li><p>在引入线程概念的操作系统中，操作系统将资源分配给线程还是进程？为什么？在线程实现<br>的二种方案中，线程实现在用户级与实现在内核级相比，有什么缺点？</p>
<blockquote>
<p>答：资源分配给进程，因为进程是资源分配的最小单位，线程是在进程内，共享使用进程的资<br>源。线程实现在用户级，当一个线程阻塞时，内核会阻塞这个线程所在进程，导致这个进程中<br>其他可以运行的线程也被阻塞。</p>
</blockquote>
</li>
<li><p>什么是 SPOOLing 技术？它是如何在解决死锁问题中得到应用的？</p>
<blockquote>
<p>SPOOLing 技术又称为“假脱机技术“。它可以破坏”独占使用“条件。例如打印机为临界资<br>源，可以在硬盘上开辟一个目录，所有的打印任务都ᨀ交的这个目录下的队列中，由一个打印<br>队列监控程序（daemon）负责将任务送到打印机上打印。</p>
</blockquote>
</li>
<li><p>为什么要使用倒排页表？倒排页表面临的最大的问题是什么？如何解决？</p>
<blockquote>
<p>答：在 64 位系统中，由于虚拟地址太大，普通页表会非常大，无法存储。另一方面，实际内存<br>相对较小，所以建立一张从物理地址索引得到相对地址的倒排页表。<br>最大的问题的难于从相对地址查找到绝对地址。可以采用 hash 表ᨀ高查找效率，并使用 TLB<br>加速查找。</p>
</blockquote>
</li>
<li><h4 id="PV题"><a href="#PV题" class="headerlink" title="PV题"></a>PV题</h4></li>
</ol>
<ul>
<li>“虚拟化与云计算”课程安排上机，假设机房共有 2m 台机器，有 2n 名学生选该课，<br>其中 m,n 为正整数且 m&lt;n。规定：<br>（1） 按到达顺序，两个学生组成一组，每人占一台机器，协同完成上机实习；<br>（2） 两个学生到齐，并且此时机房有空闲机器时，方可进入机房；<br>试用类 C 语言，使用 PV 操作实现上述要求。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore computer=<span class="number">2</span>m; <span class="comment">//控制对机器使用的信号量</span></span><br><span class="line">semaphore pair=<span class="number">0</span>; <span class="comment">//保证学生成对进入的信号量</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>; <span class="comment">//保证变量互斥访问的信号量</span></span><br><span class="line"><span class="keyword">int</span> sc=<span class="number">0</span>; <span class="comment">//到达学生的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">student</span><span class="params">()</span></span>&#123;</span><br><span class="line">P(mutex); <span class="comment">//加锁，保证变量 sc 互斥使用</span></span><br><span class="line">sc=sc+<span class="number">1</span>; <span class="comment">//学生以到达顺序编号</span></span><br><span class="line"><span class="keyword">if</span> (sc%<span class="number">2</span>==<span class="number">1</span>) &#123; <span class="comment">//奇数编号的学生到达</span></span><br><span class="line"> V(mutex); <span class="comment">//解锁</span></span><br><span class="line"> P(pair); <span class="comment">//申请结对进入</span></span><br><span class="line">&#125; <span class="keyword">else</span> ( <span class="comment">//偶数编号的学生到达</span></span><br><span class="line"> V(mutex); <span class="comment">//解锁</span></span><br><span class="line"> V(pair); <span class="comment">//完成结对</span></span><br><span class="line">&#125;</span><br><span class="line">P(computer); <span class="comment">//申请计算机</span></span><br><span class="line">上机实习…</span><br><span class="line">V(computer); <span class="comment">//释放计算机</span></span><br><span class="line">&#125;</span><br><span class="line">评分标准：</span><br><span class="line">（<span class="number">1</span>） 正确定义信号量和共享变量，并赋初值。（<span class="number">2</span> 分）</span><br><span class="line">（<span class="number">2</span>） 正确使用信号量（mutex），保证共享变量（sc）被互斥使用。（<span class="number">2</span> 分）如存在死锁</span><br><span class="line">可能，如在 V(mutex)前就做 P(pair)，则此处只得 <span class="number">1</span> 分。</span><br><span class="line">（<span class="number">3</span>） 正确使用信号量（pair），保证学生结对。（<span class="number">2</span> 分）</span><br><span class="line">（<span class="number">4</span>） 正确使用共享变量（sc），实现对学生编号的判断。（<span class="number">2</span> 分）</span><br><span class="line">（<span class="number">5</span>） 正确使用信号量（computer），实现对计算机资源的控制。（<span class="number">2</span> 分）</span><br><span class="line">解法不唯一，如有其他解题思想，酌情给分。</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>某停车场有 M 个大型车车位和 N 个小型车车位，大型车必须停大型车车位内，小型车优先停小型<br>车车位，在小型车车位全满的情况下，也可以停入大型车车位。大型车与小型车分别从两个入口<br>进入停车场。当车位已满时，车辆在停车场外排队等候。为实现上述控制，请用 PV 原语和信号<br>量，分别描述大型车和小型车使用停车场的过程。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore big=M; <span class="comment">//大型车车位</span></span><br><span class="line">Semaphore all=M+N; <span class="comment">//总车位</span></span><br><span class="line">BigCar()&#123;</span><br><span class="line">P(big); <span class="comment">//如果有大型车车位，则占大型车车位</span></span><br><span class="line">P(all); <span class="comment">//占一个总车位</span></span><br><span class="line">大型车进车位</span><br><span class="line">V(big); <span class="comment">//释放一个大型车车位</span></span><br><span class="line">V(all); <span class="comment">//释放一个总车位</span></span><br><span class="line">&#125;</span><br><span class="line">SmallCar() &#123;</span><br><span class="line">P(all); <span class="comment">//占一个总车位</span></span><br><span class="line">小型车进车位</span><br><span class="line">V(all); <span class="comment">//释放一个总车位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设有两个优先级相同的进程 P1 和 P2，共享 x、y、z 三个变量，执行代码见下表。信号量 s1 和s2 的初值均为 0。试问 P1、P2 并发执行后，x、y、z 的值各是多少？给出解题过程。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">进程 P1</th>
<th align="left">进程 P2</th>
</tr>
</thead>
<tbody><tr>
<td align="left">y=1;</td>
<td align="left">x=1;</td>
</tr>
<tr>
<td align="left">y=y+2;</td>
<td align="left">x=x+2;</td>
</tr>
<tr>
<td align="left">V(s1);</td>
<td align="left">P(s1);</td>
</tr>
<tr>
<td align="left">z=y+1;</td>
<td align="left">x=x+y;</td>
</tr>
<tr>
<td align="left">P(s2);</td>
<td align="left">V(s2);</td>
</tr>
<tr>
<td align="left">y=z+y;</td>
<td align="left">z=x+z;</td>
</tr>
</tbody></table>
<blockquote>
<p>答：<br>P1 的 6 条语句，分别用 P1-1 ~ P1-6 表示，P2 的 6 条语句，分别用 P2-1 ~ P2-6 表示。<br>根据信号量的约束，P1-6 一定晚于 P2-5 执行，而 P2-4 一定晚于 P1-3，而其他顺序不受<br>限制。执行顺序不同后导致结果不同的语句有：P1-6, P2-4, P2-6<br>(1) 由于 P2-4 一定晚于 P1-3，但一定早于 P1-6，而 P1-3~P1-6 期间 y=3，所以最终 x=6<br>(2) 如果 P2-6 早于 P1-4 执行，则 P2-6 使 z=6，然后 P1-4 使 z=4，P1-6 使 y=7<br>(3) 如果 P2-6 晚于 P1-4，但早于 P1-6 执行，则 P1-4 使 z=4，P2-6 使 z=10，P1-6 使 y=13<br>(4) 如果 P2-6 晚于 P1-6 执行，则 P1-4 使 z=4，P1-6 使 y=7，P2-6 使 z=10<br>综上所述：<br>如果 P2-6 早于 P1-4 执行，则 x=6, y=7, z=4<br>如果 P2-6 晚于 P1-4，但早于 P1-6 执行，则 x=6, y=13, z=10<br>如果 P2-6 晚于 P1-6 执行，则 x=6, y=7, z=10</p>
</blockquote>
<p>2.理发师问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>;    <span class="comment">//互斥信号量，初值为1.</span></span><br><span class="line">Semaphore  Wait = <span class="number">0</span>;     <span class="comment">//等待服务的顾客数 </span></span><br><span class="line">Semaphore  barbers= <span class="number">0</span>;    <span class="comment">//等待顾客的理发师数</span></span><br><span class="line">Int custNum = <span class="number">0</span>;    <span class="comment">//等待的顾客(还没理发的)  </span></span><br><span class="line"></span><br><span class="line">Costumer()</span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">　　&#123;</span><br><span class="line">        P(mutex);            <span class="comment">//申请理发</span></span><br><span class="line">        <span class="keyword">if</span>(custNum&gt;<span class="number">0</span>)         </span><br><span class="line">　　　　　&#123;</span><br><span class="line">            <span class="keyword">if</span>(custNum&lt;N)   <span class="comment">//若等待人数小于N</span></span><br><span class="line">　　　　　　　&#123;</span><br><span class="line">                V(mutex);     <span class="comment">//释放进程等待</span></span><br><span class="line">                CustNum++；     <span class="comment">//增加等待人数</span></span><br><span class="line">            &#125;</span><br><span class="line">　　　　　　　<span class="keyword">else</span>            <span class="comment">//若等待人数超过N</span></span><br><span class="line">　　　　　　　　&#123;</span><br><span class="line">                V(mutex);   <span class="comment">//释放进程等待</span></span><br><span class="line">                离开；</span><br><span class="line">             &#125;</span><br><span class="line">　　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">else</span>                <span class="comment">//若目前无人等待</span></span><br><span class="line">　　　　&#123;</span><br><span class="line">            V(mutex);        <span class="comment">//释放进程等待</span></span><br><span class="line">            V(barbers)；     <span class="comment">//如果必要的话，唤醒理发师</span></span><br><span class="line">            理发；</span><br><span class="line">            离开；</span><br><span class="line">            P(mutex);        <span class="comment">//要求进程等待</span></span><br><span class="line">            custNum--；        <span class="comment">//顾客人数减1</span></span><br><span class="line">            V(mutex);       <span class="comment">//释放进程等待</span></span><br><span class="line">            V(wait);        <span class="comment">//等待人数减1</span></span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Barber()</span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">　　&#123;</span><br><span class="line">        P(mutex);            <span class="comment">//要求进程等待</span></span><br><span class="line">        <span class="keyword">if</span>(custNum ==<span class="number">0</span>)    <span class="comment">//目前无顾客</span></span><br><span class="line">　　　　 &#123;</span><br><span class="line">            V(mutex);        <span class="comment">//释放进程等待</span></span><br><span class="line">            P(barbers);        <span class="comment">//理发师睡觉</span></span><br><span class="line">　　     &#125;</span><br><span class="line">　　　　<span class="keyword">else</span></span><br><span class="line">　　　　&#123;</span><br><span class="line">            V(mutex);        <span class="comment">//释放进程等待</span></span><br><span class="line">            理发;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、烟—吸烟者问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore S = <span class="number">1</span>;                <span class="comment">//供应者</span></span><br><span class="line">Semaphore S1,S2,S3;                <span class="comment">//三个吸烟者</span></span><br><span class="line">S1 = S2 = S3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> flag1,flag2,fiag3;            <span class="comment">//三种吸烟原料</span></span><br><span class="line">fiag1=flag2=flag3=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">Apply()                            <span class="comment">//供应者</span></span><br><span class="line">&#123;</span><br><span class="line">　　While(<span class="literal">true</span>)</span><br><span class="line">　　&#123;</span><br><span class="line">          P(S);</span><br><span class="line">　　   　　 取两样香烟原料放桌上，由flagi标记；</span><br><span class="line">　　　     <span class="keyword">if</span> (flag2 &amp;&amp; flag3) <span class="comment">//供纸和火柴</span></span><br><span class="line">　　　　　　&#123;</span><br><span class="line">　　　        V(S1);          <span class="comment">//唤醒吸烟者一</span></span><br><span class="line">　　　       &#125;</span><br><span class="line">　　       <span class="keyword">else</span> <span class="keyword">if</span>(flag1 &amp;&amp; fiag3) <span class="comment">//供烟草和火柴</span></span><br><span class="line">　　　　　　&#123;</span><br><span class="line">　　　        V(S2);                <span class="comment">//唤醒吸烟者二</span></span><br><span class="line">　　　       &#125;</span><br><span class="line">　　   　　<span class="keyword">else</span>                      <span class="comment">//供烟草和纸</span></span><br><span class="line">　　　　　　&#123;</span><br><span class="line">　　　        V(S3);                <span class="comment">//唤醒吸烟者三</span></span><br><span class="line">           &#125;</span><br><span class="line">　　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Smoker1()                         <span class="comment">//吸烟者一</span></span><br><span class="line">&#123;</span><br><span class="line">　　　While(<span class="literal">true</span>)</span><br><span class="line">　　 &#123;</span><br><span class="line">　　　    P(S1);</span><br><span class="line">　　　    取原料；</span><br><span class="line">　　　    做香烟；</span><br><span class="line">　　　    V(S);                    <span class="comment">//唤醒供应者</span></span><br><span class="line">　　　    吸香烟；</span><br><span class="line">　　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker2()                        <span class="comment">//吸烟者二</span></span><br><span class="line">&#123;</span><br><span class="line">　　　While(<span class="literal">true</span>)</span><br><span class="line">　　　&#123;</span><br><span class="line">　　　    P(S2);</span><br><span class="line">　　　    取原料；</span><br><span class="line">　　　    做香烟；</span><br><span class="line">　　　    V(S);                    <span class="comment">//唤醒供应者</span></span><br><span class="line">　　　    吸香烟;</span><br><span class="line">　　　&#125;</span><br><span class="line">&#125;　　</span><br><span class="line"></span><br><span class="line">Smoker3()                        <span class="comment">//吸烟者三</span></span><br><span class="line">&#123;</span><br><span class="line">　　　While(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">　　　    P(S3);</span><br><span class="line">　　     取原料；</span><br><span class="line">　　     做香烟；</span><br><span class="line">　　　    V(S);                    <span class="comment">//唤醒供应者</span></span><br><span class="line">　　　   吸香烟;</span><br><span class="line">　　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.面包师问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore buyer= <span class="number">0</span>;                <span class="comment">//顾客人数</span></span><br><span class="line">Semaphore seller = n;            <span class="comment">//销售人员数</span></span><br><span class="line">Semaphore mutex_s = <span class="number">1</span>;            <span class="comment">//用于销售人员的互斥信号量</span></span><br><span class="line">Semaphore mutex_b = <span class="number">1</span>;            <span class="comment">//用于顾客的互斥信号量</span></span><br><span class="line"><span class="keyword">int</span> count_s = <span class="number">0</span>;                <span class="comment">//记录取号的值</span></span><br><span class="line"><span class="keyword">int</span> count_b = <span class="number">0</span>;                <span class="comment">//记录叫号的值 </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Buy</span><span class="params">()</span>                    <span class="comment">//顾客进程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     进店；</span><br><span class="line">    P(mutex_b);          <span class="comment">//取号</span></span><br><span class="line">    count_b++; </span><br><span class="line">　　 V(mutex_b);</span><br><span class="line">　　 V(buyer);</span><br><span class="line"> 　　P(seller);            <span class="comment">//等待叫号</span></span><br><span class="line">    买面包；</span><br><span class="line">    离开             </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         P(buyer);</span><br><span class="line">         P(mutex_s);   <span class="comment">//叫号</span></span><br><span class="line">        </span><br><span class="line">         count_s++;</span><br><span class="line">         </span><br><span class="line">         叫编号为count_s的顾客；</span><br><span class="line">         V(mutex_s);</span><br><span class="line">         V(seller)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.</p>
<blockquote>
<p>桌子上有一只盘子，最多可容纳两个水果，每次只能放入或取出一个水果。爸爸专向盘<br>子放苹果（ apple），妈妈专向盘子中放桔子（ orange）；两个儿子专等吃盘子中的桔子，<br>两个女儿专等吃盘子中的苹果。请用 P、 V 操作来实现爸爸、妈妈、儿子、女儿之间的<br>同步与互斥关系。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>;      <span class="comment">//互斥信号量, 其初值为1</span></span><br><span class="line">Semaphore empty = <span class="number">2</span>;       <span class="comment">//记录允许向盘子中放入水果的个数，初值为2</span></span><br><span class="line">Semaphore orange = <span class="number">0</span>;      <span class="comment">//盘子中已放入的苹果的个数，初值为0</span></span><br><span class="line">Semaphore apple = <span class="number">0</span>;      <span class="comment">//盘子中已放入的桔子的个数，初值为0</span></span><br><span class="line">main()  </span><br><span class="line">&#123;   </span><br><span class="line">Cobegin  </span><br><span class="line">&#123;   </span><br><span class="line">　 father                    <span class="comment">//父亲进程  </span></span><br><span class="line">    &#123;   </span><br><span class="line">　　　　<span class="keyword">while</span> (<span class="literal">true</span>)  </span><br><span class="line">       &#123;   </span><br><span class="line">　　　　　　　　  P(empty);           <span class="comment">//减少盘中可放入的水果数  </span></span><br><span class="line">                P(mutex);           <span class="comment">//申请向盘中取、放水果  </span></span><br><span class="line">                向盘中放苹果;  </span><br><span class="line">                V(mutex);           <span class="comment">//允许向盘中取、放水果  </span></span><br><span class="line">                V(apple);           <span class="comment">//递增盘中的苹果数  </span></span><br><span class="line">        &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">    mother                    <span class="comment">//母亲进程  </span></span><br><span class="line">    &#123;   </span><br><span class="line">　　　　<span class="keyword">while</span> (<span class="literal">true</span>)  </span><br><span class="line">       &#123;   </span><br><span class="line">　　　　　　　　　 P(empty);           <span class="comment">//减少盘中可放入的水果数  </span></span><br><span class="line">                P(mutex);           <span class="comment">//申请向盘中取、放水果  </span></span><br><span class="line">                向盘中放桔子;  </span><br><span class="line">                V(mutex);           <span class="comment">//允许向盘中取、放水果  </span></span><br><span class="line">                V(orange);          <span class="comment">//递增盘中的桔子数  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    daughteri（i=<span class="number">1</span>,<span class="number">2</span>）      <span class="comment">//两女儿进程  </span></span><br><span class="line">    &#123;   </span><br><span class="line">　　　　<span class="keyword">while</span> (<span class="literal">true</span>)  </span><br><span class="line">       &#123;   </span><br><span class="line">　　　　　　      P(apple);           <span class="comment">//减少盘中苹果数  </span></span><br><span class="line">                P(mutex);           <span class="comment">//申请向盘中取、放水果  </span></span><br><span class="line">                取盘中苹果;  </span><br><span class="line">                V(mutex);           <span class="comment">//允许向盘中取、放水果  </span></span><br><span class="line">                V(empty);           <span class="comment">//递增盘中可放入的水果数  </span></span><br><span class="line">        &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">    sonj（j=<span class="number">1</span>,<span class="number">2</span>）           <span class="comment">//两儿子进程  </span></span><br><span class="line">    &#123;   </span><br><span class="line">　　　　<span class="keyword">while</span> (<span class="literal">true</span>)  </span><br><span class="line">       &#123;   </span><br><span class="line">　　　　　　　　  P(orange);          <span class="comment">//减少盘中桔子数  </span></span><br><span class="line">                P(mutex);           <span class="comment">//申请向盘中取、放水果  </span></span><br><span class="line">                取盘中桔子;  </span><br><span class="line">                V(mutex);           ／/允许向盘中取、放水果  </span><br><span class="line">                V(empty);           <span class="comment">//递增盘中可放入的水果数  </span></span><br><span class="line">        &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">    Coend  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.有一个仓库，可以存放 A 和 B 两种产品，仓库的存储空间足够大，但要求：<br>（ 1）一次只能存入一种产品（ A 或 B）；<br>（ 2） -N &lt; (A 产品数量-B 产品数量) &lt; M。<br>其中， N 和 M 是正整数。试用“存放 A”和“存放 B”以及 P、 V 操作描述产品 A 与<br>产品 B 的入库过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>;   <span class="comment">//互斥信号量</span></span><br><span class="line">Semaphore a = M<span class="number">-1</span> ;   <span class="comment">//存放A的资源信号量，初值为M-1</span></span><br><span class="line">Semaphore b = N<span class="number">-1</span>;      <span class="comment">//存放B的资源信号量，初值为N-1</span></span><br><span class="line">存放 A:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">        Get A；</span><br><span class="line">        P(&amp;a); </span><br><span class="line">         P(&amp;mutex); </span><br><span class="line">Put A；  </span><br><span class="line">V(&amp;mutex);  </span><br><span class="line">V(&amp;b);</span><br><span class="line">&#125;  </span><br><span class="line">&#125; </span><br><span class="line">存放B:</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123; </span><br><span class="line">        Get B；</span><br><span class="line">        P(&amp;b);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        Put B；</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        V(&amp;a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>三个进程 P1、 P2、 P3 互斥使用一个包含 N(N&gt;0)个单元的缓冲区。 P1 每次用 produce()<br>生成一个正整数并用 put()送入缓冲区某一空单元中;P2 每次用 getodd()从该缓冲区中<br>取出一个奇数并用 countodd()统计奇数个数;P3 每次用 geteven()从该缓冲区中取出一<br>个偶数并用 counteven()统计偶数个数。请用信号量机制实现这三个进程的同步与互斥活<br>动,并说明所定义信号量的含义。要求用伪代码描述。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1()</span><br><span class="line">&#123;  </span><br><span class="line">　　　While(<span class="literal">true</span>)</span><br><span class="line">　　　&#123;</span><br><span class="line">　　　    X = produce();      <span class="comment">//生成一个数</span></span><br><span class="line">　　　 　 P(empty);     <span class="comment">//是否有空单元格</span></span><br><span class="line">　　　    P(mutex);    <span class="comment">//进入临界区</span></span><br><span class="line">　　　    Put();  </span><br><span class="line">　　　    <span class="keyword">if</span>(X%<span class="number">2</span> == <span class="number">0</span>)  </span><br><span class="line">　　　         V(s2);   <span class="comment">//如果是偶数，向P3发出信号 </span></span><br><span class="line">　　　    <span class="keyword">else</span>  </span><br><span class="line">　　　          V(s1);   <span class="comment">//如果是奇数，向P2发出信号 </span></span><br><span class="line">　　　    V(mutex);         <span class="comment">//离开临界区，释放互斥信号量  </span></span><br><span class="line">　　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()</span><br><span class="line">&#123;  </span><br><span class="line">　　　While(<span class="literal">true</span>)</span><br><span class="line">　　　&#123;</span><br><span class="line">　　　    P(s1);     <span class="comment">//收到P1发送来的信号，已产生奇数</span></span><br><span class="line">　　　 　 P(mutex);         <span class="comment">//进入临界区     </span></span><br><span class="line">　　　    getodd();  </span><br><span class="line">　　　    countodd():=countodd()+<span class="number">1</span>; </span><br><span class="line">　　　    V(mutex);    </span><br><span class="line">　　　    V(empty);         <span class="comment">//离开临界区，释放互斥信号量   </span></span><br><span class="line">　　　&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">P3()</span><br><span class="line">&#123;</span><br><span class="line">　　　While(<span class="literal">true</span>)</span><br><span class="line">　　　&#123;</span><br><span class="line">　　　 　 P(s2)        <span class="comment">//收到P1发送来的信号，已产生偶数   </span></span><br><span class="line">　　　   P(mutex);         <span class="comment">//进入临界区  </span></span><br><span class="line">　　　   geteven();  </span><br><span class="line">　　　   counteven():=counteven()+<span class="number">1</span>;  </span><br><span class="line">　　　   V(mutex);    </span><br><span class="line">　　　   V(empty);         <span class="comment">//离开临界区，释放互斥信号量   </span></span><br><span class="line">　　　&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>8.在天津大学与南开大学之间有一条弯曲的小路，这条路上每次每个方向上只允许一辆自<br>行车通过。但其中有一个小的安全岛 M，同时允许两辆自行车停留，可供两辆自行车已<br>从两端进入小路的情况下错车使用。如图所示。<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/pv.png" alt><br>下面的算法可以使来往的自行车均可顺利通过。其中使用了 4 个信号量， T 代表天大路<br>口资源， S 代表南开路口资源， L 代表从天大到安全岛一段路的资源， K 代表从南开到<br>安全岛一段路的资源。程序如下，请在空白位置处填写适当的 PV 操作语句，每处空白<br>可能包含若干个 PV 操作语句。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">    t:=<span class="number">1</span>;s:=<span class="number">1</span>;l:=<span class="number">1</span>;k:=<span class="number">1</span>;</span><br><span class="line">    cobegin</span><br><span class="line">    从天大到南开的进程</span><br><span class="line">        begin</span><br><span class="line">            ______(<span class="number">1</span>)______</span><br><span class="line">           通过 L 路段;</span><br><span class="line">           进入安全岛 M；</span><br><span class="line">           ______(<span class="number">2</span>)______</span><br><span class="line">           通过 K 路段</span><br><span class="line">           ______(<span class="number">3</span>)______</span><br><span class="line">        end</span><br><span class="line">   从南开到天大的进程</span><br><span class="line">       begin</span><br><span class="line">          略，与“从天大到南开的进程”相反。</span><br><span class="line">       end</span><br><span class="line">    coend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>9.有桥如下图所示，车流如箭头所示，桥上不允许两车交汇，但允许同方向多辆车依次<br>通过（即桥上可以有多个同方向的车）。用P、V操作实现交通管理以防止桥上堵塞。<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/pv2.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这题和读者写者问题类似</span></span><br><span class="line">semaphore fmutex=<span class="number">1</span>, normutex=<span class="number">1</span>, sormutex=<span class="number">1</span>,<span class="built_in">queue</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sou_count = <span class="number">0</span>, nor_count = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tonorth</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">while</span>( TRUE )&#123; </span><br><span class="line">P(<span class="built_in">queue</span>)</span><br><span class="line">P(normutex); </span><br><span class="line"><span class="keyword">if</span>( nor_count == <span class="number">0</span> ) &#123; P(fmutex); &#125; </span><br><span class="line">nor_count = nor_count + <span class="number">1</span>; </span><br><span class="line">V(normutex); </span><br><span class="line">V(<span class="built_in">queue</span>); </span><br><span class="line"><span class="comment">//过去了 ... </span></span><br><span class="line">P(normutex); </span><br><span class="line">nor_count = nor_count - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span>( nor_count == <span class="number">0</span> ) &#123; V(fmutex); &#125; </span><br><span class="line">V(normutex); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tosouth</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">while</span>( TRUE )&#123; </span><br><span class="line">P(<span class="built_in">queue</span>); </span><br><span class="line">P(sormutex);</span><br><span class="line"><span class="keyword">if</span>(sor_count==<span class="number">0</span>) &#123;P(fmutex);&#125;</span><br><span class="line">sor_count = sor_count++;</span><br><span class="line">V(sormutex);</span><br><span class="line">V(<span class="built_in">queue</span>);</span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">P(sormutex)</span><br><span class="line">sor_count = sor_count + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(sorcount==<span class="number">0</span>)&#123;V(fmutexl)&#125;</span><br><span class="line">V(sormutex); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>10.用 P、V 操作和信号量实现下图中的前趋关系。其中 S1~S5 是 5 个具有同步关系的<br>进程。<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/pv1.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore s1 =<span class="number">0</span>,s2=<span class="number">0</span>,s3=<span class="number">0</span>,s4=<span class="number">0</span>,s5=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//s1....</span></span><br><span class="line">    V(s1);</span><br><span class="line">    V(s1);</span><br><span class="line">    V(s1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(s1);</span><br><span class="line">    <span class="comment">//s2...</span></span><br><span class="line">    V(s2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(s1);</span><br><span class="line">    <span class="comment">//s3...</span></span><br><span class="line">    V(s3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(s2);</span><br><span class="line">    <span class="comment">//s4....</span></span><br><span class="line">    V(s4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(s1);</span><br><span class="line">    P(s3);</span><br><span class="line">    P(s4);</span><br><span class="line">    <span class="comment">//s5...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="11">
<li>2010 世博会在上海成功举行，很多场馆都给人留下了深刻的印象。中国馆有很多<br>观众参观。为保持场内卫生，需要不定期的清馆打扫卫生。为保证秩序，相关部门做出了以下的管理规定：<br>1) 同时进入场馆的人数上限为 N；如果场内观众人数达到上限，新观众在场外排队等候。<br>2) 为保证打扫卫生工作的正常开始，保洁人员首先会暂停新观众进场，新观众在场外排队等候；<br>3) 如果场内无观众，则打扫卫生立即开始，如还有剩余观众，则待场内观众全部离开后，即开始打扫卫生；<br>4) 完成后重新开放。</li>
</ol>
<p>为实现上述控制，请用 PV 原语和信号量，分别描述观众和保洁人员的行为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>(人数加减的锁),r=N,w=<span class="number">1</span>,s=<span class="number">1</span>; (w是保持场馆状态)</span><br><span class="line"><span class="keyword">int</span> rc=<span class="number">0</span>;</span><br><span class="line">reader()</span><br><span class="line">&#123;</span><br><span class="line">P(s);<span class="comment">//给别人(特别是writer)看</span></span><br><span class="line">P(mutex);</span><br><span class="line">rc++;</span><br><span class="line"><span class="keyword">if</span> (rc==<span class="number">1</span>) P(w);</span><br><span class="line">P(r);</span><br><span class="line">V(mutex);</span><br><span class="line">V(s);</span><br><span class="line">读文件;</span><br><span class="line">P(mutex);</span><br><span class="line">rc--;</span><br><span class="line"><span class="keyword">if</span> (rc==<span class="number">0</span>) V(w);</span><br><span class="line">V(r);</span><br><span class="line">V(mutex);</span><br><span class="line">&#125;</span><br><span class="line">writer()<span class="comment">//w给别人看</span></span><br><span class="line">&#123;</span><br><span class="line">P(s);</span><br><span class="line">P(w);</span><br><span class="line">写文件;</span><br><span class="line">V(w);</span><br><span class="line">V(s);</span><br><span class="line">&#125;</span><br><span class="line">只有reader 会拿着 w</span><br><span class="line">只有写者 会拿着 s</span><br><span class="line">s 保证了门口只能站着一个人在等着进去</span><br></pre></td></tr></table></figure>
<ol start="12">
<li>某火车订票系统，可共多个用户同时共享一个订票数据库。规定允许多个用户同时查询该数据库，有查询者时，用户不能订票；有用户订票而需要更新数据库时，不可以有其他用户使用数据库。当有用户申请订票时，后续的查询者的请求会被暂时挂起直到订票操作完成。请在下面程序的空格处填入 P、 V 操作写出查询者和订票者的同步执行程序，一个空格处可能会有一条或多条 P、V 操作<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">答：程序中没有出现对信号量直接读写的语句，且 P、V 操作中没有出现非信号</span><br><span class="line">量作为参数。（<span class="number">1</span> 分）（程序中的给分项必须 P、V 操作成对完整且位置正确方可</span><br><span class="line">得分，分值标在相应的 P 操作上）</span><br><span class="line">semaphore mutex=<span class="number">1</span>（<span class="number">1</span> 分）,db=<span class="number">1</span>（<span class="number">1</span> 分）,w=<span class="number">1</span>（<span class="number">1</span> 分）; <span class="comment">//此处为信号量初始</span></span><br><span class="line">化</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>; <span class="comment">//共享变量，查询用户的个数</span></span><br><span class="line">query() <span class="comment">//查询过程</span></span><br><span class="line">&#123;</span><br><span class="line">P(mutex) （<span class="number">1</span> 分）;P(w) （<span class="number">1</span> 分）;</span><br><span class="line">count=count+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (count==<span class="number">1</span>) &#123; <span class="comment">//是第一个查询者</span></span><br><span class="line">P(db) （<span class="number">1</span> 分）; &#125;</span><br><span class="line">V(w);V(mutex);</span><br><span class="line">查询余票; P(mutex) （<span class="number">1</span> 分）;</span><br><span class="line">count=count<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (count==<span class="number">0</span>)&#123; <span class="comment">//是最后一个查询者</span></span><br><span class="line">V(db);</span><br><span class="line">&#125;</span><br><span class="line">V(mutex);</span><br><span class="line">&#125;</span><br><span class="line">book() <span class="comment">//订票过程</span></span><br><span class="line">&#123;</span><br><span class="line">P(w) （<span class="number">1</span> 分）;P(db) （<span class="number">1</span> 分）;</span><br><span class="line">订票;</span><br><span class="line">V(db);V(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>(1)读者优先(考试重点)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore fmutex=<span class="number">1</span> <span class="comment">//fmutex --&gt; access to file; </span></span><br><span class="line">sepaphore rdcntmutex=<span class="number">1</span>; <span class="comment">// rdcntmutex --&gt; access to reader_count </span></span><br><span class="line"><span class="keyword">int</span> reader_count = <span class="number">0</span>; <span class="comment">// reader_count --&gt; the number of readers </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">while</span> ( TRUE )&#123; </span><br><span class="line">P(rdcntmutex); </span><br><span class="line"><span class="keyword">if</span>( reader_count == <span class="number">0</span> ) &#123; P(fmutex); &#125; </span><br><span class="line">reader_count = reader_count + <span class="number">1</span>; </span><br><span class="line">V(rdcntmutex); </span><br><span class="line"><span class="comment">//Do read operation ... </span></span><br><span class="line">P(rdcntmutex); </span><br><span class="line">reader_count = reader_count - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span>( reader_count == <span class="number">0</span>) &#123; V(fmutex); &#125; </span><br><span class="line">V(rdcntmutex); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">while</span> ( TRUE )&#123; </span><br><span class="line">P(fmutex); </span><br><span class="line"><span class="comment">//Do write operation ... </span></span><br><span class="line">V(fmutex); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)写者优先</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore fmutex=<span class="number">1</span>, rdcntmutex=<span class="number">1</span>, wtcntmutex=<span class="number">1</span>, <span class="built_in">queue</span>=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">int</span> reader_count = <span class="number">0</span>, writer_count = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">while</span>( TRUE )&#123; </span><br><span class="line">P(<span class="built_in">queue</span>); </span><br><span class="line">P(rdcntmutex); </span><br><span class="line"><span class="keyword">if</span>( reader_count == <span class="number">0</span> ) &#123; P(fmutex); &#125; </span><br><span class="line">reader_count = reader_count + <span class="number">1</span>; </span><br><span class="line">V(rdcntmutex); </span><br><span class="line">V(<span class="built_in">queue</span>); </span><br><span class="line"><span class="comment">//Do read operation ... </span></span><br><span class="line">P(rdcntmutex); </span><br><span class="line">reader_count = reader_count - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span>( reader_count == <span class="number">0</span> ) &#123; V(fmutex); &#125; </span><br><span class="line">V(rdcntmutex); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">while</span>( TRUE )&#123; </span><br><span class="line">P(wtcntmutex); </span><br><span class="line"><span class="keyword">if</span>( writer_count == <span class="number">0</span> ) &#123; P(<span class="built_in">queue</span>); &#125; </span><br><span class="line">writer_count = writer_count + <span class="number">1</span>; </span><br><span class="line">V(wtcntmutex); </span><br><span class="line">P(fmutex); </span><br><span class="line"><span class="comment">//Do write operation ... </span></span><br><span class="line">V(fmutex); </span><br><span class="line">P(wtcntmutex); </span><br><span class="line">writer_count = writer_count - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span>( writer_count == <span class="number">0</span> ) &#123; V(<span class="built_in">queue</span>); &#125; </span><br><span class="line">V(wtcntmutex); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)公平竞争</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore fmutex=<span class="number">1</span>, rdcntmutex=<span class="number">1</span>, wtcntmutex=<span class="number">1</span>, <span class="built_in">queue</span>=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">int</span> reader_count = <span class="number">0</span>, writer_count = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">while</span>( TRUE )&#123; </span><br><span class="line">P(<span class="built_in">queue</span>); </span><br><span class="line">P(rdcntmutex); </span><br><span class="line"><span class="keyword">if</span>( reader_count == <span class="number">0</span> ) &#123; P(fmutex); &#125; </span><br><span class="line">reader_count = reader_count + <span class="number">1</span>; </span><br><span class="line">V(rdcntmutex); </span><br><span class="line">V(<span class="built_in">queue</span>); </span><br><span class="line"><span class="comment">//Do read operation ... </span></span><br><span class="line">P(rdcntmutex); </span><br><span class="line">reader_count = reader_count - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span>( reader_count == <span class="number">0</span> ) &#123; V(fmutex); &#125; </span><br><span class="line">V(rdcntmutex); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">while</span>( TRUE )&#123; </span><br><span class="line">P(<span class="built_in">queue</span>); </span><br><span class="line">P(fmutex); </span><br><span class="line">V(<span class="built_in">queue</span>); </span><br><span class="line"><span class="comment">//Do write operation ... </span></span><br><span class="line">V(fmutex); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解答题-2"><a href="#解答题-2" class="headerlink" title="解答题"></a>解答题</h4><ol>
<li><p>当操作系统发现死锁已经发生时，通常采用哪些方法来解决这个问题？哪种方法的代价相对比较小？</p>
<blockquote>
<p>答：可以重启操作系统、或结束死锁状态的一个或多个进程。回答剥夺死锁进程的部分资源也可以给分。<br>选择结束死锁状态中最年轻的进程的生命，代价较小，因为重新运行到这个状态相对比较容易。 </p>
</blockquote>
</li>
<li><p>请讨论一下使用 TSL 语句实现加锁的方法和原理。如果在不支持 TSL 的 x86 系列 CPU 上，如何使<br>用 XCHG 语句来代替 TSL 语句实现同样的功能？</p>
<blockquote>
<p>答：设置一个变量 LOCK，约定其值为 0 代表资源空闲，为 1 代表资源占用。(1 分)<br>进入临界区前执行下面的判断<br>(1) TSL 指令将变量 LOCK 的值存入寄存器 REGISTER 中，并将 LOCK 的值设置为 1。由于这是在一条指<br>令中完成，这两件事是原子性的，即“同时、不可被打断”。<br>(2) 判断寄存器 REGISTER 的值是 1 吗？是，重新执行第（1）步。<br>离开临界区前，将变量 LOCK 的值设为 0。（2 分）<br>如果使用 XCHG 替代 TSL 语句，可以改为：<br>进入临界区前执行下面的判断<br>(1) 将寄存器 REGISTER 的值设置为 1。<br>(3) 使用 XCHG 交换变量 LOCK 的值和寄存器 REGISTER 的值。由于这是在一条指令中完成，这个交换<br>是原子性的，即“同时、不可被打断”。<br>(4) 判断寄存器 REGISTER 的值是 1 吗？是，重新执行第（1）步。<br>离开临界区前，将变量 LOCK 的值设为 0。（2 分）</p>
</blockquote>
</li>
</ol>
<p>代码:?</p>
<ol start="3">
<li><p>根据你了解的 Linux 对于进程的管理机制，回答下面的问题：<br>（1）Linux 中各个进程是彼此平等的，还是存在父子族亲关系？<br>（2）内核创建的第一个进程叫什么名字？<br>（3）如果一个进程即将结束，而它尚有活动的子进程，该进程会正常结束，从而形成孤儿进程吗？<br>（4）使用什么命令，可以起动一个进程，在其父 shell 退出后，可以继续在后台运行？</p>
<blockquote>
<p>答：(1) 存在父子族亲关系（1 分）<br>(2) 第一个进程叫 init（1 分）<br>(3) 不会形成孤儿进程。（1 分）一般情况下有两种处理方法，一是先将它的子进程杀死后再结束自己，另一种是将子进程的父进程变更为 init 后再结束自己。（1 分）<br>(4) 使用 nohup 语句（1 分）</p>
</blockquote>
</li>
<li><p>操作系统通过系统调用向用户程序提供服务,讨论一下问题<br>1)以fork()为例,说明用户程序如何调用系统调用.<br>2)以xv6系统为例,说明设计并实现一个系统调用需要哪些步骤.</p>
<blockquote>
<p>答:1)用户调用fork(),如果进程分裂成功,当前进程为父进程,fork()的返回值为子进程的PID,子进程中fork()的返回值为0.如果分裂失败,返回值为-1.<br>2)要点,需要修改一下文件:</p>
</blockquote>
</li>
</ol>
<ul>
<li>syscall.h 增加系统调用编号</li>
<li>syscall.c 增加系统调用声明</li>
<li>sysproc.c 实现系统调用</li>
<li>user.h 增加系统调用的声明</li>
<li>usys.S 增加系统调用相关的宏</li>
</ul>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><h5 id="选择题-2"><a href="#选择题-2" class="headerlink" title="选择题"></a>选择题</h5><ol>
<li><p>下列措施中，能加快虚实地址转换的是：C<br>I. 增大快表（TLB）    II. 让页表常驻内存    III. 增加交换区<br>A.  仅 I    B. 仅 II    C. 仅 I,II    D. 仅 II,III</p>
</li>
<li><p>下列选项中，属于多级页表优点的是：D<br>A.加快地址变换速度            B.减少缺页中断次数<br>C. 减少一个页表项所占字节数     D.减少页表所占的内存空间</p>
</li>
<li><p>若用户进程访问内存时产生缺页，则下列选项中，操作系统可能执行的操作是 B<br>I.处理越界错    II.置换页    III.分配内存<br>A.仅I、II    B.仅II、III    C. 仅I、III    D. I、II和III</p>
<blockquote>
<p>增大TLB，是为了避免去内存中匹配页表。TLB本身就在***里，而且能并行计算。把页表都放在内存里，也是可以的，但一般页表很大，可以经过多级页表和反置页表处理后再放在内存里。交换区是内存不够用时的解决手段，增大交换区能腾出更多地方。</p>
</blockquote>
</li>
<li><p>在⼀个请求分页系统中，采⽤ LRU 页⾯转换算法时，加⼊⼀个作业的页⾯⾛向为：<br>1，3，2，1，1，3，5，1，3，2，1，5.当分配给该作业的物理块数分别为 3 和 4 时，在访问过程中所发⽣的缺页率为  C<br>A. 25%，33%    B. 50%，25%    C.50%,33%    D. 50%，75%</p>
<blockquote>
<p>M=3<br>1 3 2<br>请求5 缺页 1 3 5<br>请求2 缺页 1 3 2<br>请求5 缺页 1 5 2<br>6/12 = 25%<br>M=4<br>1 3 2 5<br>4 / 12 = 33%</p>
</blockquote>
</li>
<li><p>某作业的逻辑地址空间为4页，页⾯⼤⼩为2048，已知页表如下所⽰，则逻辑地址<br>4865（⼗进制）对应的物理地址为（<strong>C</strong>）。<br>页号    0    1    2    3<br>块号    2    4    6    8<br>A、4865    B、8961    C、13057    D、6865</p>
<blockquote>
<p>4865 = 1301H = ‭0001001100000001‬<br>2对应6<br>11001100000001‬ = 13057<br>ok</p>
</blockquote>
</li>
<li><p>若⽤户进程访问内存时产⽣缺页，则下列选项中，操作系统可能执⾏的操作是 B<br>I.处理越界错    II.置换页    III.分配内存<br>A.仅I、II    B.仅II、III    C.  仅I、III    D. I、II和III</p>
<blockquote>
<p>用户进程访问内存时缺页会发生缺页中断。发生缺页中断，系统会执行的操作可能是置换页面或分配内存。系统内没有越界的错误，不会进行越界出错处理</p>
</blockquote>
</li>
<li><p>考虑页⾯置换算法，系统有 m 个物理块供调度，初始时全空，页⾯引⽤串长度为p，包含了 n 个不同的页号，⽆论⽤什么算法，缺页次数不会少于（<strong>C</strong>）<br>A、m<br>B.p<br>C. n<br>D. min(m,n)</p>
<blockquote>
<p>无论采用什么置换算法,每种页面第一次访问时不可能在内存中.必然发生缺页.</p>
</blockquote>
</li>
<li><p>把进程地址空间中使⽤的逻辑地址变成内存中物理地址的过程称为：<strong>A</strong><br>A、重定位    B、物理化    C、逻辑化    D、加载</p>
<blockquote>
<p>由程序中逻辑地址组成的地址范围叫做逻辑地址空间，或简称为地址空间。而由内存中的一系列存储单元所限定的地址范围称为内存空间，也称为物理空间或者绝对空间。<br>程序和数据装入内存时需对目标程序中的地址进行修改。这种把逻辑地址转变为内存的物理地址的过程叫重定位。<br>对程序进行重定位的技术按重定位的时机可分为两种：静态重定位和动态重定位。</p>
</blockquote>
</li>
</ol>
<h5 id="计算题-2"><a href="#计算题-2" class="headerlink" title="计算题"></a>计算题</h5><ol>
<li>某操作系统的内存管理器采用请求式分页，页面大小为 4KB，某计算机主存按字节编址，逻辑地<br>址和物理地址都是 32 位，页表项大小为 4 字节。若使用二级页表的分页存储管理方式，逻辑地<br>址结构为</li>
</ol>
<table>
<thead>
<tr>
<th align="center">页目录号(10位)</th>
<th align="center">页表索引(10位)</th>
<th align="center">页内偏移量(12位)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TLB（快表）采用全相联映射，有 4 个页表项，内容如下表所示。</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">有效位</td>
<td align="center">页号</td>
<td align="center">页框号</td>
</tr>
<tr>
<td align="center">:-</td>
<td align="center">:-</td>
<td align="center">:-</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">FF180H</td>
<td align="center">——</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3FFF1H</td>
<td align="center">0F035H</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">FFFC6H</td>
<td align="center">3054CH</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">03FFFH</td>
<td align="center">0C153H</td>
</tr>
<tr>
<td align="center">(1) 该系统的页表项中,最多可以保存多少位标志位.</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">(2) 若该进程共用到了3072个页,则此时此二级页表占用的总空间最小为多少.</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">(3) 对逻辑地址3FFF1880H转换为物理地址的结果是什么.</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>解：(1) 页面大小为 4KB =&gt; 页内偏移量 12 位<br>物理地址 32 位 =&gt; 页框号 20 位<br>页表项大小为 4 字节（即，32 位）=&gt; 标志位最多 = 页表项长度 32 – 页框号 20 = 12 位（2 分）<br>(2) 一个页表索引 10 位 =&gt; 一个小页表有 2^10=1024 个页表项<br>逻辑地址空间 3072 个页 =&gt; 需要 3072/1024=3 个小页表，加上一个页目录表，共 4 个页表 =&gt; 页<br>表最小 4*4KB=16KB（2 分）<br>(3) 页内偏移量 12 位 =&gt; 逻辑地址 3FFF1880H 的页号是 3FFF1H，查快表可知，对应页框号为<br>0F035H =&gt; 物理地址是 0F035880H（2 分）</p>
</blockquote>
<ol start="2">
<li>某操作系统的内存管理器采⽤请求式分页，页⾯⼤⼩为 4KB，逻辑地址空间为 32 位， 物理地址空间为 36 位，⼀个页表项⼤⼩为 4B。⼀次快表（TLB）的访问时间是 10ns，⼀次内存的访问时间是 100ns，处理⼀次缺页的平均时间 10^8 ns（已含更新 TLB 和页表的时间）。进程的驻留集⼤⼩固定为 2,采⽤最近未使⽤置换算法(NRU)和局部淘汰策略。假设（1） TLB 初始为空;（2）地址转换时先访问 TLB,若 TLB 未命中,再访问页表(忽略访问页表之后的 TLB  更新时间);（3）有效位为  0  表⽰页⾯不在内存,产⽣缺页中断,缺页中断处理后,返回到产⽣缺页中断的指令处重新执⾏。进程的部分页表如下所⽰：</li>
</ol>
<table>
<thead>
<tr>
<th align="left">页号</th>
<th align="left">页框(Page Frame)号</th>
<th align="left">P存在位</th>
<th align="left">R访问位</th>
<th align="left">M修改位</th>
</tr>
</thead>
<tbody><tr>
<td align="left">00000H</td>
<td align="left">——</td>
<td align="left">0</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">00001H</td>
<td align="left">007F61H</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">00002H</td>
<td align="left">101254H</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">00003H</td>
<td align="left">——</td>
<td align="left">0</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
</tbody></table>
<p>(1)该系统的页表项中，最多可以保存 <strong>B</strong>位标志位。<br>A．4    B．8    C．12    D．16</p>
<blockquote>
<p>页表项32位, (36-12)算出页框号<br>所以32 - (36- 12) = 8<br>41、若采⽤多级页表，要求每级页表均可以装⼊⼀个页⾯内，则应该采⽤  <strong>C</strong>级页表较合适。<br>A．0    B．1    C．2    D．3<br>ok</p>
</blockquote>
<p>(2)如果不考虑缺页的情况，对于已经载⼊内存的页⾯，快表命中率为90%，则访问内存中数据的平均有效访问时间是  <strong>A</strong>。<br>A．20ns    B．110ns    C．120ns    D．320ns</p>
<blockquote>
<p>10<em>0.9+110</em>0.1=20ns +不+100呢?</p>
</blockquote>
<p>(3)⾸先，访问逻辑地址00001618H，则读⼊所需数据需要的总时间是 <strong>D</strong>。<br>A．约 10^8ns    B．110ns    C．200ns    D．210ns</p>
<blockquote>
<p>内存是P位<br>10 + 100 +100</p>
</blockquote>
<p>(4)然后，访问逻辑地址00000FA6H，则读⼊所需数据需要的总时间是 <strong>A</strong>    。<br>A．约 10^8ns    B．110ns    C．200ns    D．210ns</p>
<blockquote>
<p>缺页中断了.</p>
</blockquote>
<p>(5)最后，访问逻辑地址0000126CH，则读⼊所需数据需要的总时间是 <strong>B</strong>    。<br>A．约 10^8ns    B．110ns    C．200ns    D．210ns</p>
<blockquote>
<p>页表1 在快表中了</p>
</blockquote>
<p>(6)在依次访问完上述三个逻辑地址后，页框101254H对应的页号为 <strong>A</strong>。<br>A．00000H    B．00001H    C．00002H    D．00003H</p>
<blockquote>
<p>(这题我也没太理解)是不是访问00000FA6H时候缺页中断 置换了页表2</p>
</blockquote>
<ol start="3">
<li><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%861.png" alt></p>
<blockquote>
<p>答案:(1) 4KB (2) 4MB (3) (LA&gt;&gt;22)&amp;0x000003FF (4) (LA&gt;&gt;12)&amp;0x000003FF (5)  4×4K<br>(6) 00200020H (7) 00200040H (8) 00900H (9) 00901H (10)00901000H</p>
</blockquote>
</li>
<li><p>已知某系统页⾯长 4KB，页表项 4B，虚拟地址空间为 64 位。<br>（1）如采⽤多层分页策略，限定各分层页表最多占 1 页⼤⼩，请问可以采⽤⼏层分页<br>策略？<br>（2）如采⽤倒排页表⽅式，请问倒排页表的⼤⼩？是每个进程⼀张倒排页表还是系统<br>维护⼀张倒排页表？如何解决倒排页表不便于逻辑地址向物理地址转换的问题？</p>
<blockquote>
<p>(1)页面长 4KB，说明页内偏移地址占 12 位，虚拟地址空间 64 位，说明页号总长<br>为 64-12=52 位。页面长 4KB，页表项 4B，故每张页表不超过<br>4K/4=1K=2^10    项，即每级 页表地址长度不应该超过 10 位。页号总长 52 位/<br>每页表最长 10 位=5.2，向上取整为 6。 即采用六层分页策略。<br>(2)如采用倒排页表，因为物理地址空间 4GB，故倒排页表应该有 4GB/4KB=1M个页 表项，每页表项大小为 4B，倒排页表大小为 1M*4B=4MB。系统维护一张倒排页表。可以使用 Hash 散列，解决倒排页表不便于逻辑地址向物理地址转换的问题。</p>
</blockquote>
</li>
</ol>
<h5 id="解答题-3"><a href="#解答题-3" class="headerlink" title="解答题"></a>解答题</h5><ol>
<li>缺页中断产生后，被中断的进程应该转入什么运行状态？讨论一下缺页中断的执行过程，并说明<br>中断处理完毕后返回被中断的进程时应该执行哪条语句。<blockquote>
<p>（1）转入阻塞态（或者说 blocked 态、睡眠态、sleep 态都可以）(1 分)<br>（2）保护现场、陷入内核态、如果内存空间不足则选择页面淘汰(1 分)；调需要的页面进内存、更新页表和快表(1 分)；返回用户态，恢复现场、重新执行 被中断的语句(1 分)。<br>（3）执行被中断的语句(1 分)</p>
</blockquote>
</li>
<li>某系统的页面淘汰算法采用老化(Aging)算法，每个页面分配一个 8 位二进制数的计数器。某进程共有 6 个页面，在时刻 0 之前所有页面均未被引用过。下表是前 5 个 clock tick 中各页面的被引用情况，被引用者标 1，未被引用者标 0。</li>
</ol>
<table>
<thead>
<tr>
<th align="center">Clock tick</th>
<th align="center">Page 0</th>
<th align="center">Page 1</th>
<th align="center">Page 2</th>
<th align="center">Page 3</th>
<th align="center">Page 4</th>
<th align="center">Page 5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1） 在 clock tick 4 过后，需要淘汰一个页面，应选择哪个页面进行淘汰？为什么？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2） 为什么说老化(Aging)算法是一种简单有效的算法，但只是 LRU 的一个近似实现？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>1)应淘汰 Page 3，因为其访问计数器为 00100，为最小值<br>2)老化算法只有有限位的存储，记录最近若干次页面使用情况，更早的使用情况会丢失。另外，老<br>化算法没有记录在一个时间周期内页面的使用频度和时间等，所以与 LRU 相比只是一个近似实现。</p>
</blockquote>
<ol start="3">
<li><p>在虚拟存储管理中，分段式内存管理⽅式解决了分页式内存管理中的什么问题，又带来了什么问题呢？</p>
<blockquote>
<p>解决了分页式机械化的分页(功能可能不同)导致颠簸现象?<br>分段式由内在逻辑来分, 不过段大 类似于动态分区会产生外碎片 导致内存利用率低<br>标答:分段式内存管理解决了分页式内存管理中划分页时仅根据大小划分，这样<br>可能将无关的 内容分到一页中，此页不便设置权限与保护，也不利于共享。<br>也有可能把密切相关的内容分 到不同页中，当页面置换算法设置不当时，内<br>存紧张时容易形成“抖动”现象。 分段式内存管理带来的问题是段往往过大，多<br>次分配释放后可能形成大量“外碎片”，利 用内存效率不高。</p>
</blockquote>
</li>
<li><p>LRU页⾯置换算法是⼀种⽐较优秀的算法但是较难实现，为什么？试给出⼀种可⾏<br>的近似算法作为LRU的取代⽅案。</p>
<blockquote>
<p>LRU需求记录所有页面长期运行中被使用的时间和次数，需要大量的快速存<br>储空间，而且比较 pthreadkill()：向线程发送一个信号 算法非常复杂，不容易<br>实现。 <code>z</code>同步函数，用于 mutex    和条件变量替代方案可以采用老化（aging）<br>算法，每个页面有一个长度有限的记数器，记录每个 tick    内pthreadmutexinit()    初始化互斥锁 面使用情况，记录信息的权重逐次递减。这种算法与 LRU    相比，不能记录每个 tick    中内存使用情况，pthreadmutex_destroy()    删除互斥锁 而且记录的位数有限，但是实现方案较易<br>实现。</p>
</blockquote>
</li>
<li><p>单纯的分段式和分页式内存管理各有什么缺点？为什么段页式可以避免这些缺点？<br>为什么段页式内存管理没有被⼴泛采⽤呢？</p>
<blockquote>
<p>分页式：逻辑地址空间划分只简单依靠页面大小，缺乏内在逻辑性，导致一方<br>面相关内容被分散 到多页上，页面置换不当时容易造成内存抖动，另一方面<br>不同性质的内容被分到同一页中，使得页面 权限保护设置困难。 分段式：段<br>体积大，在内存中无法不连续存储，易形成内存外碎片，降低内存利用率。<br>段页式：先分段再分页，以段为单位调入调出，以页为单位在内存中不连续存<br>储，既保证了相关内容 同时进出内存，便于设置权限保护，又可以充分利用<br>内存空间。 段页式结构复杂，实现起来效率低，所以没有被广泛采用。</p>
</blockquote>
</li>
<li><p>为什么内存管理⽅式中，可变分区管理中有最差适应（worst fit)分配算法，⽽固定<br>分区管理中没有这个算法？分区管理中的交换技术（swap）和段式管理中的请求式<br>分段技术有什么区别？请求式分段与覆盖技术（overlay）又有什么区别？</p>
<blockquote>
<p>最差适应分配最大空间的分区给进程使用,以期剩余外碎片空间较大,再次利用的可能性较大.固定分区无外碎片,故不应采用这种算法.<br>交换技术交换单位是进程,请求式分段技术交换的单位是段<br>请求式分段式操作系统进行段调入调出,对程序员透明,而覆盖技术需要程序员自己完成调入调出.</p>
</blockquote>
</li>
<li><p>页⾯置换（淘汰）的时机是什么？哪种算法最理想同时也不可能实现？为什么说<br>LRU算法很有效但是很难实现？什么是Belady异常？哪种算法存在Belady异常现<br>象?</p>
<blockquote>
<p>页面置换应该在内存空余空间小于一个固定的下限阈值时开始，并在达到<br>另一个上限阈值时停止。 OPT 最理想但不可能实现。 LRU 要求比较最近最少<br>使用的页面，条件多，要存储的数据量大，比较的时间长，很难实现。<br>Belady 异常指的时当增加页框时缺页中断发生的数量反而升高的现象。 FIFO<br>存在 Belady 异常</p>
</blockquote>
</li>
<li><p>请讨论⼀下页⾯置换算法中⼯作集（Working Set）置换算法的⼯作原理。</p>
<blockquote>
<p>答：进程设置一个虚拟时钟，执行一个时钟周期就加 1，不执行就不增加。<br>（1    分）每个页面被访问时，记录最后访问的虚拟时间，R    位置 1。R    位定期<br>清除。（1 分）如果 R=1,则保留，将当前时间记录下来。（1    分）如果 R=0    对<br>比当前虚拟时间与页面最后访问时间差 age    与阈值 τ，如 age&gt;τ 则淘汰（1<br>分）。如 age    &lt;=    τ，则记录其访问时间，必要时淘汰其中最旧的。（1    分）</p>
</blockquote>
</li>
<li><p>在内存管理的⽅法中，分段式管理⽐分页式管理有什么优势？段页式与其他⽅式相<br>⽐有什么好处？</p>
<blockquote>
<p>分段比分页更有逻辑性，将同类的或相关的内容放在一个段内，这样不会<br>由于页面置换算法选择不当而形成“抖动”现象。（1    分）同类内容划分在一个<br>段内，可以实现段的保护，如代码段设置为只读，数据段设置为读写。（1     分）<br>公共代码段可以通过映射共享到多个进程。（1    分）段页式既按照相关性划分<br>段，继承了分段的优势（1    分），又有分页管理可以不连续存储，能够充分利<br>用空间的好处。（1    分）</p>
</blockquote>
</li>
<li><p>为什么要使⽤倒排页表？倒排页表⾯临的最⼤的问题是什么？如何解决？</p>
<blockquote>
<p>在 64    位系统中，由于虚拟地址太大，普通页表会非常大，无法存储。另一方<br>面，实际内存 相对较小，所以建立一张从物理地址索引得到相对地址的倒排<br>页表。 最大的问题的难于从相对地址查找到绝对地址。可以采用 hash    表ò高<br>查找效率，并使用 TLB加速查找。</p>
</blockquote>
</li>
<li><p>内存分区管理中的交换技术与请求式分段技术相⽐，有什么相同点和不同点？</p>
<blockquote>
<p>答：相同点都是为了在内存不足的情况下装入更多的进程，都是会产生外碎片。<br>不同点为交换 技术交换的对象是整个进程而请求式分段交换的进程中的一个<br>段。</p>
</blockquote>
</li>
<li><p>在页⾯淘汰算法中，为什么说⽼化(Aging)算法只是 LRU 的⼀个近似实现？</p>
<blockquote>
<p>老化算法与 LRU    相比，主要有两点区别：<br>(1）老化算法记录使用情况的<br>寄存器只有有限位， 比如 8位，无法记录所有使用情况。<br>（2）同一时间间隔内只使用 0/1区分页面使用情况，无法详 细区别间隔内的具体时间</p>
</blockquote>
</li>
<li><p>单纯的分段式和分页式内存管理各有什么缺点？为什么段页式可以避免这些缺点？为什么段页式内存管理没有被广泛采用呢？</p>
<blockquote>
<p>答：分页式：逻辑地址空间划分只简单依靠页面大小，缺乏内在逻辑性，导致一方面相关内容被分散到多页上，页面置换不当时容易造成内存抖动，另一方面不同性质的内容被分到同一页中，使得页面权限保护设置困难。<br>分段式：段体积较大，在内存中无法不连续存储，易形成内存外碎片，降低内存利用率。<br>段页式：先分段再分页，以段为单位调入调出，以页为单位在内存中不连续存储，既保证了相关内容同时进出内存，便于设置权限保护，又可以充分利用内存空间。<br>段页式结构复杂，实现起来效率低，所以没有被广泛采用。</p>
</blockquote>
</li>
<li><p>为什么内存管理方式中，可变分区管理中有最差适应（worst fit)分配算法，而固定分区管理中没有这个算法？分区管理中的交换技术（swap）和段式管理中的请求式分段技术有什么区别？请求式分段与覆盖技术（overlay）又有什么区别？</p>
<blockquote>
<p>答：最差适应分配最大空间的分区给进程使用，以期剩余外碎片空间较大，再次利用的可能性较大。<br>固定分区无外碎片，故不应采用这种算法。<br>交换技术交换的单位是进程，请求式分段技术交换的单位是段。<br>请求式分段是操作系统进行段调入调出，对程序员透明，而覆盖技术需要程序员自己完成调入调出。</p>
</blockquote>
</li>
<li><p>页面置换（淘汰）的时机是什么？哪种算法最理想同时也不可能实现？为什么说LRU算法很有效但是很难实现？什么是Belady异常？哪种算法存在Belady异常现象？</p>
<blockquote>
<p>答：页面置换应该在内存空余空间小于一个固定的下限阈值时开始，并在达到另一个上限阈值时停止。<br>OPT最理想但不可能实现。<br>LRU要求比较最近最少使用的页面，条件多，要存储的数据量大，比较的时间长，很难实现。<br>Belady异常指的时当增加页框时缺页中断发生的数量反而升高的现象。<br>FIFO存在Belady异常。</p>
</blockquote>
</li>
<li><p>请问缓存（Cache）有什么用，什么地方会用到它？</p>
<blockquote>
<p>答：缓存主要用于解决 CPU 和内存之间存在的速度差。一般来说，CPU 中寄存器的速<br>度要远快于内存，将 CPU 要用到的数据预先从内存中读到缓存，这样 CPU 使用时就可<br>以快速得到数据，写回内存的过程也类似。<br>TLB 就是使用缓存的一个典型例子。</p>
</blockquote>
</li>
<li><p>内存管理中，什么是内存的外碎片？哪些种内存管理方式可能出现外碎片？为什么？为了避免出现大量很小的外碎片，在空间申请时可以考虑采用哪种分配策略？</p>
<blockquote>
<p>答：外碎片指的是内存中的小的空闲区域，虽然存在理论上被分配出去的可能性，但是<br>实际上由于空间很小，很难被利用。<br>可变式分区管理、分段式管理等内存管理方式均可能出现外碎片。<br>为了避免出现大量小的外碎片，可以使用最差适应（Worst Fit）分配策略。</p>
</blockquote>
</li>
<li><p>已知某系统页面长 4KB，页表项 4B，虚拟地址空间为 64 位，物理地址空间 4GB。 （1）如采用多层分页策略，限定各分层页表最多占 1 页大小，请问可以采用几层分页策<br>略？<br>（2）如采用倒排页表方式，请问倒排页表的大小？是每个进程一张倒排页表还是系统维<br>护一张倒排页表？如何解决倒排页表不便于逻辑地址向物理地址转换的问题？</p>
<blockquote>
<p>答：（1）页面长 4KB，说明页内偏移地址占 12 位，虚拟地址空间 64 位，说明页号总长为 64-12=52 位。页面长 4KB，页表项 4B，故每张页表不超过 4K/4=1K=210 项，即每级页表地址长度不应该超过 10 位。页号总长 52 位/每页表最长 10 位=5.2，向上取整为 6。即采用六层分页策略。<br>（2）如采用倒排页表，因为物理地址空间 4GB，故倒排页表应该有 4GB/4KB=1M 个页<br>表项，每页表项大小为 4B，倒排页表大小为 1M*4B=4MB。<br>系统维护一张倒排页表。<br>可以使用 Hash 散列，解决倒排页表不便于逻辑地址向物理地址转换的问题。</p>
</blockquote>
</li>
<li><p>缺页中断产生后，被中断的进程应该转入什么运行状态？讨论一下缺页中断<br>的执行过程，并说明中断处理完毕后返回被中断的进程时应该执行哪条语句。</p>
<blockquote>
<p>答：转入阻塞态（1 分）保护现场、陷入内核态、如果内存空间不足则选择淘汰、调需要的页面进内存（1 分）、更新页表和快表（1 分）、返回用户态，恢复现场、（1 分）重新执行被中断的语句。(1分)</p>
</blockquote>
</li>
<li><p>请讨论一下页面置换算法中工作集（Working Set）置换算法的工作原理。</p>
<blockquote>
<p>答：进程设置一个虚拟时钟，执行一个时钟周期就加 1，不执行就不增加。<br>（1 分）<br>每个页面被访问时，记录最后访问的虚拟时间，R 位置 1。R 位定期清除。（1<br>分）<br>如果 R=1,则保留，将当前时间记录下来。（1 分）<br>如果 R=0 对比当前虚拟时间与页面最后访问时间差 age 与阈值τ，如 age&gt;<br>τ则淘汰（1 分）。如 age &lt;= τ，则记录其访问时间，必要时淘汰其中最旧的。 （1 分）</p>
</blockquote>
<h4 id="设备管理和其他"><a href="#设备管理和其他" class="headerlink" title="设备管理和其他"></a>设备管理和其他</h4></li>
<li><p>用户程序发出磁盘I/O请求后，计算数据所在磁盘的柱面号、磁头号、扇区号的程序是 C<br>A.用户程序 B.系统调用处理程序 C.设备驱动程序 D.中断处理程序</p>
</li>
<li><p>在系统内存中设置磁盘缓冲区的主要目的是(A)<br>A．减少磁盘 I/O 次数 B．减少平均寻道时间 C．ᨀ高磁盘数据可靠性 D．实现设备无关性</p>
</li>
<li><p>在一个文件被用户进程首次打开的过程中，操作系统需做的是：B<br>A. 将文件内容读到内存中    B. 将文件控制块读到内存中<br>C. 修改文件控制块中的读写权限    D. 将文件的数据缓冲区首指针返回给用户进程</p>
</li>
<li><p>下列选项中，不可能在用户态发生的事件是 C<br>A. 系统调用    B. 外部中断    C. 进程切换    D. 缺页</p>
</li>
<li><p>操作系统的I/O子系统通常由四个层次组成，每一层明确定义了与邻近层次的接口，其合理层次组织排列顺序是 A<br>A.用户级 I/O 软件、设备无关软件、设备驱动程序、中断处理程序<br>B.用户级 I/O 软件、设备无关软件、中断处理程序、设备驱动程序<br>C.用户级 I/O 软件、设备驱动程序、设备无关软件、中断处理程序<br>D.用户级 I/O 软件、中断处理程序、设备无关软件、设备驱动程序</p>
</li>
<li><p>下列关于虚拟存储器的叙述中，正确的是 B<br>A. 虚拟存储器只能基于连续分配技术    B. 虚拟存储器只能基于非连续分配技术<br>C. 虚拟存储器只受外存容量的限制    D. 虚拟存储器只受内存容量的限制</p>
</li>
<li><p>计算机开机后，操作系统最终被加载到 D<br>A. BIOS    B. ROM(只读存储器)    C. EPROM    D. RAM(内存)</p>
</li>
<li><p><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/os%E4%B9%A0%E9%A2%98/os9.png" alt="os9.png"><br>B</p>
</li>
<li><p>若一个用户过程通过read系统调用读取一个磁盘文件中的数据，则下列关于此过程的叙述中，正确的是A<br>Ⅰ. 若该文件的数据不在内存，则该进程进入睡眠等待状态<br>Ⅱ. 请求 read 系统调用会导致 CPU 从用户态切换到核心态<br>Ⅲ. read 系统调用的参数应包含文件的名称<br>A. 仅Ⅰ、Ⅱ B. 仅Ⅰ、Ⅲ C. 仅Ⅱ、Ⅲ D. Ⅰ、Ⅱ和Ⅲ</p>
</li>
<li><p>在采用 SPOOLing 技术的系统中，用户的打印数据首先被送到<strong>A_</strong>。<br>A. 磁盘固定区域 B. 内存固定区域 C. 终端 D. 打印机</p>
</li>
<li><p>操作系统的I/O子系统通常由四个层次组成，每一层明确定义了与邻近层次的接口，其合理的层次组织排列顺序是: A<br>A. 用户级 I/O 软件、设备无关软件、设备驱动程序、中断处理程序<br>B. 用户级 I/O 软件、设备无关软件、中断处理程序、设备驱动程序<br>C. 用户级 I/O 软件、设备驱动程序、设备无关软件、中断处理程序<br>D. 用户级 I/O 软件、中断处理程序、设备无关软件、设备驱动程序</p>
</li>
<li><p>下列选项中，不可能在用户态发生的事件是 C<br>A. 系统调用 B. 外部中断 C. 进程切换 D. 缺页</p>
</li>
<li><p>中断处理和子程序调用都需要压栈以保护现场，中断处理一定会保存而子程序调用不需要保存的是 A<br>A. 程序计数器 B. 程序状态字寄存器<br>C. 通用数据寄存器 D. 通用地址寄存器</p>
</li>
<li><p>在分时系统中，进程调度的时间片的大小宜选择为（C）<br>A、几十纳秒 B、几十微秒 C、几十毫秒 D、几十秒</p>
</li>
<li><p>若当前进程因时间片用完而让出处理机时，该进程应转变为（A）状态。<br>A、就绪 B、等待 C、运行 D、完成</p>
</li>
<li><p>能否使用管程，主要取决于（ B）：<br>A、程序员的编程技巧 B、编程语言的编译器支持<br>C、操作系统是否支持线程 D、是否有相应硬件的支持</p>
</li>
<li><p>下列选项中,导致创建新进程的操作是<strong><em>C</em></strong>。<br>I 用户登录成功 II 设备分配 III 启动程序执行<br>A.仅 I 和 II B.仅 II 和 III C.仅 I 和 III D.I 、II 和 III</p>
</li>
<li><p>下列文件物理结构中,适合随机访问且易于文件扩展的是<strong>B_</strong>。<br>A.连续结构 B.索引结构<br>C.链式结构且磁盘块定长 D.链式结构且磁盘块变长</p>
</li>
<li><p>19、设文件 F1 的当前引用计数值为 1,先建立 F1 的符号链接(软链接)文件 F2,再建立F1 的硬链接文件 F3,然后删除 F1。此时,F2 和 F3 的引用计数值分别是<strong>B</strong>。<br>A. 0、1 B.1、1 C.1、2 D.2、1</p>
</li>
<li><p>中断扫描机构是（B）扫描一次中断寄存器。<br>A、每隔一个时间片 B、每条指令执行周期内最后时刻<br>C、每当进程释放 CPU D、每产生一次中断</p>
</li>
<li><p>弹出式线程的优点在于：A<br>A、没有历史，创建迅速 B、安全性高<br>C、执行效率高 D、不需要操作系统内核支持线程</p>
</li>
<li><p>在 Web Server 中使用线程，可以ᨀ高对客户请求的响应效率。请简述图中<br>web page cache 的作用。<br><img src="/2020/01/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98%E6%95%B4%E7%90%86/os1.png" alt></p>
<blockquote>
<p>答：线程共享进程资源，所有的线程都可以访问进程的 web page cache（1<br>分），cache 在内存中（1 分），被访问过的页面存放在 cache 中，当任何线程再<br>次需要这个页面时就可以从 cache 中得到，而不需要再次读取硬盘。（3 分）</p>
</blockquote>
</li>
</ol>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><a href="https://blog.csdn.net/qq_28602957/article/details/53744956" target="_blank" rel="noopener">请求分页存储管理方式</a></p>
<p><a href="https://www.cnblogs.com/edisonchou/p/5090315.html" target="_blank" rel="noopener">内存管理上:基本内存管理</a><br><a href="https://www.cnblogs.com/edisonchou/p/5094066.html" target="_blank" rel="noopener">内存管理中:分页内存管理</a><br><a href="https://www.cnblogs.com/edisonchou/p/5115242.html" target="_blank" rel="noopener">内存管理下:段式内存管理</a></p>
]]></content>
      <categories>
        <category>期末</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵链相乘</title>
    <url>/2019/11/02/%E7%9F%A9%E9%98%B5%E9%93%BE%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<h3 id="矩阵链相乘"><a href="#矩阵链相乘" class="headerlink" title="矩阵链相乘"></a>矩阵链相乘</h3><p>矩阵链乘法<br>   求解矩阵链相乘问题时动态规划算法的另一个例子。给定一个n个矩阵的序列（矩阵链）&lt;A1,A2,…,An&gt;，我们希望计算它们的乘积  A1A2…An</p>
<a id="more"></a> 
<p> 两个矩阵A和B只有相容(compatible)，即A的列数等于B的行数时，才能相乘。如果A是p×q的矩阵，B是q×r的矩阵，那么乘积C是p×r的矩阵。计算C所需要时间由第8行的标量乘法的次数决定的，即pqr。<br>   以矩阵链&lt;A1,A2,A3&gt;为例，来说明不同的加括号方式会导致不同的计算代价。假设三个矩阵的规模分别为10×100、100×5和5×50。<br>   如果按照((A1A2)A3)的顺序计算，为计算A1A2(规模10×5)，需要做10×100×5=5000次标量乘法，再与A3相乘又需要做10×5×50=2500次标量乘法，共需7500次标量乘法。<br>   如果按照(A1(A2A3))的顺序计算，为计算A2A3(规模100×50)，需100×5×50=25000次标量乘法，再与A1相乘又需10×100×50=50000次标量乘法，共需75000次标量乘法。因此第一种顺序计算要比第二种顺序计算快10倍。</p>
<p> 矩阵链乘法问题(matrix-chain multiplication problem)可描述如下：给定n个矩阵的链&lt;A1,A2,…,An&gt;，矩阵Ai的规模为p(i-1)×p(i) (1&lt;=i&lt;=n)，求完全括号化方案，使得计算乘积A1A2…An所需标量乘法次数最少。</p>
<h3 id="递推关系式"><a href="#递推关系式" class="headerlink" title="递推关系式"></a>递推关系式</h3><p><a href="https://blog.csdn.net/Neo_kh/article/details/81282025" target="_blank" rel="noopener">https://blog.csdn.net/Neo_kh/article/details/81282025</a><br>    ①如果i=j，m[i,j]=0</p>
<pre><code>②如果i&lt;j，m[i,j]=min{m[i,k]+m[k+1,j]+p(i-1)p(k)p(j)}  i&lt;=k&lt;j</code></pre><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_size 400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 100000000</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[max_size][max_size];<span class="comment">//保存构造最优解信息</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> p[max_size];<span class="comment">//矩阵规模的记录</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m[max_size][max_size];<span class="comment">//记录最优值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">matrix_chain_order</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m[i][i]=<span class="number">0</span>;<span class="comment">//初始化最优值(起始于1,结束于n)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">2</span>;l&lt;=n;l++)<span class="comment">//l表示矩阵链的长度</span></span><br><span class="line">    &#123;<span class="comment">//计算每一条对角线的最优值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-l+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+l<span class="number">-1</span>;</span><br><span class="line">            m[i][j]=INF;</span><br><span class="line">            s[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j<span class="number">-1</span>;k&gt;=i;k--)<span class="comment">//解决方案优先选取先左边的矩阵</span></span><br><span class="line">            &#123;<span class="comment">//②如果i&lt;j，m[i,j]=min&#123;m[i,k]+m[k+1,j]+p(i-1)p(k)p(j)&#125;  i&lt;=k&lt;j</span></span><br><span class="line">                <span class="keyword">int</span> q=m[i][k]+m[k+<span class="number">1</span>][j]+p[i<span class="number">-1</span>]*p[k]*p[j];</span><br><span class="line">                <span class="keyword">if</span>(q&lt;m[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j]=q;</span><br><span class="line">                    s[i][j]=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_optimal_parents</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span><span class="comment">//打印最优解的结果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==j)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"A%d"</span>,i);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">//中序二叉树?</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">            print_optimal_parents(i,s[i][j]);</span><br><span class="line">            print_optimal_parents(s[i][j]+<span class="number">1</span>,j);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        matrix_chain_order(n);</span><br><span class="line">        print_optimal_parents(<span class="number">1</span>,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结:<br>动态规划算法设计要素<br>1.多阶段决策过程,每步处理一个子问题,界定子问题的边界<br>2.列出优化函数的递推方程及初值<br>3.问题要满足优化原则或最优子结构性质,即:一个最优决策序列的任何子序列本身一定是相对于子序列的<br>初始和结束状态的最优决策序列<br>拓展: 递归实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==j)               <span class="comment">/*如果只有一个矩阵就直接返回*/</span></span><br><span class="line">        <span class="keyword">return</span> m[i][j];</span><br><span class="line">    m[i][j]=<span class="number">999999999</span>;     <span class="comment">/*将m[i][j]设为无穷大*/</span></span><br><span class="line">    s[i][j]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)&#123;  <span class="comment">/*将i到j个矩阵分为i到k和k+1到j个矩阵*/</span></span><br><span class="line">        <span class="keyword">int</span> q=dp(i,k)+dp(k+<span class="number">1</span>,j)+p[i<span class="number">-1</span>]*p[k]*p[j]; </span><br><span class="line">        <span class="keyword">if</span>(q&lt;m[i][j])&#123;      <span class="comment">/*如果有更小的方案更新*/</span></span><br><span class="line">            m[i][j]=q;</span><br><span class="line">            s[i][j]=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m[i][j];         </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;  <span class="comment">/*输入矩阵链*/</span></span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));    <span class="comment">/*初始化*/</span></span><br><span class="line">        dp(<span class="number">1</span>,n);                    <span class="comment">/*查找目标1到n个矩阵链乘*/</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;m[<span class="number">1</span>][n]&lt;&lt;<span class="string">" "</span>&lt;&lt;s[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>矩阵链</tag>
      </tags>
  </entry>
</search>
