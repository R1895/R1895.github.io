<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="Jason's blogs" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="数据库复习还几天考数据库了,看了看往年试卷没找几道会的题.翻了翻书复习,内容太多了所以打算拿往年试卷复习.">
<meta property="og:type" content="article">
<meta property="og:title" content="DataBase">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;21&#x2F;DataBase&#x2F;index.html">
<meta property="og:site_name" content="Jason&#39;s blogs">
<meta property="og:description" content="数据库复习还几天考数据库了,看了看往年试卷没找几道会的题.翻了翻书复习,内容太多了所以打算拿往年试卷复习.">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;rlj-1999-1259282223.cos.ap-beijing.myqcloud.com&#x2F;%E6%95%B0%E6%8D%AE%E5%BA%93&#x2F;%E4%B9%A0%E9%A2%98&#x2F;sjk1.png">
<meta property="og:image" content="https:&#x2F;&#x2F;rlj-1999-1259282223.cos.ap-beijing.myqcloud.com&#x2F;%E6%95%B0%E6%8D%AE%E5%BA%93&#x2F;%E4%B9%A0%E9%A2%98&#x2F;sjk2.png">
<meta property="og:image" content="https:&#x2F;&#x2F;rlj-1999-1259282223.cos.ap-beijing.myqcloud.com&#x2F;%E6%95%B0%E6%8D%AE%E5%BA%93&#x2F;%E4%B9%A0%E9%A2%98&#x2F;sjk3.png">
<meta property="og:image" content="https:&#x2F;&#x2F;rlj-1999-1259282223.cos.ap-beijing.myqcloud.com&#x2F;%E6%95%B0%E6%8D%AE%E5%BA%93&#x2F;%E4%B9%A0%E9%A2%98&#x2F;sjk4.png">
<meta property="og:image" content="https:&#x2F;&#x2F;rlj-1999-1259282223.cos.ap-beijing.myqcloud.com&#x2F;%E6%95%B0%E6%8D%AE%E5%BA%93&#x2F;%E4%B9%A0%E9%A2%98&#x2F;sjk5.png">
<meta property="og:image" content="https:&#x2F;&#x2F;rlj-1999-1259282223.cos.ap-beijing.myqcloud.com&#x2F;%E6%95%B0%E6%8D%AE%E5%BA%93&#x2F;%E4%B9%A0%E9%A2%98&#x2F;sjk6.png">
<meta property="og:image" content="https:&#x2F;&#x2F;rlj-1999-1259282223.cos.ap-beijing.myqcloud.com&#x2F;%E6%95%B0%E6%8D%AE%E5%BA%93&#x2F;%E4%B9%A0%E9%A2%98&#x2F;sjk7.png">
<meta property="og:image" content="https:&#x2F;&#x2F;rlj-1999-1259282223.cos.ap-beijing.myqcloud.com&#x2F;%E6%95%B0%E6%8D%AE%E5%BA%93&#x2F;%E4%B9%A0%E9%A2%98&#x2F;sjk8.png">
<meta property="og:image" content="https:&#x2F;&#x2F;rlj-1999-1259282223.cos.ap-beijing.myqcloud.com&#x2F;%E6%95%B0%E6%8D%AE%E5%BA%93&#x2F;%E4%B9%A0%E9%A2%98&#x2F;sjk9.png">
<meta property="og:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190603175459427.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3ODY1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190603180545304.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3ODY1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190603202218714.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3ODY1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;2019060320274211.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3ODY1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2019-12-21T05:55:01.366Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;rlj-1999-1259282223.cos.ap-beijing.myqcloud.com&#x2F;%E6%95%B0%E6%8D%AE%E5%BA%93&#x2F;%E4%B9%A0%E9%A2%98&#x2F;sjk1.png">

<link rel="canonical" href="http://yoursite.com/2019/12/21/DataBase/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>DataBase | Jason's blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Only action can relieve the uneasiness.</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-fw fa-calendar"></i>日程表</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/21/DataBase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/rlj.jpg">
      <meta itemprop="name" content="任林杰">
      <meta itemprop="description" content="建设最美114">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason's blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          DataBase
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-12-21 13:53:02 / 修改时间：13:55:01" itemprop="dateCreated datePublished" datetime="2019-12-21T13:53:02+08:00">2019-12-21</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>32k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>29 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="数据库复习"><a href="#数据库复习" class="headerlink" title="数据库复习"></a>数据库复习</h2><p>还几天考数据库了,看了看往年试卷没找几道会的题.<br>翻了翻书复习,内容太多了<br>所以打算拿往年试卷复习.</p>
<a id="more"></a>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><ol>
<li>下列关于关系数据库的说法，哪一项是正确的？B<br>• A. 关系数据库不能存储视频或音频。<br>• B. 表是由列和行组成的。<br>• C. 同一个表中的行可以拥有不同的列集。<br>• D. 行也称为表字段。</li>
<li>下列哪些是关系数据模型的组件？B<br>• A. 指针，集合，约束<br>• B. 关系，属性，元组<br>• C. 实例，记录类型，实体<br>• D. 表，行，等级</li>
<li>下列哪一项表述是错误的？A<br>• A. 关系模型中的属性映射到关系数据库中的行<br>• B. 在 ERD 中，用长方形表示实体(集)<br>• C. 一对一和多对多是可以在 ERD 中表示的关系<br>• D. 关系模型中的实体映射到关系数据库中的表<blockquote>
<p>行可能是一个实体,列是属性</p>
</blockquote>
</li>
<li>应用程序 B 想要在同一事务中多次读取表 EMPLOYEE 中的行子集。为了保证每次<br>都能返回相同的行子集，应该使用哪种隔离级别？C<br>• A.当前落实<br>• B.读稳定性<br>• C.可重复读<br>• D.未落实读</li>
<li>下列关于事务的说法，哪一项是错误的？A<br>• A.事务中的操作并行执行。<br>• B.同一个事务中只能执行 1 个 COMMIT 语句。<br>• C.事务会保证一组操作的原子性。<br>• D. ROLLBACK 或 COMMIT 语句可以终结事务。</li>
<li>下列哪一项是事务的定义？A<br>• A. 组合在一起的一个或多个 SQL 操作序列，也被称为一个工作单元<br>• B. 一组可以并行执行的独立操作<br>• C. 一个数据隔离级别，可通过允许读取之前已落实的数据来防止死锁<br>• D. 一个 DB2 数据库对象</li>
<li>以下哪种情况会发生脏读？C<br>• A. 一个事务读取了相同的数据行两次，并且每次都返回不同的数据值<br>• B. 在一个事务期间，基于特定标准的搜索在执行连续搜索之后返回额外的行<br>• C. 返回了未落实的数据，但产生这些数据的事务已回滚<br>• D. 两个事务读取并试图更新相同的数据，第二次更新将在第一次更新落实之前将其覆盖</li>
<li>下列哪一项是关于 DB2 授权的最佳描述？A<br>• A. 授权是一个过程，检查你是否具有足够的权限以执行所需的数据库操作<br>• B. 授权是一个过程，在此过程中 DBA 将收集相关信息以查看哪些人可以访问数据库<br>• C. 授权是一个过程，在此过程中 DB2 数据库将使用 Windows 安全机制来检查你是<br>否能够访问 DB2 数据库<br>• D. 授权是一个过程，它通过验证你的用户 ID 和密码来确认你是否是所声称的那个人</li>
<li>下列哪一项不是恢复的类型？B<br>A. 版本恢复<br>B. 自动重启恢复<br>C. 崩溃恢复<br>D. 前滚恢复</li>
<li>自动存储具备什么功能？A<br>• A. 自动存储允许用户指定数据库管理器用于存储表空间数据的路径，从而简化了存储<br>管理。<br>• B. 自动存储是一种选项，它允许写入到数据库的事务自动落实。<br>• C. 自动存储是一种 DB2 功能，它允许按设定计划自动备份表。<br>• D. 自动存储可以用于自动重组物理介质上的数据，以提高性能。</li>
</ol>
<h3 id="2012-2013"><a href="#2012-2013" class="headerlink" title="2012-2013"></a>2012-2013</h3><ol>
<li>下列哪一个选项中的描述都可以作为E/R图中的实体集？ <strong>D</strong><br>A. 产品，颜色，高度<br>B. 黄色，大，长<br>C. 约翰，狗，飞机<br>D. 人，动物，植物 </li>
</ol>
<blockquote>
<p>实体是某种抽象对象,相似实体的集合形成实体集.<br>实体集有相关的属性,属性是这个实体机中实体所具有的性质<br>联系是两个或多个实体集的连接<br>颜色,高度 应该算是一种属性<br>约翰,狗,飞机 是实体</p>
</blockquote>
<ol start="2">
<li><p>下列哪一项表述是错误的？ <strong>D</strong><br>A.关键字唯一地标识表中的行。<br>B.外关键字是引用其他表主关键字的列集。<br>C.主关键字和外关键字用于强制数据完整性。<br>D.必须始终在表中定义主关键字。</p>
</li>
<li><p>下列哪些实体集在ER图中应该使用一对多关系？ <strong>D</strong><br>A. 人，  汽车<br>B. 学生，课程<br>C. 学生，教师<br>D. 母亲，孩子</p>
</li>
<li><p>如果使用下列语句创建 TAB1<br>CREATE TABLE tab1(c1 int not null,c2 int not null,<br>check  (c1+c2&gt;10))<br>下列哪个语句会将记录成功插入表 TAB1？ <strong>C</strong><br>A. INSERT INTO tab1 VALUES (0, 9)<br>B. INSERT INTO tab1 VALUES (null, 20)<br>C. INSERT INTO tab1 VALUES (4, 22)<br>D. INSERT INTO tab1 VALUES (20,null)</p>
<blockquote>
<p>check 这个是约束吗?</p>
</blockquote>
</li>
<li><p>给定下列两个表 </p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">C1</td>
<td align="center">C2</td>
<td align="center"></td>
<td align="center">CA</td>
<td align="center">CB</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center"></td>
<td align="center">a</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">4</td>
<td align="center"></td>
<td align="center">c</td>
<td align="center">d</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">6</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">下列哪个查询语句会得到下面的结果 <strong>C</strong>?</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>C1   C2    CA    CB<br>1    2     a      b<br>1    2     c      d<br>3    4     a      b<br>3    4     c      d<br>5    6     a      b<br>5    6     c      d<br>A.select * from t1,t2 where t1.c1=t2.cb<br>B.select * from t1,t2 where t1.c2=t2.ca<br>C.select * from t1,t2<br>D.select * from t1 inner join t2 on t1.c1=t2.ca</p>
<ol start="6">
<li><p>我们在DBMS中记录员工和部门的管理信息,当一个部门的管理员辞职后,数据库需要自动将该部门的管理员信息填成空值,在定义管理关系表时我们对于外关键字的删除规则应定义为 <strong>C</strong><br>A.ON DELETE CASCADE            B.ON DELETE ROLLBACK<br>C.ON DELETE SET NULL        D.ON DELETE NO ACTION</p>
</li>
<li><p>执行下列 SQL 语句之后：<br>GRANT ALL  ON TABLE student TO USER user1<br>假设用户 USER1 没有其他权限，下列哪一项操作是 USER1 可以执行的？<strong>D</strong><br>A. 将其获得在表student上的所有权限赋予其他用户<br>B. 删除关联到表 STUDENT 的视图<br>C. 删除表 STUDENT   D. 以上都不是</p>
</li>
<li><p>下面视图定义是中哪个是可更新视图  我猜选<strong>D</strong><br>A.Create view V1 as select  S.rating , max(S.age) as avgage from Sailors S group by S.rating<br>B.Create view V2 as select  *  from saliros S1 where S1.age&gt;18 expect select * from sailors S2 where S2.name like ‘%Tom’<br>C.Create view V3 as select  S.name, R,bid. from Sailor S, Reserves R where S.sid=R.sid<br>D.Create view V4 as select * from Bailors B where B.name is not null</p>
</li>
</ol>
<ul>
<li>(1) 若视图是基于多个表使用联接操作而导出的，那么对这个视图执行更新操作时，每次只能影响其中的一个表。</li>
<li>(2) 若视图导出时包含有分组和聚合操作，则不允许对这个视图执行更新操作。</li>
<li>(3) 若视图是从一个表经选择、投影而导出的，并在视图中包含了表的主键字或某个候选键，这类视图称为‘行列子集视图’。对这类视图可执行更新操作。<br><a href="https://www.cnblogs.com/suncan0/p/4767900.html" target="_blank" rel="noopener">可更新视图规则</a></li>
</ul>
<ol start="9">
<li>有两个关系TAB1,TAB2<br> TAB1                       TAB2<br>C1     C2                   CX     CY </li>
</ol>
<hr>
<p>A      11                    A      21<br>B      12                    C      22<br>C      13<br>   结果集如下<br>C1     C2    CX     CY </p>
<hr>
<p> A     11    A      21<br> C     13    C      22<br> B     12    -       -<br>哪个SQL语句能够生成该结果  <strong>D</strong><br>A. SELECT * FROM tab1 right OUTER JOIN tab2 ON c1=cx<br>  B. SELECT * FROM tab1 INNER JOIN tab2 ON c1=cx<br>C. SELECT * FROM tab1 FULL OUTER JOIN tab2 ON c1=cx<br>D. SELECT * FROM tab1 LEFT OUTER JOIN tab2 ON c1=cx</p>
<ol start="10">
<li><p>数据库系统管理员按照事务的方式执行下面的语句：<br>Create table tab1 (a int,b int)<br>insert into tabl values(1,2)<br>insert into tab2 values(2,3)<br>commit<br>Insert into tab1 values(2,3)<br>Insert into tab1 values(1,6)<br>rollback<br>Delete from tab1 where a=1<br>Insert into tab1 values(1,7)<br>数据库系统突然崩溃，系统重新启动后，该管理员执行<br>Select count(<em>) from tab1<br>数据库系统的输出是多少：*</em>A**<br>A. 2      B.3        C.4        D.5</p>
<blockquote>
<p>我猜 (1,7)(2,3)</p>
</blockquote>
</li>
<li><p>有关系模式R（A,B,C,D）,其函数依赖集F={A-&gt;B,B-&gt;C,C-&gt;D,D-&gt;A},将关系模式R分解为AB，BC，CD后，哪个函数依赖丢失了？<strong>C</strong><br>A． A-&gt;B    B.  B-&gt;C   C. D-&gt;A  D.没有函数依赖丢失</p>
</li>
</ol>
<ol start="12">
<li>有两个关系T1,T2<br>T1          T2<br>C1           CX    </li>
</ol>
<hr>
<p>A             A<br>B             C      </p>
<p>结果集如下<br>C1<br>A<br>B<br>A<br>C<br>哪个SQL语句能够生成该结果 <strong>B</strong><br>A.select * from t1 union  select * from t2<br>B.select * from t1 union all select * from t2<br>C.select * from t1,t2<br>D.select * from t1 except select * from t2</p>
<blockquote>
<p>union 默认是去重的,<br>如果要取消去重,要 加上 all关键字</p>
</blockquote>
<ol start="13">
<li><p>假设关系模式R1（EMP_ID，EMP_NAME，PHONE，EMAIL，SALARY）<br>下列方法中，哪一个是限制用户查看 SALARY 信息但仍允许他们查看其他值的最简单方法？<strong>B</strong><br>A. 加密表的数据<br>B. 创建不包含 SALARY 列的视图。赋予访问视图的权限，并撤销访问原始表的权限<br>C. 撤销不应查看 SALARY 数据的用户对 SALARY 列的 SELECT 访问权限<br>D. 将 SALARY 数据存储在其他表中，并赋予相应用户对该表的 SELECT 权限</p>
</li>
<li><p>有关系模式R(A,B,C,D),有函数依赖集F={A-&gt;B,D-&gt;C，A-&gt;C，D-&gt;A},下面哪个分解不具有无损连接性 <strong>D</strong><br>A. ABC,AD   B. ACD,BCD  C.ABD,BD   D.AD,AB </p>
<blockquote>
<p>无损连接性就是能还原关系的意思</p>
</blockquote>
</li>
<li><p>下面哪个说法符合数据库系统WAL(log先写协议): <strong>D</strong><br>A.数据库内存中被事务修改的页面在事务成功完成时被强制写到磁盘中<br>B.数据库内存中被事务修改的页面在事务撤销时被写到标记为非脏页<br>C.事务成功完成时不需要将与其相关的log页面强制写回磁盘<br>D.事务中被修改的内存数据页面在写回磁盘前必须将与其相关的log写回磁盘</p>
</li>
<li><p>在JDBC提供的数据库编程方法中提供了几种JDBC和数据库的连接方法:<strong>C</strong><br>A.5            B.2            C.4            D.1</p>
</li>
<li><p>某数据库应用系统中，在tab1表上频繁出现where a=… ., where a=….and c=….这些查询条件，其中tab1表中的记录个数为1000万条。数据库中数据库管理员为了提高查询效率决定建立索引，请你选出最合适的索引 <strong>D</strong><br>A.  在属性a上和属性（c，b）和属性（a，b，c）上分别建立索引<br>B． 在属性（a，c, b）上建立一个索引<br>C． 在属性a上和属性（a，b，c）分别建立索引<br>D． 在属性（a，c）上建立索引</p>
</li>
<li><p>下面哪个调度是串行调度:  <strong>B</strong><br>A. T1:R(A),T2:R(B),T2:W(B),T1:W(A)<br>B. T1:R(B),T1:W(B),T2:R(A), T2:W(A)<br>C. T1:R(A),T2:R(B),.T1:W(A),T2:W(B)<br>D. T2:R(A),T1:R(B),.T1:W(A),T2:W(B)</p>
</li>
<li><p>关于数据库管理系统下面哪个描述是最正确的  <strong>C</strong><br>A.数据库管理系统是数据的集合.<br>B.数据库管理系统是数据的集合,并且存储着数据与数据之间的关系.<br>C.数据库管理系统是由一个互相关联的数据的集合和一组用以访问和管理这些数据的程序组成.</p>
</li>
<li><p>以下哪种情况会发生不可重复读？<strong>A</strong><br>A. 一个事务读取了相同的数据记录两次，并且每次都返回不同的数据值<br>B. 在一个事务期间，基于特定标准的搜索在执行连续搜索之后返回额外的行<br>C. 返回了未落实的数据，但产生这些数据的事务已回滚<br>D. 两个事务读取并试图更新相同的数据，第二次更新将在第一次更新落实之前将其覆盖</p>
<p>二.名称解释(每题3分,共15分)</p>
</li>
<li><p>主关键字<br>主关键字（主键，primary key）是被挑选出来,作表的行的唯一标识的候选关键字。一个表只有一个主关键字。主关键字又可以称为主键。 主键可以由一个字段，也可以由多个字段组成，分别称为单字段主键或多字段主键。又称主码。并且它可以唯一确定表中的一行数据，或者可以唯一确定一个实体。</p>
</li>
</ol>
<p>2.BC范式</p>
<p>BCNF<br>设关系模式R&lt;U，F&gt;∈1NF，如果对于R的每个函数依赖X→Y，若Y不属于X，则X必含有候选码，那么R∈BCNF。</p>
<ol start="3">
<li>关系模式分解的无损连接性</li>
</ol>
<p>对关系模式分解时，原关系模式的任何一个合法的关系值在分解之后应该能通过自然连接运算恢复起来，这就是无损连接所要解决的问题。</p>
<ol start="4">
<li><p>数据库</p>
<blockquote>
<p>数据库是存放数据的仓库。它的存储空间很大，可以存放百万条、千万条、上亿条数据。但是数据库并不是随意地将数据进行存放，是有一定的规则的，否则查询的效率会很低。当今世界是一个充满着数据的互联网世界，充斥着大量的数据。即这个互联网世界就是数据世界。数据的来源有很多，比如出行记录、消费记录、浏览的网页、发送的消息等等。除了文本类型的数据，图像、音乐、声音都是数据</p>
</blockquote>
</li>
<li><p>事务原子性<br>事务中的多个数据库操作是一个不可分割的原子单元整体，只有所有的操作执行成功，整个事务才提交。事务中的任何一个数据库操作失败，已经执行的任何操作都必须被撤销，让数据库返回初始状态。<br>拓展:</p>
</li>
</ol>
<ul>
<li>事务ACID四大特性:<ul>
<li>原子性<br>  -定义:事务中的多个数据库操作是一个不可分割的原子单元整体，只有所有的操作执行成功，整个事务才提交。事务中的任何一个数据库操作失败，已经执行的任何操作都必须被撤销，让数据库返回初始状态。<ul>
<li>实现:事务内的一组操作全部成功(或者全部失败),为了实现原子性,就需要通过日志:将所有对数据的操作都写入日志,如果事务中的一部分操作已经成功,但后面部分操作,因为系统断电,操作系统崩溃等问题而没有成功执行,那么就要通过<strong>回溯日志,将前面已经成功执行的操作撤销,从而达到”全部执行失败”的效果。</strong></li>
</ul>
</li>
<li>一致性:<ul>
<li>事务操作成功后，保证数据不会被破坏</li>
<li>如A账户转账100元到B账户，不管操作成功与否，A和B账户的存款总额是不变的。一致性分为数据库外部一致性和内部一致性：</li>
<li>数据库外部一致性:由外部的应用编码来实现,即银行的应用在进行转账的操作时,必须在同一事务内部调用对账户A和账户B的操作。如果在这个阶段出现错误,这不是数据库本身能解决的,也不属于我们要讨论的范围。</li>
<li>数据库内部的一致性:在同一个事务内部的一组操作必须全部成功(或者全部失败) 这就是事务原子性</li>
</ul>
</li>
<li>持久性:<ul>
<li>一旦事务提交成功后，事务中所有的数据操作都必须被持久化到数据库中。即使在事务提交后，数据库马上崩溃，在数据库重启时，也必须保证能够通过某种机制恢复数据。</li>
</ul>
</li>
<li>隔离性:<br>  <a href="https://blog.csdn.net/u014079773/article/details/52808193" target="_blank" rel="noopener">点击阅读隔离</a></li>
</ul>
</li>
</ul>
<p>   三．简答题（共45分）<br>有关系模式students(sid,sname,age,grade,class), course(cid, cname), enroll(sid,cid, score). students记录学生的基本信息,在students中sid表示学生的学号，sname表示学生的姓名,age表示年龄,grade表示年级,class表示班级，sid是students的主关键字.Course记录课程信息,cid为课程编号,cname表示课程名称,cid为course的主关键字.Enroll表示学生的选课信息,sid表示学号,cid表示课程编号,score表示成绩,sid,cid共同组成enroll的主关键字,sid为指向students的外关键字,cid为指向course的外关键字<br>1.请用关系代数写出下面的查询<br>查找年龄最小的学生姓名 (5分)</p>
<p>2.请用元组关系演算写出下面的查询<br>查找年龄小于19而且数据库课程的成绩高于89的学生姓名（5分）</p>
<p>元组关系表达式好像没有学吧?</p>
<p>请用SQL语句写出下面的查询<br>4.查找即选了’数据库原理’课程而没有选’web开发’课程的学生姓名（5分）</p>
<p>select sname from course c,students s,enrool r<br>where cname = ‘数据库原理’<br>and s.sid=r.sid<br>and c.cid=r.cid<br>except<br>select sname from course c,students s,enrool r<br>where cname = ‘数据库原理’<br>and s.sid=r.sid<br>and c.cid=r.cid</p>
<p>select sname from course c,students s,enrool r<br>where cname = ‘数据库原理’<br>and s.sid=r.sid<br>and c.cid=r.cid<br>and cname &lt;&gt;’web开发’</p>
<p>5.统计2011级每个班中数据库课程不及格的人数 （5分）</p>
<p>select count(*)<br>from course c,students s,enrool r<br>where grade = 2011<br>and cname = ‘数据库原理’<br>and s.sid=r.sid<br>and c.cid=r.cid<br>and score &gt;=60</p>
<ol start="6">
<li>显示在2011级各班中在数据库原理课程上平均分最低的班级和平均分（5分）</li>
</ol>
<ol start="7">
<li>统计选了数据库课程的平均分，最高分和最低分（5分）</li>
</ol>
<ol start="8">
<li>请根据下面的要求画出ER图（5分）<br>某个企业的数据库中记录以下信息:1.员工(ssn，name，lot)员工编号ssn唯一确定一个员工，2.部门(did，dname，buget)部门编号did唯一确定一个部门,3.员工与部门的管理关系，每个部门有且仅有一个管理者。</li>
</ol>
<blockquote>
<p>一个员工实体集,ssn是主键 (矩形)<br>一个部门实体集,did是主键 (矩形)<br>一个 manage 关系, 剪头指向 部门 (菱形)<br>需不需要用弧线?</p>
</blockquote>
<ol start="9">
<li>有关系模式R(ABCD),R上的函数依赖集F={ AC,CA,BAC,DAC,BDA },请将R分解成满足第三范式的关系模式，要求该分解具有无损连接性和依赖保持性(10分)</li>
</ol>
<h4 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h4><ul>
<li><p>关系的键 : 一个或多个属性集 {…}; 当键只包括单独的属性A时,称A(而不是{A})是键 </p>
<ul>
<li><ol>
<li>不可能存在两个不同元组具有相同的{…} </li>
</ol>
</li>
<li><ol start="2">
<li>键必须是最小的,ok!</li>
</ol>
</li>
</ul>
</li>
<li><p>超键 : 不满足上述条件的第二种情况.</p>
</li>
<li><p><strong>主属性</strong>：  包含在任一候选关键字中的属性称主属性。</p>
</li>
<li><p><strong>非主属性</strong>：  不包含在主码中的属性称为非主属性。</p>
</li>
<li><p><strong>函数依赖FD</strong>：<br>例：身份证号→姓名。<br>A → B<br>感觉就是 已知 A 可以推出 B (A可能就是键值吧)<br>至于是谁依赖谁呢?</p>
<ul>
<li><p><strong>部分函数依赖</strong>：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。</p>
</li>
<li><p><strong>完全函数依赖</strong>：在R(U)中，如果Y函数依赖于X,并且对于X的任何一个真子集X’，都有Y不函数依赖于X’， 则称Y对X完全函数依赖。否则称Y对X部分函数依赖。</p>
<ul>
<li><strong>平凡函数依赖</strong> : 例如: A,B,C -&gt; A,B<br>右边是左边的子集</li>
</ul>
<blockquote>
<p>【例】:<br>举个例子就明白了。假设一个学生有几个属性<br>SNO 学号   SNAME 姓名    SDEPT系<br>SAGE 年龄  CNO 班级号     G 成绩<br>对于(SNO,SNAME,SDEPT,SAGE,CNO,G)来说，G完全依赖于(SNO, CNO), 因为(SNO,CNO)可以决定G，而SNO和CNO都不能单独决定G。<br>而SAGE部分函数依赖于(SNO,CNO),因为(SNO,CNO)可以决定SAGE，而单独<br>SNO也可以决定SAGE。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>传递函数依赖</strong>：<br>设R（U）是属性集U上的关系，x、y、z是U的子集，在R（U）中，若x→y，但y→x，若y→z，则x→z，称z传递函数依赖于x，记作X→TZ。<br>如果X-&gt;Y, Y-&gt;Z, 则称Z对X传递函数依赖。</p>
</li>
<li><p><strong>计算X+（属性的闭包）算法</strong>： </p>
<blockquote>
<pre><code>a.初始化，令X+ = X;  </code></pre><p>   b.在F中依次查找每个没有被标记的函数依赖，若“左边属性集”包含于X+ ，则令 X+ = X+∪“右边属性集”, 并为访问过的函数依赖设置标记。<br>   c.反复执行b直到X+不改变为止。</p>
</blockquote>
</li>
<li><p><strong>检验给定的任意函数依赖A1A2…An-&gt;B是否蕴含于依赖集S:</strong></p>
<blockquote>
<p>分析：<br>根据属性集闭包的定义，可知A1A2…An-&gt;{A1,A2,…,An}+ 蕴含于S。只要证明B在{A1，A2，….,An}+中，那么函数依赖A1A2…An-&gt;B肯定蕴含于依赖集S中<br>求解过程：<br>（1） 利用依赖集计算闭包<br>（2） 如果B在闭包中，则函数依赖A1A2…An-&gt;B是否蕴含于<br>依赖集S，否则不蕴含于S</p>
</blockquote>
</li>
</ul>
<p>【例】:<br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk1.png" alt=""><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk2.png" alt=""><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk3.png" alt=""></p>
<ul>
<li>最小化基本集 : 不可能包含平凡FD<ul>
<li><ol>
<li>B中所有FD的右边均为单一属性</li>
</ol>
</li>
<li><ol start="2">
<li>从B中删除任何一个FD后,该集合不再是基本集</li>
</ol>
</li>
<li><ol start="3">
<li>对于B中任何一个FD,如果从其左边删除一个或者多个属性,B将不再是基本集</li>
</ol>
</li>
</ul>
</li>
<li>Armstrong公理<ul>
<li>自反律:自己推自己 A-&gt;A</li>
<li>增广律 A-&gt;B 怎 AC-&gt;BC</li>
<li>传递律 A-&gt;B B-&gt;C 则A-&gt;C</li>
</ul>
</li>
</ul>
<p><font color=red size = 5>总结：</font><br>判定函数依赖X→Y是否能由F导出的问题，         可转化为求X+并判定Y是否是X+子集的问题。<br><font color=red>即求F闭包的问题可转化为求属性集闭包的问题。</font></p>
<p>函数依赖的闭包：<br>定义：若F为关系模式R(U)的函数依赖集，我们把F以及<font color=red>所有被F逻辑蕴涵的函数依赖的集合</font><br>称为F的闭包，记为F+</p>
<p>求函数依赖闭包，基于函数依赖推理规则<br>函数依赖推理规则：<br>若XY-&gt;Z，则X-&gt;Z，Y-&gt;z （错）<br>正确的：<br>若X-&gt;Y, 则XZ-&gt;YZ<br>若X-&gt;Y,X-&gt;Z，则X-&gt;YZ<br>若X-&gt;Y，Z属于Y，则X-&gt;Z<br>若X-&gt;Y，Y-&gt;Z，则X-&gt;Z<br>若X-&gt;YZ，则X-&gt;Y，X-&gt;Z //可以把每个函数依赖的右边的属性分解，从而使其右边只出现一个属性<br>伪传递率：<br>若A-&gt;B,BC-&gt;D,则AC-&gt;D</p>
<ul>
<li>异常<ul>
<li>冗余</li>
<li>更新异常</li>
<li>删除异常</li>
</ul>
</li>
<li>分解关系<br>  一般用分解关系的方法来消除异常4</li>
</ul>
<p><font size = 5 color=red>第一范式（1NF）：</font>属性，属性值，字段不可分<br>就是无重复的列<br>如果一个关系模式R的所有属性都是不可分的基本数据项<br>不满足1NF的数据库就不是关系数据库<br>不可以表中有表</p>
<p><font size = 5 color=red>第二范式（2NF）：</font>符合1NF，每一个非主属性完全依赖于码，不能存在部分依赖，有主键，非主键字段依赖主键; 唯一性 一个表只说明一个事物;<br>例:<br>不符合第二范式的例子:<br>表:学号, 姓名, 年龄, 课程名称, 成绩, 学分;<br>这个表明显说明了两个事务:学生信息, 课程信息;<br>存在问题:<br>数据冗余，每条记录都含有相同信息；<br>删除异常：删除所有学生成绩，就把课程信息全删除了；<br>插入异常：学生未选课，无法记录进数据库；<br>更新异常：调整课程学分，所有行都调整。<br>修正:<br>学生：Student(学号, 姓名, 年龄)；<br>课程：Course(课程名称, 学分)；<br>选课关系：SelectCourse(学号, 课程名称, 成绩)。<br>满足第2范式只消除了插入异常。</p>
<p><font size = 5 color=red>第三范式（3NF）：</font><br>符合2NF，并且，消除传递依赖，非主键字段不能相互依赖; 每列都与主键有直接关系，不存在传递依赖;<br>若所有的属性都是主属性，则属于第三范式<br>要求一个数据库表中不包含已在其它表中已包含的非主关键字信息<br>【例】：<br>不符合第三范式的例子:<br>学号, 姓名, 年龄, 所在学院, 学院联系电话，关键字为单一关键字”学号”;<br>存在依赖传递: (学号) → (所在学院) → (学院地点, 学院电话)<br>存在问题:<br>数据冗余:有重复值；<br>更新异常：有重复的冗余信息，修改时需要同时修改多条记录，否则会出现数据不一致的情况<br>删除异常<br>修正：<br>学生：(学号, 姓名, 年龄, 所在学院)；<br>学院：(学院, 地点, 电话)。 </p>
<font size = 5 color=red>
总结：</font>

<ul>
<li>1nf:不可分</li>
<li>2nf:一个表说明一个事物，唯一性</li>
<li>3nf:对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。</li>
</ul>
<p><font size = 5 color=red>BCNF</font>是3NF的改进形式<br>BCNF意味着在关系模式中每一个决定因素都包含候选键，也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。BCNF范式排除了任何属性对候选键的传递依赖与部分依赖。</p>
<ul>
<li>满足BCNF条件<ul>
<li>1 所有非主属性对每一个候选键都是完全函数依赖；</li>
<li>2 所有的主属性对每一个不包含它的候选键，也是完全函数依赖；</li>
<li>3 没有任何属性完全函数依赖于非候选键的任何一组属性。</li>
</ul>
</li>
</ul>
<p><font size = 5 color=red>候选键</font>(又称候选码，候选关键字,码 ，candidate key)<br>设K是一个R(U)中的属性或属性集合(注意可以是属性集合，也即多个属性的组合)，若K完全函数确定U，则K为R的候选键(Candidate key);<br>通俗地说就是，能够确定全部属性的某个属性或某组属性，称为候选键。若候选键多于一个，则选定其中一个作为主键。</p>
<p><strong>在所有依赖关系右边没有出现的属性一定是候选键的成员。</strong></p>
<p><font size = 5 color=red>BCNF范式排除了任何属性对候选键的传递依赖与部分依赖。</font><br><font size = 5 color=red></font><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk4.png" alt=""><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk5.png" alt=""><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk6.png" alt=""><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk7.png" alt=""><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk8.png" alt=""><br><img src="https://rlj-1999-1259282223.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B9%A0%E9%A2%98/sjk9.png" alt=""></p>
<h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><p>设有关系模式R（A，B，C，D，E，G）上的函数依赖集为：<br> F={ A→B，B→C，AD→G，D→E } 。求解：<br>31. 求关系模式R的所有侯选键。</p>
<blockquote>
<p>解: 求出侯选键AD。（2分）<br>首先在F中函数依赖右边不出现的属性必在侯选键中,即AD (1分)；由于(AD)+=ABCDEG, 即AD能函数决定所有的属性, 所以侯选键只有一个 AD（1分） 。 AD+=AD BEG C<br>32. 分别求属性集G、AD、CD、BC的闭包。<br>G+=G(1分)；      (AD)+=ABCDEG(1分)；<br>(CD)+= CDE(1分)；(BC)+=BC(1分)<br>33. 将关系模式R保持依赖地且无损地分解成3NF，要求写出分解过程。<br>解：F={ A→B，B→C，AD→G，D→E }<br>F是最小依赖集，所有属性在F中出现，将F中是每个函数依赖组成一个关系模式得保持函数依赖的分解：{AB，BC，ADG， DE} (2分)； 并上一个侯选键{AD}得无损分解：<br>{AB，BC，ADG，DE}∪{AD}={ AB，BC，ADG，DE } (2分)<br>F={ A→B，B→C，AD→G，D→E }<br>34. 将关系模式R无损地分解成BCNF，要求写出分解过程。<br>解：根据转换为BCNF的无损连接分解算法6.5  1）由于候选键为AD，<br>F中存在不符合BCNF要求的函数依赖，所以R不是BCNF，<br>选 A→B 分解为：R1=AB，R2=ACDEG ；(1分)<br>R1上保持的函数依赖集为A→B，键为A，所以是BCNF；<br>R2 上保持的函数依赖集为A→C，AD→G，D→E，键为AD，所以不是BCNF； (1分)<br>选A→C进一步分解为：R21=AC，R22=ADEG；(1分) R21上保持的函数依赖为A→C，键为A，所以是BCNF；<br>R22上保持的函数依赖为AD→G，D→E键为AD，所以不是BCNF； 选D→E进一步分解为：R221=DE，R222=ADG；(1分) R221上保持的函数依赖为D→E，键为D，所以是BCNF； R222上保持的函数依赖为AD→G，键为AD，所以是BCNF；<br>最后得保持无损连接特征的分解：{R1，R21，R221，R222}或表示为{AB，AC，DE，ADG}(1分)<br>注：由于选择不符合BCNF要求的函数依赖有多个，因此选择次序可有不同，最后的结果也不同，原则上按上述评分标准分步给分。<br>35. 说明分解ρ={R1，R2}，R1（ABC）、R2（ADEG）的范式级别并说明理由<br>答：R1是2NF (1分)，R2是1NF；(1分)<br>R1上的函数依赖集为：A→B，B→C，码为：A，不存在部分依赖，存在非主属性C对码A的传递依赖。(1分)<br>R2上的函数依赖集为：AD→G，D→E码为：AD，存在非主属性E对码AD的部分依赖。。(1分)<br>ρ={R1，R2}，R1（ABC）、R2（ADEG）</p>
</blockquote>
<h4 id="关系模型基础"><a href="#关系模型基础" class="headerlink" title="关系模型基础:"></a>关系模型基础:</h4><ul>
<li>属性 : 关系的列命名为属性,属性出现在列的顶部;属性用来表述所在列的项目的语义</li>
<li>模式 : 关系名和其属性集合的组合称为这个关系的模式;</li>
<li>元组 : 关系中除含有属性名所在行以外的其他行称为元组;<br>每个元组均有一个分量对应于关系的每个属性</li>
<li>域 : 一个特殊的元素属性 (数据类型)</li>
<li>关系是元组的集合,而不是元组的列表,关系中元组出现的顺序不是实质问题.</li>
<li>关系上的键 : </li>
<li>修改关系模式<ul>
<li>DROP TABLE R;</li>
<li>ALTER TABLE Moive ADD phone char(16);</li>
<li>ALTER TABLE Moive DROP phone;</li>
</ul>
</li>
<li>默认值 <ul>
<li>gender char(1) default ‘?’,</li>
<li>birthdate date default date ‘0000-00-00’,</li>
</ul>
</li>
<li>键的声明<br>  可声明一个或者一组属性是键<ul>
<li>PRIMARY KEY (属性不能有null值)</li>
<li>UNIQUE (null值是允许的)</li>
<li>外键</li>
</ul>
</li>
</ul>
<h4 id="代数查询语言"><a href="#代数查询语言" class="headerlink" title="代数查询语言"></a>代数查询语言</h4><ul>
<li>关系上的集合操作<ul>
<li>并 R∪S</li>
<li>交 R∩S</li>
<li>差 R-S</li>
</ul>
</li>
<li>投影 π a1,a2,…(R)<br>ok领会!<br>a1,a2…是要投影的列</li>
<li>选择<br>σc(R) C是条件</li>
<li>笛卡尔积 R × S<br>领会</li>
<li>自然连接<br>  R ∞ S (用∞代替那个符号了)<ul>
<li>要求: 连接时相应的元组必须在某些方面一致.(属性名字吗?)</li>
<li>如果一个元组不能和另外关系中的任何一个元组配对的话,这个元组就被称为<strong>悬浮元组</strong></li>
</ul>
</li>
<li>θ连接<br>R ∞c S<br>上面提到了C指的是条件<br>θ连接也就是满足某种条件的笛卡尔积</li>
<li>命名和重命名<br>ρs(R)<br>ρs(A1,A2,…An)(R)<br>把S改成名为R的关系</li>
<li>操作之间的关系<ul>
<li>R ∩ S = R - (R - S)</li>
<li>R ∞c S = σc(R × S) </li>
<li>自然连接和笛卡尔积的连接就不必写了把</li>
</ul>
</li>
<li>代数表达式的线性符号<ul>
<li>关系的名字和用圆括号括起来的关系属性的列表.名字Answer习惯性表示最后一步运算的结果,也就是在表达式树根节点上的关系名</li>
<li>赋值符号 :=</li>
<li>赋值号右边的任何代数表达式,可以采用每个赋值语句只用一个算符的方法.也可把几个代数运算组合到一起写到表达式的右端.</li>
</ul>
</li>
<li>关系上的约束<ul>
<li>R=ø 表示 R的值必须为空的约束 与 “R中没有元组等价”</li>
<li>R ⊆ S 表示”任何在R中出现的元组都必须在S中出现”的约束<br>也可写成R - S = ø</li>
<li>引用完整性约束是一种普通的约束.<br>某个上下文出现的值也必须在另外相关的上下文中出现<br>领悟!</li>
<li>键约束 没有任何两个元组在键分量上具有相同的值</li>
<li>其他约束: 略懂;  满足某些条件的关系代数表达式 等于ø 或 ⊆关系</li>
</ul>
</li>
</ul>
<h4 id="E-R图"><a href="#E-R图" class="headerlink" title="E/R图"></a>E/R图</h4><h3 id="2013-2014"><a href="#2013-2014" class="headerlink" title="2013-2014"></a>2013-2014</h3><p>一、单项选择题（20题，每题2分）</p>
<ol>
<li><p>在数据库系统中，日志文件可以用于？  <strong>D</strong><br>A.保障事务的并发性   B.保障数据的安全性<br>C.检测系统的死锁     D.数据库故障的恢复 </p>
</li>
<li><p>公司中有多个部门和多名职员，每个职员只能属于一个部门，一个部门可以有多名职员， 从职员到部门的联系集的映射类型是 <strong>C</strong><br>A．多对多      B．一对一<br>C．多对一      D．零对多</p>
</li>
<li><p>已知关系R={A，B，C，D，E，F}，F={A→C，BC→DE，D→E，CF→B}。则(AB)属性的闭包是 <strong>B</strong><br>A．ABCDEF     B．ABCDE<br>C．ABC         D．A</p>
</li>
<li><p>设有关系R（A，B，C）和S（C，D）。与SQL语句select R.A,R.B,S.D from R,S where R.C=S.C 等价的关系代数表达式是 <strong>B</strong><br>A．σR.C=S.C(πA,B,D(R×S))<br>B．πA,B,D(σR.C= S.C(R×S))<br>C．σR.C=S.C((πA,B (R))×(πD(S)))<br>D．σR.C=S.C(πD((πA,B(R))×S))</p>
</li>
<li><p>某查询语句中有“%田_”语句，则可能的查询结果有 <strong>C</strong><br>A．张田        B．田利华<br>C．田华        D．刘耕田</p>
</li>
<li><p>数据库系统与文件系统的主要区别是 <strong>B</strong><br>A．数据库系统复杂，而文件系统简单<br>B．文件系统不能解决数据冗余和数据独立性问题，而数据库系统可以解决<br>C．文件系统只能管理程序文件，而数据库系统能够管理各种类型的文件<br>D．文件系统管理的数据量较少，而数据库系统可以管理庞大的数据量    </p>
</li>
<li><p>数据库(DB)和数据库管理系统(DBMS)两者之间的关系是 <strong>A</strong><br>A．DBMS包括DB        B．DB和DBMS无关<br>C．DB包括DBMS        D．DBMS就是DB</p>
</li>
<li><p>数据库管理系统中用于定义和描述数据库逻辑结构的语言称为 <strong>A</strong><br>A．数据定义语言        B．数据库子语言<br>C．数据操纵语言        D．数据结构语言</p>
</li>
<li><p>设有关系模式W(C，P，S，G，T，R)，其中各属性的含义是：C为课程，P为教师，S为学生，G为成绩，T为时间，R为教室，根据定义有如下函数依赖集：F＝{C→G，SC→G，TR→C，TP→R，TS→R},下面哪个是W的关键字 <strong>D</strong><br>A．SC   B．TR    C．TP    D．TSP</p>
</li>
<li><p>如果事务T对数据D已加S锁，则其他事务对数据D加什么锁？ <strong>A</strong><br>A. 可以加S锁，不能加X锁<br>B. 可以加S锁，也可以加X锁<br>C. 不能加S锁，可以加X锁<br>D. 不能加任何锁</p>
</li>
<li><p>数据库中一个事务的执行，要么全部完成，要么全部不做，一个事务中对数据库的所有操作都是一个不可分割的操作序列的属性是指事务的哪个特性。  <strong>A</strong><br>A. 原子性    B. 一致性<br>C. 独立性    D. 持久性</p>
</li>
<li><p>SQL中，下列判断age是否为空值的操作，不正确的是 <strong>C</strong><br>A. AGE IS NULL<br>B. AGE IS NOT NULL<br>C. AGE = NULL<br>D. NOT (AGE IS NULL)</p>
</li>
<li><p>如果有两个关系T1,T2.客户要求每当从T2中删除一条记录时,T1中特定记录就需要被改变,我们需要定义什么来满足该要求. <strong>D</strong><br>A.在T1上定义视图        B.在T2上定义视图<br>C.在T1和T2上定义约束        D.定义trigger</p>
</li>
<li><p>我感觉是C</p>
</li>
<li><p>在DBMS中执行GRANT REFERENCES(col1) ON TABLE t1 TO user user7,对于该语句下面哪个描述是正确的: <strong>C</strong><br>A.user7可以在t1上定义视图<br>B.user7可以更新t1中的col1属性的值<br>C.user7在创建其他表时可以定义参考于t1中col1属性的外关键字<br>D.user7可以在t1中定义外关键字.</p>
</li>
</ol>
<p>16.有一个关系模式employee(name,department,phone_number),下面哪句话允许user1可以修改phone_number列的值 <strong>C</strong><br>A. GRANT INDEX (phone_number) ON TABLE employee TO user1<br>B. GRANT ALTER (phone_number) ON TABLE employee TO user1<br>C. GRANT UPDATE (phone_number) ON TABLE employee TO user1<br>D. GRANT REFERENCES (phone_number) ON TABLE employee TO user1</p>
<p>17.一个企业提供了一个查询数据库,该数据库的数据可以很容易的重新构造.为了提供数据库中磁盘数据的访问速度,下面磁盘技术<br>中采用哪种方法可以满足该要求: <strong>A</strong><br>A. RAID 0        B.RAID 1<br>C. RAID 0+1        D.RAID 5</p>
<ol start="18">
<li>以下哪种情况会发生丢失更新？ <strong>A</strong><br>A. 一个事务读取了相同的数据记录两次，并且每次都返回不同的数据值<br>B. 在一个事务期间，基于特定标准的搜索在执行连续搜索之后返回额外的行<br>C. 返回了未落实的数据，但产生这些数据的事务已回滚<br>D. 两个事务读取并试图更新相同的数据，第二次更新将在第一次更新落实之前将其覆盖。<blockquote>
<p>A是 可重复读?<br>D什么意思?</p>
</blockquote>
</li>
</ol>
<ol start="19">
<li><p>在开发数据库应用软件时，应用中事务的默认隔离级是： <strong>B</strong><br>A．Read Uncommitted      B. Read Committed<br>C.  Repeatable Read        D. Serializable</p>
</li>
<li><p>铁路售票系统要求客户在订票前可以允许客户查询但客户上次的查询结果必须出现在下次查询中,在售票系统中的事务隔离级至</p>
</li>
</ol>
<p>少应该是: <strong>C</strong><br>A. Read Uncommitted  B Read Committed<br>C. Repeatable Reads   D. Serializable</p>
<p>解答题:<br>有关系模式Sailors(sid:char(10),sname:char(20),rating:int,age:int),其中sid是主关键字，sid表示水手的编号，sname表示水手的姓名，rating表示水手的级别，age表示水手的年龄。Boats(bid:char(10),bname:char(20),color:char(10)),其中bid表示船的编号是主关键字，bname是船的名字，color是船的颜色。Reserves(sid:char(10),bid:char(10),rdate:date),Reserves中记录水手在哪天定了那只船，其中sid是指向Sailors的外关键字,bid是指向Boats的外关键字,(sid,bid,rdate)合起来构成Reserves的主关键字。</p>
<p>请用关系代数表示下列查询：<br>1.查找至少定过两艘不同的船的水手编号。（5分）</p>
<p>select sid<br>from sailors s,boats b,reserves r<br>where s.sid = r.sid<br>      b.bid = r.bid<br>现在只找到了某个水手定过什么船</p>
<p>2.查找水手中年龄最大的水手编号。 （5分）</p>
<p>where age = MAX(age)</p>
<p>请用SQL语句表示下列查询：<br>3.查找所有水手的定船信息，并将结果按水手编号和船的编号排序（水手编号相同再排船的编号）。（5分）</p>
<p>4.删除名字叫lubber的水手的定船信息。（5分）</p>
<p>5.查找定了103号船的水手的详细信息。（4分）</p>
<p>6.查找级别最高的水手中年龄最小的水手编号。（6分）</p>
<p>7.根据下面的要求创建学生表  （5分）<br>某学院需要完成一个学生选课及成绩管理系统，该系统要求能够登记，修改，查询，统计学生、课程、选课的基本信息。学生的基本信息包括：学号(sid:char(10))，姓名(name:char(10))，性别(gender:char(2))，入学年份(grade:char(4)）。课程的基本信息包括：课程编号(cid:char(10))，课程名称(cname:char(10))，学分(credit:char(10))。选课信息：学生学号(sid:char(10))，课程号(cid:char(10))，选课年份(years:char(4))，成绩 (mark:int)。要求学生基本信息中性别的可选着值只能是（男或女），所有的学生在2014年全部都要选课。<br>添加约束check<br>gender = ‘y’or’n’<br>years &lt;= 2014</p>
<p>8.设有关系模式R(A，B，C，D)，其上的函数依赖集：F＝{A→C，C→A，B→AC，D→AC}  （15分）<br>(1).计算(AD)+。      （2分）</p>
<p>ADC</p>
<p>(2).求F的函数依赖最小等价依赖集。   （5分） </p>
<p>A C<br>C A<br>B A<br>D A</p>
<p>(3).求R的一个关键字。 （3分）</p>
<p>BD 的 闭包是 ABCD</p>
<p>(4).将R分解成满足3NF并具有无损连接性与保持依赖性。（5分）</p>
<h3 id="2015-2016"><a href="#2015-2016" class="headerlink" title="2015-2016"></a>2015-2016</h3><ol>
<li><p>下面关于关键字描述不正确的是: D<br>A.在表中可以通过关键字唯一的确定一条记录. B.关键字可以由多个属性组成.<br>C.组成关键字的属性值可以为空. D.一个表中可以有多个关键字</p>
</li>
<li><p>下面关于外关键字描述不正确的是  C<br>A.外关键字必须是所参考表的主关键字.<br>B.外关键字属性值这可以为空<br>C.定义外关键字需要对所参考表拥有 select 权<br>D.一个表中可以有多个外关键字.</p>
</li>
<li><p>有关系模式 R(A,B,C,D,E),R 的函数依赖集 F={A-&gt;B,BC-&gt;E,ED-&gt;A},下面哪个说法是正确的:<br>A.R 是 BCNF    B.R 是 3NF<br>C.分解(ACD,BCE)是无损分解    D.分解(ABD,CDE)是无损分解</p>
</li>
<li><p>下面哪个隔离级在读的时候不给任何数据加读锁的是：A?<br>A.Read Uncommitted    B. Read Committed<br>C. Repeatable Read    D. Serializable</p>
</li>
</ol>
<ol start="5">
<li><p>JDBC 有几种驱动类型:   C<br>A.5    B.2<br>C.4    D.1</p>
</li>
<li><p>下面关于数据库事务处理描述正确的是:<br>A.原子性和一致性是由数据库的并发调度保证的.<br>B.隔离性和持久性是由数据库的并发调度保证的.<br>C.原子性和持久性是由数据库的 log 机制保证的<br>D.一致性和隔离性是由数据库的 log 机制保证的</p>
</li>
<li><p>下面说法正确的是:<br>A.在一个表上一个事物加上 IS 锁时而另外一个事物同时也可以加上 X 锁。<br>B.在一个表上一个事物加上 IX 锁时而另外一个事物同时也可以加上 X 锁。<br>C.在一个表上一个事物加上 IX 锁时而另外一个事物同时也可以加上 IS 锁。<br>D.在一个表上一个事物加上 IX 锁时而另外一个事物同时也可以加上 S 锁。</p>
</li>
<li><p>下面哪个调度是冲突可串行化的调度<br>A. T1:R(X),T2:R(X),T1:W(X),T2:W(X)<br>B. T1:W(X),T2:R(Y),T1:R(Y),T2:R(X)<br>C. T1:R(X),T1:R(Y),T1:W(X),T2:R(Y),T3:W(Y),T1:W(X),T2:R(Y)<br>D. T1:W(X),T2:R(X),T1:W(X),T2:Abort,T1:Commit</p>
</li>
<li><p>下面哪个调度不是可串行化的调度<br>A.T1:R(X), T2:R(Y), T3:W(X), T2:R(X), T1:R(Y)<br>B.T1:R(X), T2:W(X), T1:W(X), T2:Abort, T1:Commit<br>C.T1:R(X), T2:W(X), T1:W(X), T2:Commit, T1:Commit<br>D.T1:R(X), T2:W(X), T1:W(X), T2:Commit, T1:Commit</p>
</li>
<li><p>下面哪个调度是串行调度:<br>A. T1:R(A),T2:R(B),T2:W(B),T1:W(A)<br>B. T2:R(B),T2:W(B),T1:R(A),T1:W(A)<br>C. T1:R(A),T2:R(B),T1:W(A),T2:W(B)<br>D. T2:R(A),T1:R(B),T2:W(A),T1:W(B)</p>
</li>
<li><p>在遵循严格 2PL 锁的规则的情况下，下面哪个调度会出现死锁: A.T1:R(X),T2:W(X),T2:W(Y),T3:W(Y),T1:W(Y)<br>B T1:R(X),T2:W(Y),T2:W(X),T3:W(Y),T1:W(Y),<br>C T1:R(A),T2:W(B),T1:R(A),T3:R(C),T2:W(C),T4:W(A)<br>D.T1:R(A),T2:W(B),T3:W(C),T1: Commit,T2:W(A), T2:Commit,T3:W(B), T3:Commit</p>
</li>
<li><p>数据库中 SAILORS 表是由 joe 创建的，.在 DBMS 完成下面的语句后<br>Grant select on Sailors to Art with grant option–Joe 执行<br>Grant Insert on Sailors To Bob With Grant option—Joe 执行<br>Grant select on sailors to Bob with grant option–Art 执行<br>Grant select on sailors to Art with grant option –Bob 执行<br>Grant select on sailors to Cal with grant option-Joe 执行<br>Grant select on sailors to Bob with grant option-Cal 执行<br>Revoke select on Sailors From Art CASCADE–Joe 执行<br>Bob 对 Sailors 表拥有什么权利？<br>A. Insert 权    B. Update 权<br>C.没有任何权利    D.Insert 和Select  权</p>
</li>
<li><p>在一个隔离级为可重复读的事物中执行 select * from sailors where sid=9 查询后，对该事物在数据库中获得的锁下面哪个描述是最准确的？<br>A.获得 sailors 表的 S 锁<br>B.获得 sailors 表的 IS 锁及所有 sid 为 9 的记录上的 IS 锁<br>C.获得 sailors 表的 S 锁及所有 sid 为 9 的记录上的 IS 锁<br>D.获得 sailors 表的 IS 锁及所有 sid 为 9 的记录上的 S 锁</p>
</li>
<li><p>以下哪种情况会发生幻影问题？<br>A.一个事务先后执行多次相同条件的查询，并且每次返回的数据都不相同。<br>B.在一个事务期间，基于特定标准的搜索在执行连续搜索之后返回额外的行<br>C.返回了未落实的数据，但产生这些数据的事务已回滚<br>D.两个事务读取并试图更新相同的数据，第二次更新将在第一次更新落实之前将其覆盖</p>
</li>
<li><p>有关系模式 R(A,B,C,D,E),R 的函数依赖集 F={A-&gt;BC,CB-&gt;E,B-&gt;D,E-&gt;A}下面哪个分解具有无损连接性<br>A. (A,C,E),(B,C,D)    B. (A,C,D),(A,B,E)<br>C. (A,C,E),(A,E,D)    D. (A,B,D),(A,C,D)</p>
</li>
<li><p>在大部分的 DBMS 中，我们在一个关系上<br>A.只能定义一个外关键字    B.只能创建一个聚集索引(cluster index) C.只能创建一个唯一索引    D.只能定义一个约束.</p>
</li>
<li><p>关于视图的描述下面说法哪些是正确的:<br>A.数据库只存储视图的定义.B.数据库为视图另外保存数据C.视图都是可更新的    D.视图只能在一个关系上创建</p>
</li>
<li><p>在数据库中存储的是<br>A．数据    B．数据模型<br>C．数据以及数据之间的联系    D．信息</p>
</li>
<li><p>当一个关系模式 R（A，B）已属于 3NF，下列说法中正确的。A．它一定消除冗余    B．可能存在一定冗余<br>C．一定属于 BCNF    D．A 和 C 都是</p>
</li>
</ol>
<p>有关系 模式    students(sid:    char(10),sname:    char(20),age:    int,    department:    char(10), grade:char(5), gpa:float)， sid 表示学生的学号，sname 为学生的姓名，age 为学生的年龄， department 为学生所在学院，grade 为学生的年级，gpa 为学生成绩的加权平均值，sid 为主关键字。</p>
<ol start="21">
<li><p>下面哪些查询能够查出年龄最大的学生的姓名，并显示该学生的年龄。<br>A.select s.sname, max(s.age) from students<br>B.select s.sname, s.age from students s where s.age &gt;all(select s2.age from students s2)<br>C.select s.sname, s,age from students s where s.age=(select max(s2.age) from students s2)<br>D.select s.sname, s.age from students s where s.age &gt;=any(select s2.age from students s2)</p>
</li>
<li><p>一个企业有大量的数据需要存储在数据库中,企业要求数据的稳定性存储和数据快速访问,但不想使用太多的磁盘进行冗余存储,下面磁盘技术中采用哪种方法可以满足该要求:<br>A. RAID 0    B.RAID 1<br>C. RAID 0+1    D.RAID 5</p>
</li>
<li><p>关 系 模 式 R,R 的 属 性 集 是 {ABCDEG} 有 函 数 依 赖 集<br>F={AB-&gt;C,D-&gt;EG,C-&gt;A,BE-&gt;C,BC-&gt;D,CG-&gt;BD,CE-&gt;AG}计算(BE)的属性闭包.<br>A.    BDEG    B.    BDC<br>C.    ABCDEG    D.    ABCD</p>
</li>
<li><p>T1 表中有 100 万条记录，为了加快 select c1,c2 from t1 where c2&gt;100 查询速度，定义下列哪个索引最为合适？<br>A.create index ind1 on t1(c2)<br>B.create unique index ind2 on t1(c2)<br>C.create cluster index ind3 on t1(c2)<br>create index ind4 on t1(c2) include(c1)</p>
</li>
</ol>
<p>25．下面哪个说法符合数据库系统 WAL(log 先写协议):<br>A.数据库缓存中被事务修改的页面在事务成功完成时被强制写到磁盘中B.数据库缓存中被事务修改的页面在事务撤销时被写到标记为非脏页 C.事务成功完成时必须将与其相关的 log 页面强制写回磁盘<br>D.数据库缓存中被事务修改的页面在事务撤销时将该事物修改的数据恢复成被修改前的值</p>
<p>二．简答题（每题 5 分，共 50 分）<br>在 mysql 中有 club 数据库，该数据库中有四个表分别是：<br>Sailors(sid char(10),sname char(20),rating int,age int，gender char(2)),其中 sid 是主关键字， sid 表示水手的编号，sname 表示水手的姓名，rating 表示水手的级别，age 表示水手的年龄,gender 表示水手的性别。<br>Boats(bid char(10),bname char(20),color char(10)，),其中 bid 表示船的编号是主关键字，<br>bname 是船的名字，color 是船的颜色<br>Reserves(sid char(10),bid char(10),rdate date),Reserves 中记录水手在哪天订了那只船，其中sid 是指向 Sailors 的外关键字，bid 是指向 Boats 的外关键字,(sid,bid,rdate)合起来构成Reserves 的主关键字。<br>YangSailors(sid char(10),sname char(20),rating int,age int),其中 sid 是主关键字，sid 表示水手的编号，sname 表示水手的姓名，rating 表示水手的级别，age 表示水手的年龄。<br>用关系代数写出下面的查询</p>
<ol>
<li>查找性别为男的水手中级别最高的水手的姓名及编号</li>
</ol>
<p>用元组关系验算写出下面的查询<br>2. 订过所有船的水手的姓名及编号</p>
<p>用 SQL 写出下列查询<br>3. 查找至少定过两艘不同的船的水手编号和姓名</p>
<ol start="4">
<li>查找没有定过船的水手消息（sid，sname，rating，age）</li>
</ol>
<ol start="5">
<li>将水手的级别分为初级，中级，高级,其中初级表示为 rating &lt;=3,中级表示为 rating &gt;3 and rating &lt;=9,高级表示为 rating&gt;10.统计这三个级别（初，中，高）中水手的人数。 </li>
</ol>
<ol start="6">
<li>统计每个水手订船的次数，并按订船次数降序排序</li>
</ol>
<ol start="7">
<li>在 club 数据库中定义一个合适的对象，能够实现下面的功能<br>当使用 insert 语句对 sailors 表插入记录时如果某些记录的 age 值小于 19，同时将这些 age<br>小于 19 的记录插入到 yangsaliors 表中。</li>
</ol>
<ol start="8">
<li>简述 DBMS 中堆文件的中包含变长记录的数据页的组成格式</li>
</ol>
<p>9.函数依赖公理即 Armstrong 公理表示如下：<br>设有关系模式 R(A1,A2,A3,….,An)和属性全集 U=A1A2…An。X，Y，Z 均为 U 的非空子集，F 是 R 的函数依赖集。<br>A1：若Y  X ，则 XY.<br>A2：若 XY,则 XZYZ A3:若 XY,YZ 则 XZ 请证明 A3 公理    (5 分)</p>
<p>10.有    关    系    模    式    R(A,B,C,D,E,G),    其    函    数    依    赖    集    F={B-&gt;D    ，<br>DG-&gt;C,BD-&gt;E,AG-&gt;B,ADG-&gt;BC}，求该函数依赖集的最小集</p>
<h4 id="数据库语言SQL"><a href="#数据库语言SQL" class="headerlink" title="数据库语言SQL"></a>数据库语言SQL</h4><p>select L (表达式列表)<br>from R (关系)<br>where C (条件)</p>
<ul>
<li><p>投影 </p>
</li>
<li><p>选择 </p>
</li>
<li><p>模式匹配</p>
<ul>
<li>s LIKE p (p是模式)<br>_表示可匹配一个字符<br>%表示可匹配任何形式字符串</li>
</ul>
</li>
<li><p>输出排序<br>在select-from-where语句后加上<br>order by <list of attributes> (默认序是升序)<br>DESC(表示降序),  ASC(表示升序,可省略)</p>
</li>
<li><p>SQL中的积和连接</p>
</li>
<li><p>消除属性歧义<br>A.a B.a</p>
</li>
<li><p>元组变量<br>A as A</p>
</li>
<li><p>多关系查询的解释</p>
<ul>
<li>嵌套循环</li>
<li>并行赋值</li>
<li>转换为关系代数</li>
</ul>
</li>
<li><p>查询的并,交,差(查询应该分别用括号括起来)</p>
<ul>
<li>UNION ∪</li>
<li>INTERSECT ∩</li>
<li>EXCEPT -</li>
</ul>
</li>
<li><p>子查询</p>
<ul>
<li>产生标量值得子查询</li>
<li>关系得条件表达式<ul>
<li>EXISTS R</li>
<li>s IN R</li>
<li>s &gt; ALL</li>
<li>s &gt; ANY</li>
</ul>
</li>
<li>元组的条件表达式</li>
<li>关联子查询</li>
<li>FROM子句中的子查询</li>
<li><strong>SQL的连接表达式</strong><ul>
<li>cross join 交叉连接</li>
<li>join R on θ连接 </li>
<li>natural join R 自然连接 </li>
<li>natural full outer join 外连接<br>natural left outer join<br>natural right outer join</li>
</ul>
</li>
</ul>
</li>
<li><p>全关系操作</p>
<ul>
<li><p>消除重复<br>SELECT DISTINCT (实际上从关系中消除重复的代价非常昂贵)</p>
</li>
<li><p>并,交,差<br>若要消除重复元组,必须在UNION,INTERSECT和EXCEPT后跟上保留字ALL即可<br>如: R intersect all S</p>
</li>
<li><p>聚集操作符</p>
<ul>
<li>SUM</li>
<li>AVG</li>
<li>MIN</li>
<li>MAX</li>
<li>COUNT </li>
</ul>
</li>
<li><p>分组 GROUP BY name</p>
</li>
<li><p>分组,聚集和空值<br>空值不对求和,取平均和计数做贡献,也不能是列的最大值或最小值</p>
</li>
<li><p>HAVING子句</p>
</li>
</ul>
</li>
<li><p>数据库更新</p>
<ul>
<li>插入<br>insert into R(A1,A2…An) values (v1,v2…vn);</li>
<li>删除<br>delete from R where &lt;条件&gt;;</li>
<li>修改<br>update R set&lt;新值赋值&gt; where &lt;条件&gt;;<br>||运算符表示字符串的连接</li>
</ul>
</li>
<li><p>SQL中的事务</p>
<ul>
<li>可串行化</li>
<li>原子性</li>
<li>事务<ul>
<li>START TRANSACTION可用来标记事务的开始</li>
<li>SQL语句COMMIT使得事务成功结束.</li>
<li>SQL语句ROLLBACK使得事务夭折或不成功结束,任何由该事务的SQL语句所引起的修改都被撤销,即它们被回滚 rooled back, </li>
</ul>
</li>
<li>只读事务 (即它不会修改数据库,)<br>SET TRANSACTION READ ONLY<br>这条语句必须在事务开始之前执行.可以通过如下语句通知SQL下一个事务可以写数据:<br>SET TRANSACTION READ WRITE;<br>不过,这个选项是默认选项</li>
<li>读脏数据<ul>
<li>脏数据: Dirty data 是表示还没有提交的事务所写的数据的通用术语</li>
<li>脏读 : 是对脏数据的读取</li>
<li>SQL允许指定一个给定的事务是否可以脏读:<br>  SET TRANSACTION READ WRITE<pre><code>ISOLATION LEVEL READ UNCOMMITTED;</code></pre>  上述语句做了两件事:<ol>
<li>第一行声明事务可以写数据</li>
<li>第二行声明事务用读未提交的”隔离层次”运行,即允许事务读脏数据    </li>
</ol>
</li>
</ul>
</li>
<li>其他隔离层次<ul>
<li>可串行化<br>SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;默认的;</li>
<li>读未提交(脏读)</li>
<li>读提交<br>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</li>
<li>可重复读<br>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;<h4 id="事务其他相关"><a href="#事务其他相关" class="headerlink" title="事务其他相关"></a>事务其他相关</h4></li>
</ul>
</li>
</ul>
</li>
<li><p>共享锁和排他锁</p>
</li>
<li><p>日志的flush,书上例子，output</p>
</li>
</ul>
<h4 id="约束与触发器"><a href="#约束与触发器" class="headerlink" title="约束与触发器"></a>约束与触发器</h4><ul>
<li><p>键和外键</p>
<ul>
<li><p>外键声明隐含的两层意思</p>
</li>
<li><p>两种声明外键的方法<br>a) 在属性的名字和类型后加 references &lt;表名&gt; (&lt;属性名&gt;)<br>b) create table语句的属性列表上追加一个或多个声明<br>foreign key (&lt;属性名列表&gt;) reference &lt;表名&gt; (&lt;属性名列表&gt;)</p>
</li>
<li><p>维护引用完整性</p>
<ul>
<li>缺省原则</li>
<li>级联原则</li>
<li>置空值原则<br>ON DELETE SET NULL<br>ON UPDATE CASCADE</li>
</ul>
</li>
<li><p>延迟约束检查<br>创建表时候在外键后添加缺省<br>DEFERRABLE<br>NOT DEFERRABLE<br>后可有<br>INITIALLY DEFERRED 检查仅被推迟到事务提交前执行,<br>或 INITIALLY IMMEDIATE 选项. 检查在每个语句后都立即被执行<br>SET CONSTRAINT Myconstraint deferred</p>
</li>
</ul>
</li>
<li><p>属性和元组上的约束</p>
<ol>
<li>在单一属性上的约束</li>
<li>在整个元组上的约束</li>
</ol>
<ul>
<li>非空值约束</li>
<li>基于属性的CHECK约束</li>
<li>基于元组的CHECK约束</li>
</ul>
</li>
<li><p>修改约束</p>
<ul>
<li>给约束命名<br>在约束前加保留字CONSTRAINT和约束的名字</li>
<li>修改表上的约束</li>
</ul>
</li>
<li><p>断言 : </p>
<ul>
<li><p>创建断言<br>CREATE ASSERTION &lt;断言名&gt; CHECK (&lt;条件&gt;)</p>
</li>
<li><p>使用断言</p>
</li>
<li><p>删除断言<br>DROP ASSERTION (&lt;断言名&gt;)</p>
</li>
</ul>
</li>
<li><p>触发器<br>  有事也称为 事件-条件-动作规则.或者ECA规则</p>
<ul>
<li>SQL中的触发器<ul>
<li>主要特征 : </li>
</ul>
</li>
<li>触发器设计的选项<h4 id="视图与索引"><a href="#视图与索引" class="headerlink" title="视图与索引"></a>视图与索引</h4></li>
</ul>
</li>
<li><p>虚拟视图 </p>
<ul>
<li>视图的定义:<br>CREATE VIEW &lt;视图名&gt; AS &lt;视图定义&gt;<br>视图定义是一个SQL查询</li>
<li>视图查询</li>
<li>属性重命名</li>
</ul>
</li>
<li><p>视图更新</p>
<ul>
<li><p>视图删除<br>DROP VIEW ParamountMovies<br>删除视图不会影响基本关系Movies<br>但是删除表MOVIES 不但使得表Movies 从此消失,也使得视图不可用</p>
</li>
<li><p><strong>可更新视图</strong><br>  该视图是由单个关系R选取出得一些元素组成</p>
<ul>
<li>WHERE 子句在子查询中不能使用关系R</li>
<li>FROM语句只能包含一个关系R,不能再有其他关系</li>
<li>SELECT语句中的属性列表必须包括足够多的属性,以保证对该视图进行元组插入时,能够用NULL或者适当的默认值来填充所有其他不属于该视图的属性.<br>比如,SELECT语句中不允许包括被定义为非空或者没有默认值的属性.</li>
</ul>
</li>
<li><p>视图中的替换触发器<br>  可以用INSTEAD OF 代替BEFORE,AFTER</p>
</li>
</ul>
</li>
<li><p>索引:<br>  一个表最多建一个索引</p>
<ul>
<li>定义:关系中属性A的索引时一种数据结构,他能提高在属性A上查找具有某个特定值的元组的效率.</li>
<li>建立索引的动机<br>当关系变得很大时,通过扫描关系中所有的元组来找出那些匹配给定查询条件的元组的代价太高.</li>
<li>索引的声明<br>  CREATE INDEX 索引名 ON movies(year,title);<br>  DROP INDEX 索引名.</li>
</ul>
</li>
<li><p>索引的选择<br>  索引的选择时衡量数据库设计成败的一个重要因素.</p>
<ul>
<li><p>设计索引主要考虑两个因素:<br>  1)如果属性上存在索引,则为该属性指定一个值或者取值范围能极大地提高查询的执行效率.同样,如果查询涉及该属性上的连接操作,也能带来性能上的改善</p>
</li>
<li><p>另一方面,为关系上的某个属性或者某个属性集建立的索引会使得对关系的插入,删除,和修改变得更复杂和更费时.</p>
</li>
<li><p>简单代价模型</p>
</li>
<li><p>一些有用的索引:</p>
</li>
</ul>
<ol>
<li>在查询中未主键指定值时比较普遍的,因此键上的索引通常会被频繁地使用</li>
<li>因为键值时唯一的,故与给定键值匹配的元组最多只有一个,因为索引返回的要么是这个元组的位置,要么什么也不返回.<ul>
<li>存在两种情况,即使不是建立在键属性上的索引页仍然有效<br>几乎可以看成是键<br>元组在该属性上是聚集的.</li>
</ul>
</li>
</ol>
<ul>
<li>计算最佳索引</li>
<li>所以的自动选择</li>
</ul>
</li>
<li><p>物化视图(不考) </p>
</li>
</ul>
<h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程 :"></a>存储过程 :</h4><ul>
<li><p>创建PSM函数和过程</p>
<ul>
<li>过程声明要素:<br>CREATE PROCEDURE &lt;名字&gt; (&lt;参数&gt;)<br>  &lt;局部声明&gt;<br>  &lt;过程体&gt;;</li>
<li>函数定义的要素:<br>CREATE FUNCTION &lt;名字&gt; (&lt;参数&gt;) RETURNS &lt;类型&gt;<br>  &lt;局部声明&gt;<br>  &lt;函数体&gt;;</li>
<li>参数是 模式-名字-类型<br>例如: IN oldAddr VARCHAR(255)</li>
</ul>
</li>
<li><p>PSM中的简单语句格式</p>
<ul>
<li>调用语句<br>CALL &lt;过程名&gt; (&lt;参数&gt;)</li>
<li>返回语句</li>
<li>局部变量声明<br>declare &lt;名字&gt;&lt;类型&gt;;</li>
<li>赋值语句<br>set &lt;变量&gt;=&lt;表达式&gt;;</li>
<li>语句组<br>begine…end</li>
<li>语句标号<br>用名字(标号名)和冒号作为前缀来标识语句</li>
</ul>
</li>
<li><p>分支语句</p>
<ul>
<li>用保留字END IF结束</li>
<li>嵌套在if语句中的else子句以单词ELSEIF开始</li>
</ul>
</li>
<li><p>PSM中的查询</p>
<ul>
<li>声明和使用游标<br>a)语句中不出现EXEC SQL<br>b)局部变量不适用冒号前缀</li>
</ul>
</li>
<li><p>PSM中的循环<br>LOOP<br>  &lt;语句列表&gt;<br>END LOOP;<br>中断循环: LEAVE&lt;循环标识&gt;</p>
</li>
<li><p>for 循环</p>
</li>
<li><p>PSM中的异常处理</p>
</li>
<li><p>使用PSM函数和过程</p>
<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4></li>
<li><p>九种类型的权限:</p>
<ul>
<li>select,insert,delete,update 应用到关系上</li>
<li>reference权限是指在完整性约束下引用关系的权力</li>
<li>usage 关系和断言之外的多种模式元素上.</li>
<li>trigger 触发器的权限</li>
<li>execute PSM过程或函数之类的代码权限</li>
<li>under 创建给定类型的子类型权限</li>
</ul>
</li>
<li><p>创建权限</p>
</li>
<li><p>检查权限的过程</p>
</li>
<li><p>授权<br>授权语句的格式如下:<br>GRANT &lt;权限列表&gt; ON &lt;数据库元素&gt; TO &lt;用户列表&gt;<br>其后可以加上with grant option.<br>ALL PRIVILEGES可能在这里出现 </p>
</li>
<li><p><strong>授权图</strong></p>
</li>
<li><p>收权<br>  REVOKE &lt;权限列表&gt; ON &lt;数据库元素&gt; FROM &lt;用户列表&gt;</p>
<ul>
<li>CASCADE</li>
<li>RESTRICT\ <h4 id="其他部分"><a href="#其他部分" class="headerlink" title="其他部分:"></a>其他部分:</h4></li>
</ul>
</li>
<li><p>数据库教父—-E.F.Codd<br>关系层次模型提出?</p>
</li>
<li><p>DBMS:数据库管理系统(Database Management System)是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS</p>
</li>
<li><p>DBA : 数据库管理员（Database Administrator，简称DBA），是从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称</p>
</li>
<li><p>关系规范性算法（闭包，函数依赖的投影，BC范式的分解<br>2范式消除了部分依赖，1范式:原子非多值<br>3范式消除了传递依赖</p>
</li>
<li><p>函数依赖集合，不是关系R的键：算闭包</p>
</li>
<li><p>BC范式能否保持无损连接，三范式</p>
</li>
<li><p>分关系代数（注意不是sql语句）<br>关系代数表示约束，用两种方式表达，等于空集或者属于</p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_37799190/article/details/79418322" target="_blank" rel="noopener">规范化理论</a></p>
</li>
<li><p>给一个调度（并行化，并发控制）</p>
</li>
<li><p>什么叫做冲突的（两个事务对同一个对象的写操作（至少一个）</p>
</li>
<li><p>如何判断调度是不是可串行化的（画优先图）；</p>
</li>
<li><p>关于日志恢复的问题，日志分三种类型，考undo，redo日志，</p>
</li>
<li><p>写出数据库的恢复子系统，恢复的过程，以及恢复之后是什么样子；</p>
</li>
<li><p>两阶段锁协议，书上例题，保证不会发生死锁；</p>
</li>
</ul>
<h4 id="数据库恢复技术"><a href="#数据库恢复技术" class="headerlink" title="数据库恢复技术"></a>数据库恢复技术</h4><h5 id="事务的基本概念"><a href="#事务的基本概念" class="headerlink" title="事务的基本概念"></a>事务的基本概念</h5><ul>
<li><p>1.定义：<br>   一个数据库操作序列<br>   一个不可分割的工作单位<br>   恢复和并发控制的基本单位</p>
</li>
<li><p>2.显示定义方式：<br>  COMMIT</p>
<ul>
<li><p>事务正常结束</p>
</li>
<li><p>提交事务的所有操作</p>
</li>
<li><p>事务中所有对数据库的更新写回磁盘上的物理数据库中.</p>
<p>ROLLBACK</p>
</li>
<li><p>事务异常终止</p>
</li>
<li><p>事务运行的过程中发生了故障,不能继续执行</p>
</li>
<li><p>系统将事务中对数据库的所有已完成的操作全部撤销</p>
</li>
<li><p>事务滚回到开始时的状态</p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">BEGIN TRANSACTION</th>
<th align="center">BEGIN TRANSACTION</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SQL语句1</td>
<td align="center">SQL语句1</td>
</tr>
<tr>
<td align="center">SQL语句2</td>
<td align="center">SQL语句2</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">COMMIT</td>
<td align="center">ROLLBACK</td>
</tr>
</tbody></table>
<ul>
<li><p>3.隐式定义：<br>当用户没有显式地定义事务时，DBMS按缺省规定自动划分事务</p>
</li>
<li><p>4.事务的特性（ACID特性)</p>
<ul>
<li>原子性 (Atomicity)</li>
<li>一致性 (Consistency)</li>
<li>隔离性 (Isolation)</li>
<li>持续性 (Durability)<blockquote>
<ul>
<li>保证事务ACID特性是事务管理的重要任务。</li>
<li>事务ACID特性可能遭到破坏的因素是：<br>1)多个事务并行运行时，不同事务的操作交叉执行<br>2)事务在运行过程中被强行终止</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>数据库管理系统要解决的问题：</p>
<ul>
<li><p>必须保证多个事务的交叉运行不影响这些事务的原子性</p>
</li>
<li><p>必须保证被强行终止的事务对数据库和其他事务没有任何影响</p>
</li>
<li><p>这两个问题就是数据库管理系统的恢复机制和并发控制机制的责任</p>
<h5 id="数据库恢复概述"><a href="#数据库恢复概述" class="headerlink" title="数据库恢复概述"></a>数据库恢复概述</h5></li>
<li><p>故障时不可避免</p>
<ul>
<li>计算机硬件故障</li>
<li>软件的错误</li>
<li>操作员的失误</li>
<li>恶意的破坏</li>
</ul>
</li>
<li><p>故障的影响</p>
<ul>
<li>运行事务非正常中断,影响数据库中数据的正确性</li>
<li>破坏数据库,全部或部分丢失数据</li>
</ul>
</li>
<li><p>数据库的恢复</p>
<blockquote>
<p>DBMS把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态)的功能,这就是数据库的恢复管理系统对故障的对策</p>
</blockquote>
</li>
<li><p>恢复子系统是数据库管理系统的一个重要组成部分</p>
</li>
<li><p>恢复技术是衡量系统优劣的重要指标</p>
</li>
</ul>
<h5 id="故障的种类"><a href="#故障的种类" class="headerlink" title="故障的种类"></a>故障的种类</h5><ul>
<li><p>1.事务内部的故障</p>
<blockquote>
<p>两个更新操作要么全部完成要么全部不做。否则就会使数据库处于不一致状态，例如只把账户甲的余额减少了而没有把账户乙的余额增加。在这段程序中若产生账户甲余额不足的情况，应用程序可以发现并让事务滚回，撤销已作的修改，恢复数据库到正确状态</p>
</blockquote>
</li>
<li><p>事务内部更多的故障是非预期的，是不能由应用程序处理的。</p>
<ul>
<li>运算溢出</li>
<li>并发事务发生死锁而被选中撤销该事务</li>
<li>违反了某些完整性限制而被终止等</li>
</ul>
</li>
<li><p>事务故障的恢复：撤消事务（UNDO）</p>
<ul>
<li>强行回滚事务</li>
<li>撤销该事务已经做出的任何对数据库的修改,使得该事务像根本没有启动一样.</li>
</ul>
</li>
<li><p>2.系统故障(软故障)<br>  指造成系统停止运转的任何事件，使得系统要重新启动</p>
<ul>
<li>特定类型的硬件错误（如CPU故障）</li>
<li>操作系统故障</li>
<li>DBMS代码错误</li>
<li>系统断电</li>
</ul>
</li>
<li><p>系统故障的影响</p>
<ul>
<li>整个系统的正常运行突然被破坏</li>
<li>所有正在运行的事务都非正常终止 (所有活跃事务都只运行了一部分,没有全部完成)</li>
<li>内存中数据库缓冲区的信息全部丢失(部分已完成事务更新后的数据还在缓存区,没有来得及刷到硬盘上,这些更新就丢失了)</li>
<li>不破坏数据库</li>
</ul>
</li>
<li><p>系统故障的恢复</p>
<ul>
<li>发生系统故障时，事务未提交 （恢复策略：强行撤消（UNDO）所有未完成事务）</li>
<li>发生系统故障时，事务已提交，但缓冲区中的信息尚未完全写回到磁盘上。（恢复策略：重做（REDO）所有已提交的事务）<blockquote>
<p>系统故障的恢复需要做两件事情:</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>1.撤销所有未完成的事务<br>2.重做所有已提交的事务</p>
<ul>
<li>介质故障（硬故障，指外存故障）<ul>
<li>磁盘损坏</li>
<li>磁头碰撞</li>
<li>瞬时强磁场干扰</li>
</ul>
</li>
<li>介质故障破坏数据库或部分数据库,并影响正在存取这部分数据的所有事务</li>
<li>截至故障比前两类故障的可能性小得多,但破坏性大得多</li>
<li>介质故障的恢复<ul>
<li>装入数据库发生介质故障前某个时刻的数据副本</li>
<li>重做自此时始的所有成功事务，将这些事务已提交的结果重新记入数据库</li>
</ul>
</li>
</ul>
<ol start="4">
<li>计算机病毒</li>
</ol>
<ul>
<li>故障小结<br>  对各类故障，对数据库的影响有两种可能性：<ul>
<li>数据库本身被破坏</li>
<li>数据库没有被破坏，但数据可能不正确，这是由于事务的运行被非正常终止造成的</li>
</ul>
</li>
<li>恢复操作的基本原理: 冗余<br>利用存储在系统别处的冗余数据来重建数据库中已被破坏或不正确的那部分数据</li>
<li>恢复的实现技术: 复杂</li>
</ul>
<p>问: 系统故障会导致什么问题?</p>
<h5 id="恢复的实现技术"><a href="#恢复的实现技术" class="headerlink" title="恢复的实现技术"></a>恢复的实现技术</h5><ul>
<li><p>恢复机制涉及到的关键：</p>
<ul>
<li>如何建立冗余数据<ul>
<li>数据转储</li>
<li>登陆日志文件</li>
</ul>
</li>
</ul>
</li>
<li><p>数据转储</p>
<ul>
<li>转储是指DBA将整个数据库复制到磁带或另一个磁盘上保存起来的过程</li>
<li>备用的数据成为后备副本或后援副本</li>
<li>数据库遭到破坏后可以将后备副本重新装入</li>
<li>重装后备副本只能将数据库恢复到转储时的状态</li>
<li>要想恢复到故障发生时的状态,必须重新运行自转储后的所有更新事务</li>
</ul>
</li>
<li><p>转储方法</p>
<ul>
<li>静态转储<ul>
<li>系统中无运行事务时进行的转储操作</li>
<li>转储期间不允许对数据库进行操作</li>
<li>转储开始时数据库处于一致性状态</li>
<li>得到的一定是一个数据一致性的副本<blockquote>
<p>优点:实现简单<br>缺点：</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>1.降低了数据库的可用性<br>2.转储必须等待正运行的用户事务结束<br>3.新的事务必须等转储结束</p>
<ul>
<li>动态转储<ul>
<li>转储操作与用户并发进行</li>
<li>转储期间允许对数据库进行存取或修改<blockquote>
<p>优点：</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>1.不用等待正在进行的事务结束<br>2.转储期间允许对数据库进行存取或修改<br>缺点：不能保证副本中的数据正确有效</p>
<ul>
<li><p>动态转储进行故障恢复<br>需要把动态转储期间各事务对数据库的修改活动登记下来，建立日志文件<br>后备副本加上日志文件才能把数据库恢复到某一时刻的正确状态</p>
</li>
<li><p>海量转储<br>每次转储全部数据库</p>
</li>
<li><p>增量转储<br>只转储上次转储后更新过的数据</p>
</li>
</ul>
<p>海量转储与增量转储的比较</p>
<blockquote>
<p>1.从恢复角度看，使用海量转储得到的后备副本进行恢复往往更方便<br>2.如果数据库很大，事务处理又十分频繁，则增量转储更有效<br><img src="https://img-blog.csdnimg.cn/20190603175459427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3ODY1OA==,size_16,color_FFFFFF,t_70" alt=""></p>
</blockquote>
<ul>
<li>登陆日志文件</li>
<li>1.日志文件<br>记录事务对数据库的更新操作文件</li>
<li>格式：<ul>
<li>以记录为单位的日志文件（事务标识，操作类型，操作对象，更新前数据的旧值，更新后数据的新值）</li>
<li>以数据为单位的日志文件（事务标识，被更新的数据块）</li>
</ul>
</li>
<li>内容：<ul>
<li>各个事务的开始标记</li>
<li>各个事务的结束标记</li>
<li>各个事务所有的更新操作</li>
</ul>
</li>
<li>作用：<ul>
<li>进行事务故障恢复</li>
<li>进行系统故障恢复</li>
<li>协助后备副本进行介质故障恢复</li>
</ul>
</li>
</ul>
<p>2.利用静态转储副本和日志文件进行恢复<br><img src="https://img-blog.csdnimg.cn/20190603180545304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3ODY1OA==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>对上图进行说明:</p>
<ol>
<li>系统在Ta时刻停止运行事务，进行数据库转储</li>
<li>在Tb时刻转储完毕，得到Tb时刻的数据库一致性副本</li>
<li>系统运行到Tf时刻发生故障</li>
<li>为恢复数据库，首先由DBA重装数据库后备副本，将数据库恢复到Tb时刻的状态</li>
<li>重新运行自Tb~Tf时刻的所有更新事务，把数据库恢复到故障发生前的一致状态</li>
</ol>
<ul>
<li>登记日志文件<br>基本原则：<blockquote>
<p>登记的次序严格按并行事务执行的时间次序<br>必须先写日志文件，后写数据库</p>
</blockquote>
</li>
</ul>
<h5 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h5><ul>
<li>事务故障的恢复<br>事务故障：事务运行至正常终止点前被终止<br>恢复方法：由恢复子系统利用日志文件撤销（UNDO）此事务已对数据库进行的修改</li>
</ul>
<p>注: 事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预</p>
<ul>
<li><p>恢复步骤:</p>
<ul>
<li>反向扫描文件日志（从后往前扫描），查找该事务的更新操作</li>
<li>对该事务的更新操作执行逆操作，即将日志记录中“更新前的值”写入数据库</li>
<li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。</li>
<li>如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。</li>
</ul>
</li>
<li><p>系统故障的恢复</p>
<ul>
<li>系统故障:<ul>
<li>未完成事务对 数据库的更新已写入数据库</li>
<li>提交事务对数据库的更新还留在缓存区没来得及写入数据库</li>
</ul>
</li>
<li>恢复方法:<ul>
<li>UNDO故障发生时未完成的事务</li>
<li>Redo已完成的事务<br>注:系统故障的恢复由系统在重新启动时自动完成，不需要用户干预</li>
</ul>
</li>
</ul>
</li>
<li><p>恢复步骤:</p>
<ul>
<li>正向扫描日志文件（1.将在故障发生前已经提交的事务加入重做（REDO）队列，这些事务既有begin transaction记录，也有commit记录；2.将在故障发生时未完成的事务加入撤销（Undo）队列，这些事务中只有begin transaction记录，无相应的commit记录）</li>
<li>撤销（Undo）队列事务进行撤销（Undo）处理（1.反向扫描日志文件，对每个undo事务的更新操作进行逆操作；2.将日志记录中“更新前的值”写入数据库）</li>
<li>对重做（Redo）队列事务进行重做（Redo）处理（1.正向扫描日志文件，对每个REDO事务重新执行登记的操作；2.将日志记录中“更新后的值”写入数据库）</li>
</ul>
</li>
<li><p>介质故障的恢复(需要DBA介入)</p>
</li>
</ul>
<ol>
<li>重装数据库</li>
<li>重做已完成的事务</li>
</ol>
<h5 id="具有检查点的回复技术"><a href="#具有检查点的回复技术" class="headerlink" title="具有检查点的回复技术"></a>具有检查点的回复技术</h5><ul>
<li><strong>解决问题</strong>：<ul>
<li>搜索整个日志将耗费大量的时间</li>
<li>REDO处理：重新执行，浪费了大量时间</li>
</ul>
</li>
<li><strong>解决方法</strong><ul>
<li>在日志文件中增加检查点记录</li>
<li>增加重新开始文件</li>
<li>恢复子系统在登录日志文件期间动态地维护日志<br><img src="https://img-blog.csdnimg.cn/20190603202218714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3ODY1OA==,size_16,color_FFFFFF,t_70" alt=""> </li>
</ul>
</li>
</ul>
<p>建立检查点：<br>恢复子系统可以定期或不定期地建立检查点,保存数据库状态<br>1.定期：按照预定的一个时间间隔，如每隔一小时建立一个检查点<br>2.不定期：按照某种规则，如日志文件已写满一半建立一个检查点<br>恢复:<br><img src="https://img-blog.csdnimg.cn/2019060320274211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3ODY1OA==,size_16,color_FFFFFF,t_70" alt="恢复"><br>nT1：在检查点之前提交</p>
<p>nT2：在检查点之前开始执行，在检查点之后故障点之前提交</p>
<p>nT3：在检查点之前开始执行，在故障点时还未完成</p>
<p>nT4：在检查点之后开始执行，在故障点之前提交</p>
<p>nT5：在检查点之后开始执行，在故障点时还未完成</p>
<ul>
<li>利用检查点的恢复步骤<ul>
<li>1.从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录</li>
<li>2.由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST<ul>
<li>建立两个事务队列<br>undo-list<br>redo-list<br>把ACTIVE-LIST暂时放入UNDO-LIST队列，REDO队列暂为空。</li>
</ul>
</li>
<li>3.检查点开始正向扫描日志文件，直到日志文件结束<br>  如有新开始的事务Ti，把Ti暂时放入UNDO-LIST队列<br>  如有提交的事务Tj，把Tj从UNDO-LIST队列移到REDO-LIST队列</li>
<li>4.对UNDO-LIST中的每个事务执行UNDO操作<br>  对REDO-LIST中的每个事务执行REDO操作<h5 id="数据库镜像"><a href="#数据库镜像" class="headerlink" title="数据库镜像"></a>数据库镜像</h5><h3 id="2016-2017"><a href="#2016-2017" class="headerlink" title="2016-2017"></a>2016-2017</h3>一、单项选择题（25 题，每题 2 分）</li>
</ul>
</li>
</ul>
<ol>
<li><p>以下哪个选项是对脏读的描述？<br>A.一个事务先后执行多次相同条件的查询，并且每次返回的数据都不相同。<br>B.在一个事务期间，基于特定标准的搜索在执行连续搜索之后返回额外的行<br>C.一个事务读了另外一个事务修改还未提交的数据.<br>D.两个事务读取并试图更新相同的数据，第二次更新将在第一次更新落实之前将其覆盖</p>
</li>
<li><p>C</p>
</li>
<li><p>如果使用下列语句创建tab1 CREATE TABLE tab1(<br>col1 INTEGER NOT NULL, col2 CHAR(3),<br>CONSTRAINT cst1 CHECK (col1 in (1,2,3,4)))<br>下列哪个语句会将记录成功插入表 TAB1？ <strong>C</strong><br>A.INSERT INTO tab1 VALUES (0, ‘a’)<br>B.INSERT INTO tab1 VALUES (NULL, ‘abc’)<br>C.INSERT INTO tab1 VALUES (4, ‘a’)<br>D.INSERT INTO tab1 VALUES (4, ‘abcdefhijklmnopq’)</p>
</li>
<li><p>数据库管理员需要在T1表中定义一个外关键字参考与T2表，下面描述正确是： A．在T1中外关键字属性可以是T2表的某个关键字属性的真子集。<br>B.在T1中外关键字属性名称必须与T2表的某个关键字属性名称相同。<br>C.在T1中外关键字属性的数据类型必须与T2表的某个关键字属性的数据完全相同（包括字符串的长度也要相同）<br>D.在T1中外关键字属性不能为空。</p>
</li>
<li><p>有T1和T2两个表，数据如下：<br>T1    T2</p>
</li>
</ol>
<p>C1    C2    C1    C2<br>5    4    5    1<br>5    2    5    2<br>5    5    5    3<br>下面哪个查询能够返回以下结果<br>C1    C2<br>5    4<br>5    5<br>A.SELECT * FROM T1 MINUS SELECT * FROM T2<br>B.SELECT * FROM T1 EXCEPT SELECT * FROM T2<br>C.SELECT * FRM T2 UNION EXCEPT SELECT * FROM T1<br>D.SELECT * FROM T1 NOT EXISTS SELECT * FROM T2</p>
<ol start="6">
<li><p>下面哪个SQL语句可以引起触发器运行？<br>A. DROP    B. ALTER<br>C. DELETE    D. ROLLBACK</p>
</li>
<li><p>下面关于索引说法正确的是？       A．索引可以提高insert语句的执行速度。<br>B．索引可以提高某些select语句的执行速度。C．索引可以提高所有select语句的执行速度。D．索引属性值不能为空。</p>
</li>
<li><p>张三需要在t1表上创建一个视图，在t1表上他最少需要什么权限：<br>A. insert    B.    delete<br>C. query    D.    select</p>
</li>
<li><p>张三需要在t2表上定义一个外关键字，这个外关键字参考与t1表，下面说法正确的是：<br>A．张三需要有t2表上的select权<br>B．张三需要有t1表上的select权<br>C．张三需要有t2表上的references权<br>D．张三需要有t1表上的references权</p>
</li>
<li><p>在使用JDBC编写的数据库应用中下面说法错误的是：<br>Ａ．可以定义事务的隔离级<br>Ｂ．可以指定事务能否自动提交<br>Ｃ．可以调用数据库定义的存储过程<br>Ｄ．不能查询数据库中已有的表的名称</p>
</li>
<li><p>A?</p>
</li>
<li><p>12.关于第三范式描述正确的是<br>A.如果一个关系属于第三范式那么它没有数据冗余<br>B.一个关系模式不存在非主属性部分依赖,它就是属于第三范式<br>C.一个关系模式不存在非主属性传递依赖,它就是属于第三范式<br>D.一个关系模式属于 BC 范式,它就属于第三范式</p>
</li>
<li><p>下面视图定义是中哪个是可更新视图:<br>A.Create view V1 as select    S.rating , avg(S.age) as avgage from Sailors S group by S.rating<br>B.Create view V2 as select    *    from saliros S1 where S.age&gt;18 union select * from sailors S2 where S2.name like ‘%Tom’<br>C.Create view V3 as select    S.name, R.bid from Sailor R, Reserves R where S.sid=R.sid<br>D.Create view V4 as select * from Boats B where B.bname like ‘%Happ%’</p>
</li>
<li><p>在数据库启动过程中恢复系统执行顺序是:<br>A.分析阶段,取消阶段,重做阶段<br>B.取消阶段,分析阶段,重做阶段<br>C.分析阶段,重做阶段,取消阶段<br>D.取消阶段,重做阶段,分析阶段.</p>
</li>
<li><p>一个企业有大量的数据需要存储在数据库中,由于某些原因要求存储的数据条带化分布,有冗余但冗余不能使用算法冗余.下面磁盘技术中采用哪种方法可以满足该要求:<br>A. RAID 0    B.RAID 1<br>C. RAID 0+1    D.RAID 5</p>
</li>
<li><p>在一个隔离级为读提交数据的事物中执行select * from sailors where 1=1查询，对该语句执行时在数据库中获得的锁下面哪个描述是最准确的？<br>A.获得sailors表的S锁，记录上不加锁。B.获得sailors表的IS锁及记录上的IS锁C.获得sailors表的S锁及记录上的IS锁 D.获得sailors表的IS锁及记录上的S锁</p>
</li>
<li><p>数据库语言包括 DDL，DML 和DCL,下面哪个语句是 DML 语句:<br>A.Create index<br>B.Drop table<br>C.Alter table<br>D.Update</p>
</li>
<li><p>有关系模式R(A,B,C)和三个合法实例(4,2,3),(4,2,3),(5,3,3),下面哪个函数依赖在关系模式R 上不成立<br>A.A-&gt;B    B.    BC-&gt;A    C. B-&gt;C    D. C-&gt;A</p>
</li>
<li><p>有关系模式R(A,B,C,D),其函数依赖集F={A-&gt;B,B-&gt;C,C-&gt;D,D-&gt;A},将R分解为AD，AB，BC请问该分解丢失了下面哪个函数依赖：<br>A．A-&gt;C    B.B-&gt;D    C.C-&gt;D    D.没有丢失函数依赖</p>
</li>
<li><p>有关系模式R(A,B,C,D,E,F),其函数依赖集F={A-&gt;B,B-&gt;C,C-&gt;A,    D-&gt;E},在该关系模式上有几个关键字：<br>A．1    B. 2    C.3    D.4</p>
</li>
<li><p>有关系模式 R(A,B,C,D,E),R 的函数依赖集 F={A-&gt; B,BC-&gt;E,ED-&gt;A},下面哪个说法是正确的:<br>A.R 是BCNF    B.R 是 3NF<br>C.分解(ACD,BCE)是无损分解    D.分解(ABD,CDE)是无损分解</p>
</li>
<li><p>有关系模式 R(A,B,C,D)下面哪个函数依赖集使得 R 是 BCNF A. F={C-&gt;D,C-&gt;A,B-&gt;C}    B. F={ABC-&gt;D,D-&gt;A}<br>C. F={B-&gt;C,D-&gt;A}    D. F={AB-&gt;C,C-&gt;D,C-&gt;AB}</p>
</li>
<li><p>在遵循严格2PL锁的规则的情况下，下面哪个调度会出现死锁: A.T1:R(X),T2:W(X),T2:W(Y),T3:W(Y),T1:W(Y)<br>B T1:R(X),T2:W(Y),T2:W(X),T3:W(Y),T1:W(Y),<br>C T1:R(A),T2:W(B),T1:R(A),T3:R(C),T2:W(C),T4:W(A)<br>D.T1:R(A),T2:W(B),T3:W(C),T1: Commit,T2:W(A), T2:Commit,T3:W(B), T3:Commit</p>
</li>
<li><p>下面关于数据库事务处理描述正确的是:   A．原子性和一致性是由数据库的并发调度保证的. B．隔离性和持久性是由数据库的并发调度保证的. C．原子性和持久性是由数据库的恢复系统保证的D．一致性和隔离性是由数据库的恢复系统保证的</p>
</li>
</ol>
<p>二．简单题（50 分）<br>在 mysql 中有 club 数据库，该数据库中有三个表分别是：<br>Sailors(sid char(10),sname char(20),rating int,age int，gender char(2)),其中 sid 是主关键字，sid 表示水手的编号，sname 表示水手的姓名，rating 表示水手的级别，age 表示水手的年龄,gender 表示水手的性别。<br>Boats(bid char(10),bname char(20),color char(10)，),其中 bid 表示船的编号是主关键字，bname 是船的名字，color 是船的颜色。<br>Reserves(sid char(10),bid char(10),rdate date),Reserves 中记录水手在哪天订了那只船，其中 sid 是指向 Sailors 的外关字， bid 是指向 Boats 的外关键字,(sid,bid,rdate)合起来构成 Reserves 的主关键字。<br>用关系代数写出下面的查询                                                </p>
<ol>
<li>查找只订过一艘红色船而没有订过其它颜色船的水手编号（该水手只订过一次船而且船的颜色是红色.）</li>
</ol>
<p>用元组关系验算写出下面的查询<br>2. 查找既订过红色船又订过绿色船水手的姓名和编号</p>
<p>用 SQL 语言写出下面的查询<br>3. 查找定了所有船的水手的编号和姓名</p>
<ol start="4">
<li>查找订过红色船也订过绿色船水手的编号和姓名</li>
</ol>
<p>students(sid: char(10),sname: char(20) , class:int)，Students 为软件学院 2015 级学生信<br>息表，sid 表示学生的学号，sname 为学生的姓名，class 为学生的班级，sid 为主关键<br>字。<br>course(cid:char(7),cname:string,teacher:string), Course 为软件学院 2015 级学生在<br>2016-2017 学期可选课程信息表，cid 表示课程号,cname 表示课程名,teacher 表示教<br>师，cid 是主关键字。<br>enrolled(sid:char(10),cid:char(7),grade:integer),Enrolled 为学生的选课信息表，sid 表示<br>学号, cid 表示课程号, grade 表示成绩。<br>用 SQL 语言写出下面的查询</p>
<ol start="5">
<li>统计各班学生的数据库原理的最高分。</li>
</ol>
<ol start="6">
<li>查找数据库原理课程平均分最高的班级中数据库原理课程的最低分。</li>
</ol>
<p>有关系模式 R(A,B,C,D,E,F,G,H,I),它的函数依赖集<br>F={AB-&gt;CD,A-&gt;E,B-&gt;FH,C-G,D-&gt;B,G-&gt;C,H-&gt;I}<br>7. 求解它的函数依赖集最小集</p>
<ol start="8">
<li>将其分解为三范式，该分解要具有无损连接性和依赖保持性.</li>
</ol>
<ol start="9">
<li>根据函数依赖公理即 Armstrong 公理，证明下面的定理<br>有关系模式 R，X,Y,W 是 R 的属性子集，如果 X-&gt;Y，YW-&gt;Z 成立，则 XW-&gt;Z 也成立。</li>
</ol>
<ol start="10">
<li>请详细描述数据库在启动时它的恢复算法</li>
</ol>
<p><a href="https://blog.csdn.net/sumaliqinghua/article/details/86246762" target="_blank" rel="noopener">推荐阅读1</a><br><a href="https://blog.csdn.net/sumaliqinghua/article/details/85872446#commentBox" target="_blank" rel="noopener">推荐阅读2</a><br><a href="https://blog.csdn.net/weixin_42578658/article/details/90744175" target="_blank" rel="noopener">不错的文章</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2019/12/19/Computer%20Networking/" rel="next" title="Computer Networking">
                  <i class="fa fa-chevron-left"></i> Computer Networking
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2019/12/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%81%AE%E6%91%98%E8%A6%81/" rel="prev" title="计算机网络の摘要">
                  计算机网络の摘要 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库复习"><span class="nav-number">1.</span> <span class="nav-text">数据库复习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">1.1.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2012-2013"><span class="nav-number">1.2.</span> <span class="nav-text">2012-2013</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#关系数据库设计理论"><span class="nav-number">1.2.1.</span> <span class="nav-text">关系数据库设计理论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#习题"><span class="nav-number">1.2.2.</span> <span class="nav-text">习题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关系模型基础"><span class="nav-number">1.2.3.</span> <span class="nav-text">关系模型基础:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代数查询语言"><span class="nav-number">1.2.4.</span> <span class="nav-text">代数查询语言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#E-R图"><span class="nav-number">1.2.5.</span> <span class="nav-text">E/R图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2013-2014"><span class="nav-number">1.3.</span> <span class="nav-text">2013-2014</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2015-2016"><span class="nav-number">1.4.</span> <span class="nav-text">2015-2016</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库语言SQL"><span class="nav-number">1.4.1.</span> <span class="nav-text">数据库语言SQL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事务其他相关"><span class="nav-number">1.4.2.</span> <span class="nav-text">事务其他相关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#约束与触发器"><span class="nav-number">1.4.3.</span> <span class="nav-text">约束与触发器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#视图与索引"><span class="nav-number">1.4.4.</span> <span class="nav-text">视图与索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存储过程"><span class="nav-number">1.4.5.</span> <span class="nav-text">存储过程 :</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#权限"><span class="nav-number">1.4.6.</span> <span class="nav-text">权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他部分"><span class="nav-number">1.4.7.</span> <span class="nav-text">其他部分:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库恢复技术"><span class="nav-number">1.4.8.</span> <span class="nav-text">数据库恢复技术</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#事务的基本概念"><span class="nav-number">1.4.8.1.</span> <span class="nav-text">事务的基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据库恢复概述"><span class="nav-number">1.4.8.2.</span> <span class="nav-text">数据库恢复概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#故障的种类"><span class="nav-number">1.4.8.3.</span> <span class="nav-text">故障的种类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#恢复的实现技术"><span class="nav-number">1.4.8.4.</span> <span class="nav-text">恢复的实现技术</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#恢复策略"><span class="nav-number">1.4.8.5.</span> <span class="nav-text">恢复策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#具有检查点的回复技术"><span class="nav-number">1.4.8.6.</span> <span class="nav-text">具有检查点的回复技术</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据库镜像"><span class="nav-number">1.4.8.7.</span> <span class="nav-text">数据库镜像</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2016-2017"><span class="nav-number">1.5.</span> <span class="nav-text">2016-2017</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="任林杰"
    src="/images/rlj.jpg">
  <p class="site-author-name" itemprop="name">任林杰</p>
  <div class="site-description" itemprop="description">建设最美114</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">任林杰</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">160k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:25</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
